{"version":3,"file":"9744.48addad0f1123d3b.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/xsd.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/xml.js"],"sourcesContent":["/**\n * @module ol/format/xsd\n */\nimport {padNumber} from '../string.js';\nimport {getAllTextContent, getDocument} from '../xml.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\nconst whiteSpaceStart = /^\\s/;\nconst whiteSpaceEnd = /\\s$/;\nconst cdataCharacters = /(\\n|\\t|\\r|<|&| {2})/;\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  if (\n    typeof string === 'string' &&\n    (whiteSpaceStart.test(string) ||\n      whiteSpaceEnd.test(string) ||\n      cdataCharacters.test(string))\n  ) {\n    string.split(']]>').forEach((part, i, a) => {\n      if (i < a.length - 1) {\n        part += ']]';\n      }\n      if (i > 0) {\n        part = '>' + part;\n      }\n      writeCDATASection(node, part);\n    });\n  } else {\n    node.appendChild(getDocument().createTextNode(string));\n  }\n}\n","/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {*} value Value to be written.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, value, objectStack) {\n      nodeWriter.call(thisArg ?? this, node, value, objectStack);\n      const parent = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const parentNode = parent.node;\n      parentNode.appendChild(node);\n    }\n  );\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined,\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack,\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n"],"names":["n","parseFloat","parseInt","c","Node","String","DOMParser","t","m","i","XMLSerializer","document"],"mappings":"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"}