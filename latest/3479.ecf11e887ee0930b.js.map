{"version":3,"file":"3479.ecf11e887ee0930b.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/common.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/Triangulation.js"],"sourcesContent":["/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n","/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution,\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter,\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution,\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution,\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution,\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle,\n  clipExtent,\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool,\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  const stitchScale = pixelRatio / sourceResolution;\n  // Round up Float32 scale values to prevent interpolation in Firefox.\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchContext = createCanvasContext2D(\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\n      canvasPool,\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n    if (sourceExtent && clipExtent) {\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\n      const width = getWidth(sourceExtent) * stitchScale;\n      const height = getHeight(sourceExtent) * stitchScale;\n      stitchContext.rect(xPos, yPos, width, height);\n      stitchContext.clip();\n    }\n\n    sources.forEach(function (src, i, arr) {\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        if (src.clipExtent) {\n          stitchContext.save();\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\n          const width = getWidth(src.clipExtent) * stitchScale;\n          const height = getHeight(src.clipExtent) * stitchScale;\n          stitchContext.rect(\n            interpolate ? xPos : Math.round(xPos),\n            interpolate ? yPos : Math.round(yPos),\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n          );\n          stitchContext.clip();\n        }\n\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\n        const srcWidth = getWidth(src.extent) * stitchScale;\n        const srcHeight = getHeight(src.extent) * stitchScale;\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate\n            ? srcWidth\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\n          interpolate\n            ? srcHeight\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\n        );\n\n        if (src.clipExtent) {\n          stitchContext.restore();\n        }\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1)),\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0,\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY,\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(inverseScale, -inverseScale);\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height,\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {\n  createTransformFromCoordinateTransform,\n  getTransform,\n  transform,\n} from '../proj.js';\nimport {apply as applyMatrix} from '../transform.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   * @param {import(\"../transform.js\").Transform} [sourceMatrix] Source transform matrix.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n    sourceMatrix,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = sourceMatrix\n      ? createTransformFromCoordinateTransform((input) =>\n          applyMatrix(\n            sourceMatrix,\n            transform(input, this.targetProj_, this.sourceProj_),\n          ),\n        )\n      : getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n"],"names":["Math","c","s","isFinite","t","e","d","i"],"mappings":"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"}