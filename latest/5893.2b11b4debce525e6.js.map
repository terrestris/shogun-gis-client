{"version":3,"file":"5893.2b11b4debce525e6.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/quickselect/index.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/node_modules/rbush/index.js"],"sourcesContent":["\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */\nexport default function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */\n        let j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n"],"names":["swap","arr","i","j","tmp","RBush","maxEntries","Math","bbox","node","result","intersects","toBBox","nodesToSearch","child","childBBox","contains","data","tmpNode","item","createNode","equalsFn","parent","goingUp","path","indexes","index","findItem","items","a","b","left","right","height","N","M","calcBBox","N2","N1","multiSelect","right2","right3","level","targetNode","minArea","Infinity","minEnlargement","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","m","splitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","minX","minY","maxX","maxY","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","xMargin","compare","leftBBox","rightBBox","margin","bboxMargin","siblings","k","p","destNode","children","n","stack","mid","quickselect","z","s","sd","newLeft","newRight","t"],"mappings":"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"}