{"version":3,"file":"5893.2b11b4debce525e6.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/quickselect/index.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/node_modules/rbush/index.js"],"sourcesContent":["\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */\nexport default function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */\n        let j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n"],"names":["i","Math","c","t","e","r","o","n"],"mappings":"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"}