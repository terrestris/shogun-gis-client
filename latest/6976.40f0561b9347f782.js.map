{"version":3,"file":"6976.40f0561b9347f782.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/ImageTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/layer/TileProperty.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/DataTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/structs/LRUCache.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/vec/mat4.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/webgl/Canvas.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/glreproj.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/DataTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/vec/mat4\n */\n\n/** @typedef {Array<number>} Mat4 */\n\n/**\n * @return {Mat4} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n/**\n * @param {Mat4} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Mat4} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n  mat4[0] = transform[0];\n  mat4[1] = transform[1];\n  mat4[4] = transform[2];\n  mat4[5] = transform[3];\n  mat4[12] = transform[4];\n  mat4[13] = transform[5];\n  return mat4;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @param {Mat4} [out] mat4 frustum matrix will be written into\n * @return {Mat4} out\n */\nexport function orthographic(left, right, bottom, top, near, far, out) {\n  out = out ?? create();\n  const lr = 1 / (left - right),\n    bt = 1 / (bottom - top),\n    nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3\n *\n * @param {Mat4} m The matrix to scale.\n * @param {number} x How much to scale in the x direction.\n * @param {number} y How much to scale in the y direction.\n * @param {number} z How much to scale in the z direction.\n * @param {Mat4} [out] The matrix to write to.\n * @return {Mat4} out\n **/\nexport function scale(m, x, y, z, out) {\n  out = out ?? create();\n  out[0] = m[0] * x;\n  out[1] = m[1] * x;\n  out[2] = m[2] * x;\n  out[3] = m[3] * x;\n  out[4] = m[4] * y;\n  out[5] = m[5] * y;\n  out[6] = m[6] * y;\n  out[7] = m[7] * y;\n  out[8] = m[8] * z;\n  out[9] = m[9] * z;\n  out[10] = m[10] * z;\n  out[11] = m[11] * z;\n  out[12] = m[12];\n  out[13] = m[13];\n  out[14] = m[14];\n  out[15] = m[15];\n  return out;\n}\n\n/**\n * Translate a matrix.\n *\n * @param {Mat4} m the matrix to translate\n * @param {number} x How much to translate in the x direction.\n * @param {number} y How much to translate in the y direction.\n * @param {number} z How much to translate in the z direction.\n * @param {Mat4} [out] the receiving matrix\n * @return {Mat4} out\n */\nexport function translate(m, x, y, z, out) {\n  out = out ?? create();\n  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;\n\n  if (m === out) {\n    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];\n    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];\n    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];\n    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];\n  } else {\n    a00 = m[0];\n    a01 = m[1];\n    a02 = m[2];\n    a03 = m[3];\n    a10 = m[4];\n    a11 = m[5];\n    a12 = m[6];\n    a13 = m[7];\n    a20 = m[8];\n    a21 = m[9];\n    a22 = m[10];\n    a23 = m[11];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n\n    out[12] = a00 * x + a10 * y + a20 * z + m[12];\n    out[13] = a01 * x + a11 * y + a21 * z + m[13];\n    out[14] = a02 * x + a12 * y + a22 * z + m[14];\n    out[15] = a03 * x + a13 * y + a23 * z + m[15];\n  }\n\n  return out;\n}\n\n/**\n * @param {number} x x translation.\n * @param {number} y y translation.\n * @param {number} z z translation.\n * @param {Mat4} [out] optional matrix to store result\n * @return {Mat4} out\n */\nexport function translation(x, y, z, out) {\n  out = out ?? create();\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = x;\n  out[13] = y;\n  out[14] = z;\n  out[15] = 1;\n\n  return out;\n}\n","import * as mat4 from '../vec/mat4.js';\n\n/**\n * @module ol/webgl/Canvas\n */\n\nconst VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec4 a_texcoord;\n\n  uniform mat4 u_matrix;\n  uniform mat4 u_textureMatrix;\n\n  varying vec2 v_texcoord;\n\n  void main() {\n    gl_Position = u_matrix * a_position;\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\n    v_texcoord = texcoord;\n  }\n`;\n\nconst FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (\n      v_texcoord.x < 0.0 ||\n      v_texcoord.y < 0.0 ||\n      v_texcoord.x > 1.0 ||\n      v_texcoord.y > 1.0\n    ) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\n\n/**\n * Canvas-like operations implemented in webgl.\n */\nexport class Canvas {\n  /**\n   * @param {WebGLRenderingContext} gl Context to render in.\n   */\n  constructor(gl) {\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\n\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\n\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\n    this.textureMatrixLocation = gl.getUniformLocation(\n      this.program_,\n      'u_textureMatrix',\n    );\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\n\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.positions),\n      gl.STATIC_DRAW,\n    );\n\n    this.texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.texcoords),\n      gl.STATIC_DRAW,\n    );\n  }\n\n  /**\n   * 2dContext drawImage call implemented in webgl.\n   * Unlike images, textures do not have a width and height associated\n   * with them so we'll pass in the width and height of the texture.\n   *\n   * @param {WebGLTexture} tex Image to draw.\n   * @param {number} texWidth Image width.\n   * @param {number} texHeight Image height.\n   * @param {number} srcX Top-left x-point to read src image.\n   * @param {number} srcY Top-left y-point to read src image.\n   * @param {number} [srcWidth] Width of source to read.\n   * @param {number} [srcHeight] Height of source to read.\n   * @param {number} [dstX] Top-left x-point of destination.\n   * @param {number} [dstY] Top-left y-point of destination.\n   * @param {number} [dstWidth] Width of written image in destination.\n   * @param {number} [dstHeight] Height of written image in destination.\n   * @param {number} [width] Width of canvas.\n   * @param {number} [height] Height of canvas.\n   */\n  drawImage(\n    tex,\n    texWidth,\n    texHeight,\n    srcX,\n    srcY,\n    srcWidth,\n    srcHeight,\n    dstX,\n    dstY,\n    dstWidth,\n    dstHeight,\n    width,\n    height,\n  ) {\n    const gl = this.gl_;\n\n    if (dstX === undefined) {\n      dstX = srcX;\n    }\n    if (dstY === undefined) {\n      dstY = srcY;\n    }\n    if (srcWidth === undefined) {\n      srcWidth = texWidth;\n    }\n    if (srcHeight === undefined) {\n      srcHeight = texHeight;\n    }\n    if (dstWidth === undefined) {\n      dstWidth = srcWidth;\n    }\n    if (dstHeight === undefined) {\n      dstHeight = srcHeight;\n    }\n    if (width === undefined) {\n      width = gl.canvas.width;\n    }\n    if (height === undefined) {\n      height = gl.canvas.height;\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n\n    gl.useProgram(this.program_);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    gl.enableVertexAttribArray(this.texcoordLocation);\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // matrix for converting pixels to clip space\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\n\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\n    texMatrix = mat4.scale(\n      texMatrix,\n      srcWidth / texWidth,\n      srcHeight / texHeight,\n      1,\n    );\n\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\n    gl.uniform1i(this.textureLocation, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {GLenum} type Type of shader.\n * @param {string} source source of shader.\n * @return {WebGLShader} [progam] The program.\n */\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  if (shader === null) {\n    throw new Error('Shader compilation failed');\n  }\n\n  gl.shaderSource(shader, source);\n\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const log = gl.getShaderInfoLog(shader);\n    if (log === null) {\n      throw new Error('Shader info log creation failed');\n    }\n    throw new Error(log);\n  }\n\n  return shader;\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {string} fragmentSource Fragment shader source.\n * @param {string} vertexSource Vertex shader source.\n * @return {WebGLProgram} [progam] The program.\n */\nexport function createProgram(gl, fragmentSource, vertexSource) {\n  const program = gl.createProgram();\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  if (program === null) {\n    throw new Error('Program creation failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const log = gl.getProgramInfoLog(program);\n    if (log === null) {\n      throw new Error('Program info log creation failed');\n    }\n    throw new Error();\n  }\n  return program;\n}\n","/**\n * @module ol/reproj/glreproj\n */\nimport * as mat4 from '../vec/mat4.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../has.js';\nimport {Canvas as WebGLCanvas, createProgram} from '../webgl/Canvas.js';\nimport {\n  createEmpty,\n  extend,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from '../extent.js';\n\nconst EDGE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n  }\n`;\nconst EDGE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  uniform vec4 u_val;\n  void main() {\n     gl_FragColor = u_val;\n  }\n`;\n\nconst TRIANGLE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec2 a_texcoord;\n\n  varying vec2 v_texcoord;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n     v_texcoord = a_texcoord;\n  }\n`;\nconst TRIANGLE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/**\n * Create an html canvas element and returns its webgl context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\n * @return {WebGLRenderingContext} The context.\n */\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {WebGLRenderingContext} */ (\n    canvas.getContext('webgl', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {WebGLRenderingContext} gl Context.\n */\nexport function releaseGLCanvas(gl) {\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n}\n\n/**\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\n */\nexport const canvasGLPool = [];\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"../extent.js\").Extent} extent Extent.\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\n * @property {WebGLTexture} texture Texture.\n * @property {number} width Width of texture.\n * @property {number} height Height of texture.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {WebGLRenderingContext} gl the context to render in.\n * @param {number} width_ Width of the canvas.\n * @param {number} height_ Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\n */\nexport function render(\n  gl,\n  width_,\n  height_,\n  pixelRatio,\n  sourceResolution,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  dataType,\n  renderEdges,\n  interpolate,\n  drawSingle,\n) {\n  const width = Math.round(pixelRatio * width_);\n  const height = Math.round(pixelRatio * height_);\n  gl.canvas.width = width;\n  gl.canvas.height = height;\n\n  /** @type {WebGLFramebuffer | null} */\n  let resultFrameBuffer;\n  /** @type {WebGLTexture | null} */\n  let resultTexture;\n  {\n    resultTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    resultFrameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      resultTexture,\n      0,\n    );\n  }\n\n  if (resultFrameBuffer === null) {\n    throw new Error('Could not create framebuffer');\n  }\n  if (resultTexture === null) {\n    throw new Error('Could not create texture');\n  }\n\n  if (sources.length === 0) {\n    return {\n      width,\n      height,\n      framebuffer: resultFrameBuffer,\n      texture: resultTexture,\n    };\n  }\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  /** @type {WebGLTexture | null} */\n  let stitchTexture;\n  /** @type {number} */\n  let stitchWidth;\n  /** @type {number} */\n  let stitchHeight;\n  const stitchScale = 1 / sourceResolution;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchTexture = gl.createTexture();\n    if (resultTexture === null) {\n      throw new Error('Could not create texture');\n    }\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\n\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    const largeSide = Math.max(stitchWidth, stitchHeight);\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\n\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      stitchWidthFixed,\n      stitchHeightFixed,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      stitchTexture,\n      0,\n    );\n    const webGLCanvas = new WebGLCanvas(gl);\n\n    sources.forEach(function (src, i, arr) {\n      const xPos =\n        (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n      const yPos =\n        -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\n\n      if (src.clipExtent) {\n        const xPos =\n          (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n        const yPos =\n          -(src.clipExtent[3] - sourceDataExtent[3]) *\n          stitchScale *\n          scaleFactor;\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n          interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n        );\n      }\n\n      webGLCanvas.drawImage(\n        src.texture,\n        src.width,\n        src.height,\n        gutter,\n        gutter,\n        src.width - 2 * gutter,\n        src.height - 2 * gutter,\n        interpolate ? xPos : Math.round(xPos),\n        interpolate ? yPos : Math.round(yPos),\n        interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),\n        interpolate\n          ? srcHeight\n          : Math.round(yPos + srcHeight) - Math.round(yPos),\n        stitchWidthFixed,\n        stitchHeightFixed,\n      );\n\n      gl.disable(gl.SCISSOR_TEST);\n    });\n    gl.deleteFramebuffer(fb);\n  } else {\n    stitchTexture = sources[0].texture;\n    stitchWidth = sources[0].width;\n    stitchHeight = sources[0].width;\n  }\n\n  const targetTopLeft = getTopLeft(targetExtent);\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\n\n  const getUVs = (\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ target,\n  ) => {\n    const u0 =\n      ((target[0][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v0 =\n      (-(target[0][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u1 =\n      ((target[1][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v1 =\n      (-(target[1][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u2 =\n      ((target[2][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v2 =\n      (-(target[2][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    return {u1, v1, u0, v0, u2, v2};\n  };\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n  gl.viewport(0, 0, width, height);\n\n  // Draw source to reprojtile\n  {\n    /** @type {Array<number>} */\n    const vertices = [];\n    /** @type {Array<number>} */\n    const texcoords = [];\n\n    const triProgram = createProgram(\n      gl,\n      TRIANGLE_FRAGMENT_SHADER,\n      TRIANGLE_VERTEX_SHADER,\n    );\n    gl.useProgram(triProgram);\n\n    // Bind image\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    // Tell the shader to get the texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // Calculate vert and tex coordinates.\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const source = triangle.source;\n      const target = triangle.target;\n      // Make sure that everything is on pixel boundaries\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      const su0 =\n        (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv0 =\n        -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su1 =\n        (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv1 =\n        -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su2 =\n        (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv2 =\n        -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n\n      vertices.push(u1, v1, u0, v0, u2, v2);\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\n    });\n\n    // Convert pixel space to clip space.\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\n    const texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\n  }\n\n  if (renderEdges) {\n    const edgeProgram = createProgram(\n      gl,\n      EDGE_FRAGMENT_SHADER,\n      EDGE_VERTEX_SHADER,\n    );\n    gl.useProgram(edgeProgram);\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\n    const isFloat = true;\n    if (isFloat) {\n      gl.uniform4fv(burnvalLocation, burnval);\n    } else {\n      gl.uniform4iv(burnvalLocation, burnval);\n    }\n\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    /** @type {Array<number>} */\n    const lines = triangulation.getTriangles().reduce(function (\n      /** @type {Array<number>} */ lines,\n      triangle,\n    ) {\n      const target = triangle.target;\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\n    }, []);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\n  }\n\n  return {\n    width,\n    height,\n    framebuffer: resultFrameBuffer,\n    texture: resultTexture,\n  };\n}\n","/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {calculateSourceExtentResolution} from '../reproj.js';\nimport {\n  canvasGLPool,\n  createCanvasContextWebGL,\n  releaseGLCanvas,\n  render as renderReprojected,\n} from './glreproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\n * @property {boolean} [renderEdges] Render reprojection edges.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {boolean | Array<number>}\n     */\n    this.renderEdges_ =\n      options.renderEdges !== undefined ? options.renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n      options.transformMatrix,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: tileDataR,\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n        bandCount: bandCount,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const outWidth = targetWidth * this.pixelRatio_;\n    const outHeight = targetHeight * this.pixelRatio_;\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n\n    const bandCount = dataSources[0].bandCount;\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\n\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\n      premultipliedAlpha: false,\n      antialias: false,\n    });\n\n    let willInterpolate;\n    const format = gl.RGBA;\n    let textureType;\n    if (dataSources[0].dataType == Float32Array) {\n      textureType = gl.FLOAT;\n      gl.getExtension('WEBGL_color_buffer_float');\n      gl.getExtension('OES_texture_float');\n      gl.getExtension('EXT_float_blend');\n      const extension = gl.getExtension('OES_texture_float_linear');\n      const canInterpolate = extension !== null;\n      willInterpolate = canInterpolate && this.interpolate;\n    } else {\n      textureType = gl.UNSIGNED_BYTE;\n      willInterpolate = this.interpolate;\n    }\n\n    const BANDS_PR_REPROJ = 4;\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\n        const dataS = dataSource.data;\n        let offset = reproj * BANDS_PR_REPROJ;\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\n          data[j] = dataS[offset];\n          data[j + 1] = dataS[offset + 1];\n          data[j + 2] = dataS[offset + 2];\n          data[j + 3] = dataS[offset + 3];\n          offset += bandCount;\n        }\n\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        if (willInterpolate) {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        } else {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          format,\n          width,\n          height,\n          0,\n          format,\n          textureType,\n          data,\n        );\n\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          texture: texture,\n          width: width,\n          height: height,\n        });\n      }\n\n      const {framebuffer, width, height} = renderReprojected(\n        gl,\n        targetWidth,\n        targetHeight,\n        this.pixelRatio_,\n        sourceResolution,\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        textureType,\n        this.renderEdges_,\n        willInterpolate,\n      );\n\n      // The texture is always RGBA.\n      const rows = width;\n      const cols = height * BANDS_PR_REPROJ;\n      const data = new dataSources[0].dataType(rows * cols);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\n\n      let offset = reproj * BANDS_PR_REPROJ;\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\n        const flipY = (rows - 1 - ((i / cols) | 0)) * cols + (i % cols);\n        dataR[offset] = data[flipY];\n        dataR[offset + 1] = data[flipY + 1];\n        dataR[offset + 2] = data[flipY + 2];\n        dataR[offset + 3] = data[flipY + 3];\n        offset += bandCount;\n      }\n    }\n\n    releaseGLCanvas(gl);\n    canvasGLPool.push(gl.canvas);\n\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (\n          state == TileState.LOADED ||\n          state == TileState.ERROR ||\n          state == TileState.EMPTY\n        ) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.get(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.get(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  * maybe skip transition when not fully opaque\n     *  * decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tileState === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n"],"names":["ImageTile","tileCoord","state","src","crossOrigin","tileLoadFunction","options","Image","element","getBlankImage","ctx","image","asImageLike","data","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","disposedError","Error","sharedContext","defaultSize","DataTile","Tile","TileState","imageData","self","error","LRUCache","highWaterMark","undefined","entry","Disposable","keep","key","f","keys","Array","i","values","value","size","create","orthographic","left","right","bottom","top","near","far","out","lr","bt","nf","scale","m","x","y","z","VERTEX_SHADER","FRAGMENT_SHADER","Canvas","gl","createProgram","Float32Array","tex","texWidth","texHeight","srcX","srcY","srcWidth","srcHeight","dstX","dstY","dstWidth","dstHeight","width","height","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","matrix","texMatrix","createShader","type","source","shader","log","fragmentSource","vertexSource","program","vertexShader","fragmentShader","EDGE_VERTEX_SHADER","EDGE_FRAGMENT_SHADER","TRIANGLE_VERTEX_SHADER","TRIANGLE_FRAGMENT_SHADER","canvasGLPool","ReprojDataTile","Promise","Uint8ClampedArray","sourceProj","sourceProjExtent","sourceTileGridExtent","targetExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","targetResolution","targetProj","sourceResolution","isFinite","errorThresholdInPixels","Triangulation","sourceExtent","worldWidth","worldsAway","Math","sourceExtents","extent","sourceRange","getTile","tile","offset","canvasPool","settings","willInterpolate","textureType","canvas","dataSources","imageLike","tileData","gutter","arrayData","Uint8Array","DataView","toArray","pixelSize","isFloat","pixelCount","DataType","tileDataR","bytesPerElement","bytesPerPixel","bandCount","bytesPerRow","clipExtent","targetWidth","targetHeight","outWidth","outHeight","dataR","OffscreenCanvas","document","format","extension","canInterpolate","reprojs","reproj","sources","len","dataSource","BANDS_PR_REPROJ","dataS","j","texture","framebuffer","render","width_","height_","pixelRatio","triangulation","dataType","renderEdges","interpolate","drawSingle","resultFrameBuffer","resultTexture","stitchTexture","stitchWidth","stitchHeight","sourceDataExtent","arr","stitchScale","maxTexSize","largeSide","scaleFactor","stitchWidthFixed","stitchHeightFixed","fb","webGLCanvas","xPos","yPos","targetTopLeft","sourceTopLeft","getUVs","target","u0","v0","u1","v1","u2","v2","vertices","texcoords","triProgram","textureLocation","triangle","su0","sv0","su1","sv1","su2","sv2","matrixLocation","positionLocation","positionBuffer","texcoordLocation","texcoordBuffer","edgeProgram","burnval","burnvalLocation","lines","cols","rows","flipY","releaseGLCanvas","context","ImageData","leftToLoad","sourceListenKey","EventType","setTimeout","getCacheKey","sourceKey","addTileToLookup","tilesByZ","Set","set","existing","getRenderExtent","frameState","layerState","gridExtent","CanvasTileLayerRenderer","tileLayer","TileRange","cacheSize","tileCache","tileSource","cacheKey","pixel","layer","coordinate","layerExtent","viewState","tileGrid","tilePixelRatio","tileOrigin","tileSize","tileResolution","col","row","sourceRevision","initialZ","preload","tileSourceKey","wantedTiles","map","minZ","tileRange","tileQueueKey","staleKeys","altZ","covered","loaded","currentClip","allTilesIdle","projection","viewResolution","viewCenter","frameExtent","dx","dy","canvasExtent","targetZ","nextExtent","renderExtent","uid","time","tileState","alpha","removeTileFromLookup","minZoom","parentZ","canvasScale","zs","Object","Number","clips","clipZs","currentZ","currentTilePixelSize","currentScale","currentResolution","originTileCoord","originTileExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","tilesCount","tileCount","alphaChanged","usedTiles","ReprojTile","sourceTileGrid","targetTileGrid","wrappedTileCoord","getTileFunction","errorThreshold","e"],"mappings":"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"}