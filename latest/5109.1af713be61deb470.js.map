{"version":3,"file":"5109.1af713be61deb470.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/extent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/extent/Relationship.js"],"sourcesContent":["/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\n\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n  const extent = createEmpty();\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [dest] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, dest) {\n  const minX = Math.min.apply(null, xs);\n  const minY = Math.min.apply(null, ys);\n  const maxX = Math.max.apply(null, xs);\n  const maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\n}\n\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, dest) {\n  if (dest) {\n    dest[0] = extent[0] - value;\n    dest[1] = extent[1] - value;\n    dest[2] = extent[2] + value;\n    dest[3] = extent[3] + value;\n    return dest;\n  }\n  return [\n    extent[0] - value,\n    extent[1] - value,\n    extent[2] + value,\n    extent[3] + value,\n  ];\n}\n\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [dest] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent.slice();\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n  let dx, dy;\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[0] &&\n    extent2[2] <= extent1[2] &&\n    extent1[1] <= extent2[1] &&\n    extent2[3] <= extent1[3]\n  );\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const x = coordinate[0];\n  const y = coordinate[1];\n  let relationship = Relationship.UNKNOWN;\n  if (x < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n  if (y < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n  return relationship;\n}\n\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\n  if (dest) {\n    dest[0] = minX;\n    dest[1] = minY;\n    dest[2] = maxX;\n    dest[3] = maxY;\n    return dest;\n  }\n  return [minX, minY, maxX, maxY];\n}\n\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(dest) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  return createOrUpdate(x, y, x, y, dest);\n}\n\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendCoordinates(extent, coordinates);\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  dest,\n) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendRings(extent, rings);\n}\n\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n  return (\n    extent1[0] == extent2[0] &&\n    extent1[2] == extent2[2] &&\n    extent1[1] == extent2[1] &&\n    extent1[3] == extent2[3]\n  );\n}\n\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n  return (\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\n    Math.abs(extent1[3] - extent2[3]) < tolerance\n  );\n}\n\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(\n  extent,\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n  let val;\n  val = callback(getBottomLeft(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getBottomRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopLeft(extent));\n  if (val) {\n    return val;\n  }\n  return false;\n}\n\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n  let area = 0;\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n  return area;\n}\n\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n  let coordinate;\n  if (corner === 'bottom-left') {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === 'bottom-right') {\n    coordinate = getBottomRight(extent);\n  } else if (corner === 'top-left') {\n    coordinate = getTopLeft(extent);\n  } else if (corner === 'top-right') {\n    coordinate = getTopRight(extent);\n  } else {\n    throw new Error('Invalid corner');\n  }\n  return coordinate;\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n  const minX = Math.min(extent1[0], extent2[0]);\n  const minY = Math.min(extent1[1], extent2[1]);\n  const maxX = Math.max(extent1[2], extent2[2]);\n  const maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\n    center,\n    resolution,\n    rotation,\n    size,\n  );\n  return createOrUpdate(\n    Math.min(x0, x1, x2, x3),\n    Math.min(y0, y1, y2, y3),\n    Math.max(x0, x1, x2, x3),\n    Math.max(y0, y1, y2, y3),\n    dest,\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\nexport function getRotatedViewport(center, resolution, rotation, size) {\n  const dx = (resolution * size[0]) / 2;\n  const dy = (resolution * size[1]) / 2;\n  const cosRotation = Math.cos(rotation);\n  const sinRotation = Math.sin(rotation);\n  const xCos = dx * cosRotation;\n  const xSin = dx * sinRotation;\n  const yCos = dy * cosRotation;\n  const ySin = dy * sinRotation;\n  const x = center[0];\n  const y = center[1];\n  return [\n    x - xCos + ySin,\n    y - xSin - yCos,\n    x - xCos - ySin,\n    y - xSin + yCos,\n    x + xCos - ySin,\n    y + xSin + yCos,\n    x + xCos + ySin,\n    y + xSin - yCos,\n    x - xCos + ySin,\n    y - xSin - yCos,\n  ];\n}\n\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n  return extent[3] - extent[1];\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n  const intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [dest] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, dest) {\n  const intersection = dest ? dest : createEmpty();\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n  return intersection;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n  return extent[2] - extent[0];\n}\n\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[2] &&\n    extent1[2] >= extent2[0] &&\n    extent1[1] <= extent2[3] &&\n    extent1[3] >= extent2[1]\n  );\n}\n\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n  let intersects = false;\n  const startRel = coordinateRelationship(extent, start);\n  const endRel = coordinateRelationship(extent, end);\n  if (\n    startRel === Relationship.INTERSECTING ||\n    endRel === Relationship.INTERSECTING\n  ) {\n    intersects = true;\n  } else {\n    const minX = extent[0];\n    const minY = extent[1];\n    const maxX = extent[2];\n    const maxY = extent[3];\n    const startX = start[0];\n    const startY = start[1];\n    const endX = end[0];\n    const endY = end[1];\n    const slope = (endY - startY) / (endX - startX);\n    let x, y;\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.RIGHT) &&\n      !(startRel & Relationship.RIGHT)\n    ) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.BELOW) &&\n      !(startRel & Relationship.BELOW)\n    ) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.LEFT) &&\n      !(startRel & Relationship.LEFT)\n    ) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n  return intersects;\n}\n\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [dest] Destination extent.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, dest, stops) {\n  if (isEmpty(extent)) {\n    return createOrUpdateEmpty(dest);\n  }\n  let coordinates = [];\n  if (stops > 1) {\n    const width = extent[2] - extent[0];\n    const height = extent[3] - extent[1];\n    for (let i = 0; i < stops; ++i) {\n      coordinates.push(\n        extent[0] + (width * i) / stops,\n        extent[1],\n        extent[2],\n        extent[1] + (height * i) / stops,\n        extent[2] - (width * i) / stops,\n        extent[3],\n        extent[0],\n        extent[3] - (height * i) / stops,\n      );\n    }\n  } else {\n    coordinates = [\n      extent[0],\n      extent[1],\n      extent[2],\n      extent[1],\n      extent[2],\n      extent[3],\n      extent[0],\n      extent[3],\n    ];\n  }\n  transformFn(coordinates, coordinates, 2);\n  const xs = [];\n  const ys = [];\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\n    xs.push(coordinates[i]);\n    ys.push(coordinates[i + 1]);\n  }\n  return _boundingExtentXYs(xs, ys, dest);\n}\n\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n  const projectionExtent = projection.getExtent();\n  const center = getCenter(extent);\n  if (\n    projection.canWrapX() &&\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\n  ) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.floor(\n      (center[0] - projectionExtent[0]) / worldWidth,\n    );\n    const offset = worldsAway * worldWidth;\n    extent[0] -= offset;\n    extent[2] -= offset;\n  }\n  return extent;\n}\n\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @param {boolean} [multiWorld] Return all worlds\n * @return {Array<Extent>} The extent within the real world extent.\n */\nexport function wrapAndSliceX(extent, projection, multiWorld) {\n  if (projection.canWrapX()) {\n    const projectionExtent = projection.getExtent();\n\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n\n    wrapX(extent, projection);\n    const worldWidth = getWidth(projectionExtent);\n\n    if (getWidth(extent) > worldWidth && !multiWorld) {\n      // the extent wraps around on itself\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n    if (extent[0] < projectionExtent[0]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\n      ];\n    }\n    if (extent[2] > projectionExtent[2]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\n      ];\n    }\n  }\n\n  return [extent];\n}\n","/**\n * @module ol/extent/Relationship\n */\n\n/**\n * Relationship to an extent.\n * @enum {number}\n */\nexport default {\n  UNKNOWN: 0,\n  INTERSECTING: 1,\n  ABOVE: 2,\n  RIGHT: 4,\n  BELOW: 8,\n  LEFT: 16,\n};\n"],"names":["boundingExtent","coordinates","extent","createEmpty","i","ii","extendCoordinate","buffer","value","dest","clone","closestSquaredDistanceXY","x","y","dx","dy","containsCoordinate","coordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","minX","minY","maxX","maxY","relationship","Infinity","createOrUpdate","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromCoordinates","extendCoordinates","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","end","stride","extendFlatCoordinates","createOrUpdateFromRings","rings","extendRings","equals","approximatelyEquals","tolerance","Math","extend","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","isEmpty","getWidth","getHeight","getCenter","getCorner","corner","Error","getEnlargedArea","getForViewAndSize","center","resolution","rotation","size","x0","y0","x1","y1","x2","y2","x3","y3","getRotatedViewport","cosRotation","sinRotation","xCos","xSin","yCos","ySin","getIntersectionArea","getIntersection","intersection","intersects","getMargin","getSize","returnOrUpdate","scaleFromCenter","deltaX","deltaY","intersectsSegment","start","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","stops","width","height","xs","ys","l","_boundingExtentXYs","wrapX","projection","projectionExtent","worldWidth","worldsAway","wrapAndSliceX","multiWorld","isFinite"],"mappings":"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"}