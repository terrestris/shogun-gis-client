{"version":3,"file":"8555.4f32425a9cc82561.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/ImageTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/DataTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/structs/LRUCache.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/layer/TileProperty.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/ImageTile\n */\nimport {listenImage} from './Image.js';\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/reproj/Tile\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {releaseCanvas} from '../dom.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n"],"names":["Image","e","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","Error","Array","i","t","Set","s","g","l","Math","setTimeout","Object","Number","isFinite"],"mappings":"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"}