{"version":3,"file":"3479.eec6f3a0b0cdfe4f.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/Triangulation.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/common.js"],"sourcesContent":["/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution,\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter,\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution,\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution,\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution,\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle,\n  clipExtent,\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool,\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  const stitchScale = pixelRatio / sourceResolution;\n  // Round up Float32 scale values to prevent interpolation in Firefox.\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchContext = createCanvasContext2D(\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\n      canvasPool,\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n    if (sourceExtent && clipExtent) {\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\n      const width = getWidth(sourceExtent) * stitchScale;\n      const height = getHeight(sourceExtent) * stitchScale;\n      stitchContext.rect(xPos, yPos, width, height);\n      stitchContext.clip();\n    }\n\n    sources.forEach(function (src, i, arr) {\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        if (src.clipExtent) {\n          stitchContext.save();\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\n          const width = getWidth(src.clipExtent) * stitchScale;\n          const height = getHeight(src.clipExtent) * stitchScale;\n          stitchContext.rect(\n            interpolate ? xPos : Math.round(xPos),\n            interpolate ? yPos : Math.round(yPos),\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n          );\n          stitchContext.clip();\n        }\n\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\n        const srcWidth = getWidth(src.extent) * stitchScale;\n        const srcHeight = getHeight(src.extent) * stitchScale;\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate\n            ? srcWidth\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\n          interpolate\n            ? srcHeight\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\n        );\n\n        if (src.clipExtent) {\n          stitchContext.restore();\n        }\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1)),\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0,\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY,\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(inverseScale, -inverseScale);\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height,\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {\n  createTransformFromCoordinateTransform,\n  getTransform,\n  transform,\n} from '../proj.js';\nimport {apply as applyMatrix} from '../transform.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   * @param {import(\"../transform.js\").Transform} [sourceMatrix] Source transform matrix.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n    sourceMatrix,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = sourceMatrix\n      ? createTransformFromCoordinateTransform((input) =>\n          applyMatrix(\n            sourceMatrix,\n            transform(input, this.targetProj_, this.sourceProj_),\n          ),\n        )\n      : getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n"],"names":["brokenDiagonalRendering_","canvasPool","drawTestTriangle","ctx","u1","v1","u2","v2","Math","verifyBrokenDiagonalRendering","data","offset","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","undefined","sourceMetersPerUnit","sourceExtent","compensationFactor","isFinite","calculateSourceExtentResolution","targetExtent","corner","render","width","height","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","drawSingle","clipExtent","stitchContext","context","pixelRound","value","sourceDataExtent","src","i","arr","stitchScale","inverseScale","xPos","yPos","srcWidth","srcHeight","targetTopLeft","triangle","image","source","target","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","isBrokenDiagonalRendering","ud","vd","step","steps","extent","maxSourceExtent","errorThreshold","destinationResolution","sourceMatrix","transformInvCache","transformInv","input","c","key","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","MAX_SUBDIVISION","leftBound","Infinity","newTriangle","minX","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","targetCoverageX","isNotFinite","dx","center","centerSrc","centerSrcEstimX","dy","centerSrcErrorSquared","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","ERROR_THRESHOLD"],"mappings":"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"}