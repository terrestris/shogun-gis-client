{"version":3,"file":"8573.8c19c74ac05f2048.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/TextFeature.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/WKT.js"],"sourcesContent":["/**\n * @module ol/format/TextFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for text feature formats.\n *\n * @abstract\n */\nclass TextFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'text';\n  }\n\n  /**\n   * Read the feature from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromText(\n      getText(source),\n      this.adaptOptions(options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the features from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromText(\n      getText(source),\n      this.adaptOptions(options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the geometry from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   * @override\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromText(\n      getText(source),\n      this.adaptOptions(options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    return this.readProjectionFromText(getText(source));\n  }\n\n  /**\n   * @param {string} text Text.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjectionFromText(text) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as a string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   * @override\n   */\n  writeFeature(feature, options) {\n    return this.writeFeatureText(feature, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    return this.writeFeaturesText(features, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Geometry.\n   * @api\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    return this.writeGeometryText(geometry, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {string} Text.\n */\nfunction getText(source) {\n  if (typeof source === 'string') {\n    return source;\n  }\n  return '';\n}\n\nexport default TextFeature;\n","/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {transformGeometryWithOptions} from './Feature.js';\nimport TextFeature from './TextFeature.js';\n\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\n */\nconst GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon,\n};\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY';\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z';\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M';\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM';\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6,\n};\n\n/**\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\n */\nconst wktTypeLookup = {\n  Point: 'POINT',\n  LineString: 'LINESTRING',\n  Polygon: 'POLYGON',\n  MultiPoint: 'MULTIPOINT',\n  MultiLineString: 'MULTILINESTRING',\n  MultiPolygon: 'MULTIPOLYGON',\n  GeometryCollection: 'GEOMETRYCOLLECTION',\n  Circle: 'CIRCLE',\n};\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean} [decimal] Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, decimal) {\n    decimal = decimal !== undefined ? decimal : false;\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal);\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_);\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_();\n    const position = this.index_;\n    /** @type {number|string} */\n    let value = c;\n    let type;\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n\n    return {position: position, value: value, type: type};\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c;\n    const index = this.index_;\n    let decimal = false;\n    let scientificNotation = false;\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n      c = this.nextChar_();\n    } while (\n      this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      (scientificNotation && (c == '-' || c == '+'))\n    );\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c;\n    const index = this.index_;\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_ = {\n      position: 0,\n      type: TokenType.START,\n    };\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken();\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    return this.token_.type == type;\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_();\n    return this.parseGeometry_();\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n    let layout = 'XY';\n    const dimToken = this.token_;\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value;\n      if (dimInfo === Z) {\n        layout = 'XYZ';\n      } else if (dimInfo === M) {\n        layout = 'XYM';\n      } else if (dimInfo === ZM) {\n        layout = 'XYZM';\n      }\n      if (layout !== 'XY') {\n        this.consume_();\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates;\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = [];\n    const dimensions = this.layout_.length;\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_;\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push(/** @type {number} */ (token.value));\n      } else {\n        break;\n      }\n    }\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty =\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n    if (isEmpty) {\n      this.consume_();\n    }\n    return isEmpty;\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return (\n      'Unexpected `' +\n      this.token_.value +\n      '` at position ' +\n      this.token_.position +\n      ' in `' +\n      this.lexer_.wkt +\n      '`'\n    );\n  }\n\n  /**\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const token = this.token_;\n    if (this.match(TokenType.TEXT)) {\n      const geomType = /** @type {string} */ (token.value);\n      this.layout_ = this.parseGeometryLayout_();\n      const isEmpty = this.isEmptyGeometry_();\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        if (isEmpty) {\n          return new GeometryCollection([]);\n        }\n        const geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      }\n      const ctor = GeometryConstructor[geomType];\n      if (!ctor) {\n        throw new Error('Invalid geometry type: ' + geomType);\n      }\n\n      let coordinates;\n\n      if (isEmpty) {\n        if (geomType == 'POINT') {\n          coordinates = [NaN, NaN];\n        } else {\n          coordinates = [];\n        }\n      } else {\n        switch (geomType) {\n          case 'POINT': {\n            coordinates = this.parsePointText_();\n            break;\n          }\n          case 'LINESTRING': {\n            coordinates = this.parseLineStringText_();\n            break;\n          }\n          case 'POLYGON': {\n            coordinates = this.parsePolygonText_();\n            break;\n          }\n          case 'MULTIPOINT': {\n            coordinates = this.parseMultiPointText_();\n            break;\n          }\n          case 'MULTILINESTRING': {\n            coordinates = this.parseMultiLineStringText_();\n            break;\n          }\n          case 'MULTIPOLYGON': {\n            coordinates = this.parseMultiPolygonText_();\n            break;\n          }\n          default:\n            break;\n        }\n      }\n\n      return new ctor(coordinates, this.layout_);\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n}\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nclass WKT extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    this.splitCollection_ =\n      options.splitCollection !== undefined ? options.splitCollection : false;\n  }\n\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n  parse_(wkt) {\n    const lexer = new Lexer(wkt);\n    const parser = new Parser(lexer);\n    return parser.parse();\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @override\n   */\n  readFeatureFromText(text, options) {\n    const geom = this.readGeometryFromText(text, options);\n    const feature = new Feature();\n    feature.setGeometry(geom);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   * @override\n   */\n  readFeaturesFromText(text, options) {\n    let geometries = [];\n    const geometry = this.readGeometryFromText(text, options);\n    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\n      geometries = /** @type {GeometryCollection} */ (\n        geometry\n      ).getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    const features = [];\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n    return features;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromText(text, options) {\n    const geometry = this.parse_(text);\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   * @override\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    }\n    return '';\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   * @override\n   */\n  writeFeaturesText(features, options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], options);\n    }\n    const geometries = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n    const collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, options);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   * @override\n   */\n  writeGeometryText(geometry, options) {\n    return encode(transformGeometryWithOptions(geometry, true, options));\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  if (coordinates.length === 0) {\n    return '';\n  }\n  return coordinates.join(' ');\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = [];\n  const components = geom.getPoints();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = [];\n  const geoms = geom.getGeometries();\n  for (let i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  const array = [];\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = [];\n  const components = geom.getLineStrings();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = [];\n  const rings = geom.getLinearRings();\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = [];\n  const components = geom.getPolygons();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  const layout = geom.getLayout();\n  let dimInfo = '';\n  if (layout === 'XYZ' || layout === 'XYZM') {\n    dimInfo += Z;\n  }\n  if (layout === 'XYM' || layout === 'XYZM') {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry,\n};\n\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  const type = geom.getType();\n  const geometryEncoder = GeometryEncoder[type];\n  const enc = geometryEncoder(geom);\n  let wktType = wktTypeLookup[type];\n  if (typeof (/** @type {?} */ (geom).getFlatCoordinates) === 'function') {\n    const dimInfo = encodeGeometryLayout(\n      /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom),\n    );\n    if (dimInfo.length > 0) {\n      wktType += ' ' + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return wktType + ' ' + EMPTY;\n  }\n  return wktType + '(' + enc + ')';\n}\n\nexport default WKT;\n"],"names":["t","E","Error","parseFloat","i","NaN","r"],"mappings":"qTAcA,OAAM,UAAoB,IAAa,CACrC,aAAc,CACZ,KAAK,EACP,CAMA,SAAU,CACR,MAAO,MACT,CAWA,YAAY,CAAM,CAAE,CAAO,CAAE,CAC3B,OAAO,IAAI,CAAC,mBAAmB,CAC7B,EAAQ,GACR,IAAI,CAAC,YAAY,CAAC,GAEtB,CASA,oBAAoBA,CAAI,CAAE,CAAO,CAAE,CACjC,MAAO,gBACT,CAWA,aAAa,CAAM,CAAE,CAAO,CAAE,CAC5B,OAAO,IAAI,CAAC,oBAAoB,CAC9B,EAAQ,GACR,IAAI,CAAC,YAAY,CAAC,GAEtB,CASA,qBAAqBA,CAAI,CAAE,CAAO,CAAE,CAClC,MAAO,gBACT,CAWA,aAAa,CAAM,CAAE,CAAO,CAAE,CAC5B,OAAO,IAAI,CAAC,oBAAoB,CAC9B,EAAQ,GACR,IAAI,CAAC,YAAY,CAAC,GAEtB,CASA,qBAAqBA,CAAI,CAAE,CAAO,CAAE,CAClC,MAAO,gBACT,CAUA,eAAe,CAAM,CAAE,CACrB,OAAO,IAAI,CAAC,sBAAsB,CAAC,EAAQ,GAC7C,CAOA,uBAAuBA,CAAI,CAAE,CAC3B,OAAO,IAAI,CAAC,cAAc,AAC5B,CAWA,aAAa,CAAO,CAAE,CAAO,CAAE,CAC7B,OAAO,IAAI,CAAC,gBAAgB,CAAC,EAAS,IAAI,CAAC,YAAY,CAAC,GAC1D,CASA,iBAAiB,CAAO,CAAE,CAAO,CAAE,CACjC,MAAO,gBACT,CAWA,cAAc,CAAQ,CAAE,CAAO,CAAE,CAC/B,OAAO,IAAI,CAAC,iBAAiB,CAAC,EAAU,IAAI,CAAC,YAAY,CAAC,GAC5D,CASA,kBAAkB,CAAQ,CAAE,CAAO,CAAE,CACnC,MAAO,gBACT,CAWA,cAAc,CAAQ,CAAE,CAAO,CAAE,CAC/B,OAAO,IAAI,CAAC,iBAAiB,CAAC,EAAU,IAAI,CAAC,YAAY,CAAC,GAC5D,CASA,kBAAkB,CAAQ,CAAE,CAAO,CAAE,CACnC,MAAO,gBACT,CACF,CAMA,SAAS,EAAQ,CAAM,QACrB,AAAI,AAAkB,UAAlB,OAAO,EACF,EAEF,EACT,CAEA,MAAe,ECnMf,IAAM,EAAsB,CAC1B,MAAS,SAAK,CACd,WAAc,SAAU,CACxB,QAAW,SAAO,CAClB,WAAc,SAAU,CACxB,gBAAmB,SAAe,CAClC,aAAgB,SAAY,AAC9B,EAmBMC,EAAQ,QAwBR,EAAY,CAChB,MAAO,EACP,KAAM,EACN,WAAY,EACZ,YAAa,EACb,OAAQ,EACR,MAAO,EACP,IAAK,CACP,EAKM,EAAgB,CACpB,MAAO,QACP,WAAY,aACZ,QAAS,UACT,WAAY,aACZ,gBAAiB,kBACjB,aAAc,eACd,mBAAoB,qBACpB,OAAQ,QACV,CAKA,OAAM,EAIJ,YAAY,CAAG,CAAE,CAIf,IAAI,CAAC,GAAG,CAAG,EAMX,IAAI,CAAC,MAAM,CAAG,EAChB,CAOA,SAAS,CAAC,CAAE,CACV,OAAO,AAAC,GAAK,KAAO,GAAK,KAAS,GAAK,KAAO,GAAK,GACrD,CASA,WAAW,CAAC,CAAE,CAAO,CAAE,CAErB,OADA,EAAU,AAAY,SAAZ,GAAwB,EAC3B,AAAC,GAAK,KAAO,GAAK,KAAS,AAAK,KAAL,GAAY,CAAC,CACjD,CAOA,cAAc,CAAC,CAAE,CACf,MAAO,AAAK,KAAL,GAAY,AAAK,KAAL,GAAa,AAAK,MAAL,GAAa,AAAK,MAAL,CAC/C,CAMA,WAAY,CACV,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,MAAM,CACtC,CAMA,WAAY,CACV,IAIID,EAJE,EAAI,IAAI,CAAC,SAAS,GAClB,EAAW,IAAI,CAAC,MAAM,CAExB,EAAQ,EAGZ,GAAI,AAAK,KAAL,EACFA,EAAO,EAAU,UAAU,MACtB,GAAI,AAAK,KAAL,EACTA,EAAO,EAAU,KAAK,MACjB,GAAI,AAAK,KAAL,EACTA,EAAO,EAAU,WAAW,MACvB,GAAI,IAAI,CAAC,UAAU,CAAC,IAAM,AAAK,KAAL,EAC/BA,EAAO,EAAU,MAAM,CACvB,EAAQ,IAAI,CAAC,WAAW,QACnB,GAAI,IAAI,CAAC,QAAQ,CAAC,GACvBA,EAAO,EAAU,IAAI,CACrB,EAAQ,IAAI,CAAC,SAAS,QACjB,GAAI,IAAI,CAAC,aAAa,CAAC,GAC5B,OAAO,IAAI,CAAC,SAAS,QAChB,GAAI,AAAM,KAAN,EACTA,EAAO,EAAU,GAAG,MAEpB,MAAM,AAAIE,MAAM,yBAA2B,GAG7C,MAAO,CAAC,SAAU,EAAU,MAAO,EAAO,KAAMF,CAAI,CACtD,CAMA,aAAc,CAEZ,IADI,EACE,EAAQ,IAAI,CAAC,MAAM,CACrB,EAAU,GACV,EAAqB,GACzB,EACM,AAAK,KAAL,EACF,EAAU,GACD,CAAK,KAAL,GAAY,AAAK,KAAL,CAAO,GAC5B,GAAqB,EAAG,EAE1B,EAAI,IAAI,CAAC,SAAS,SAElB,IAAI,CAAC,UAAU,CAAC,EAAG,IAGlB,CAAC,GAAuB,CAAK,KAAL,GAAY,AAAK,KAAL,CAAO,GAG3C,GAAuB,CAAK,KAAL,GAAY,AAAK,KAAL,CAAO,EAC3C,CACF,OAAOG,WAAW,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAO,IAAI,CAAC,MAAM,IACzD,CAMA,WAAY,CAEV,IADI,EACE,EAAQ,IAAI,CAAC,MAAM,CACzB,GACE,EAAI,IAAI,CAAC,SAAS,SACX,IAAI,CAAC,QAAQ,CAAC,GAAI,CAC3B,OAAO,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAO,IAAI,CAAC,MAAM,IAAI,WAAW,EAC7D,CACF,CAKA,MAAM,EAIJ,YAAY,CAAK,CAAE,CAKjB,IAAI,CAAC,MAAM,CAAG,EAMd,IAAI,CAAC,MAAM,CAAG,CACZ,SAAU,EACV,KAAM,EAAU,KAAK,AACvB,EAMA,IAAI,CAAC,OAAO,CAAG,IACjB,CAMA,UAAW,CACT,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EACrC,CAOA,YAAYH,CAAI,CAAE,CAChB,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,EAAIA,CAC7B,CAOA,MAAMA,CAAI,CAAE,CACV,IAAM,EAAU,IAAI,CAAC,WAAW,CAACA,GAIjC,OAHI,GACF,IAAI,CAAC,QAAQ,GAER,CACT,CAMA,OAAQ,CAEN,OADA,IAAI,CAAC,QAAQ,GACN,IAAI,CAAC,cAAc,EAC5B,CAOA,sBAAuB,CAErB,IAAI,EAAS,KACP,EAAW,IAAI,CAAC,MAAM,CAC5B,GAAI,IAAI,CAAC,WAAW,CAAC,EAAU,IAAI,EAAG,CACpC,IAAM,EAAU,EAAS,KAAK,AAC1B,AAhQA,OAgQA,EACF,EAAS,MACA,AA5PP,MA4PO,EACT,EAAS,MACA,AAxPN,OAwPM,GACT,GAAS,MAAK,EAEZ,AAAW,OAAX,GACF,IAAI,CAAC,QAAQ,EAEjB,CACA,OAAO,CACT,CAMA,8BAA+B,CAC7B,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,UAAU,EAAG,CACpC,IAAM,EAAa,EAAE,CACrB,GACE,EAAW,IAAI,CAAC,IAAI,CAAC,cAAc,UAC5B,IAAI,CAAC,KAAK,CAAC,EAAU,KAAK,EAAG,CACtC,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,WAAW,EAClC,OAAO,CAEX,CACA,MAAM,AAAIE,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAMA,iBAAkB,CAChB,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,UAAU,EAAG,CACpC,IAAM,EAAc,IAAI,CAAC,WAAW,GACpC,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,WAAW,EAClC,OAAO,CAEX,CACA,MAAM,AAAIA,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAMA,sBAAuB,CACrB,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,UAAU,EAAG,CACpC,IAAM,EAAc,IAAI,CAAC,eAAe,GACxC,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,WAAW,EAClC,OAAO,CAEX,CACA,MAAM,AAAIA,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAMA,mBAAoB,CAClB,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,UAAU,EAAG,CACpC,IAAM,EAAc,IAAI,CAAC,wBAAwB,GACjD,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,WAAW,EAClC,OAAO,CAEX,CACA,MAAM,AAAIA,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAMA,sBAAuB,CACrB,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,UAAU,EAAG,CACpC,IAAI,EAMJ,GAJE,EADE,IAAI,CAAC,MAAM,CAAC,IAAI,EAAI,EAAU,UAAU,CAC5B,IAAI,CAAC,mBAAmB,GAExB,IAAI,CAAC,eAAe,GAEhC,IAAI,CAAC,KAAK,CAAC,EAAU,WAAW,EAClC,OAAO,CAEX,CACA,MAAM,AAAIA,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAOA,2BAA4B,CAC1B,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,UAAU,EAAG,CACpC,IAAM,EAAc,IAAI,CAAC,wBAAwB,GACjD,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,WAAW,EAClC,OAAO,CAEX,CACA,MAAM,AAAIA,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAMA,wBAAyB,CACvB,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,UAAU,EAAG,CACpC,IAAM,EAAc,IAAI,CAAC,qBAAqB,GAC9C,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,WAAW,EAClC,OAAO,CAEX,CACA,MAAM,AAAIA,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAMA,aAAc,CACZ,IAAM,EAAc,EAAE,CAChB,EAAa,IAAI,CAAC,OAAO,CAAC,MAAM,CACtC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,EAAE,EAAG,CACnC,IAAM,EAAQ,IAAI,CAAC,MAAM,CACzB,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,MAAM,EAC7B,EAAY,IAAI,CAAwB,EAAM,KAAK,OAEnD,KAEJ,CACA,GAAI,EAAY,MAAM,EAAI,EACxB,OAAO,CAET,OAAM,AAAIA,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CAMA,iBAAkB,CAChB,IAAM,EAAc,CAAC,IAAI,CAAC,WAAW,GAAG,CACxC,KAAO,IAAI,CAAC,KAAK,CAAC,EAAU,KAAK,GAC/B,EAAY,IAAI,CAAC,IAAI,CAAC,WAAW,IAEnC,OAAO,CACT,CAMA,qBAAsB,CACpB,IAAM,EAAc,CAAC,IAAI,CAAC,eAAe,GAAG,CAC5C,KAAO,IAAI,CAAC,KAAK,CAAC,EAAU,KAAK,GAC/B,EAAY,IAAI,CAAC,IAAI,CAAC,eAAe,IAEvC,OAAO,CACT,CAMA,0BAA2B,CACzB,IAAM,EAAc,CAAC,IAAI,CAAC,oBAAoB,GAAG,CACjD,KAAO,IAAI,CAAC,KAAK,CAAC,EAAU,KAAK,GAC/B,EAAY,IAAI,CAAC,IAAI,CAAC,oBAAoB,IAE5C,OAAO,CACT,CAMA,uBAAwB,CACtB,IAAM,EAAc,CAAC,IAAI,CAAC,iBAAiB,GAAG,CAC9C,KAAO,IAAI,CAAC,KAAK,CAAC,EAAU,KAAK,GAC/B,EAAY,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAEzC,OAAO,CACT,CAMA,kBAAmB,CACjB,IAAM,EACJ,IAAI,CAAC,WAAW,CAAC,EAAU,IAAI,GAAK,IAAI,CAAC,MAAM,CAAC,KAAK,EAAID,EAI3D,OAHI,GACF,IAAI,CAAC,QAAQ,GAER,CACT,CAOA,qBAAsB,CACpB,MACE,eACA,IAAI,CAAC,MAAM,CAAC,KAAK,CACjB,iBACA,IAAI,CAAC,MAAM,CAAC,QAAQ,CACpB,QACA,IAAI,CAAC,MAAM,CAAC,GAAG,CACf,GAEJ,CAMA,gBAAiB,CACf,IAAMD,EAAQ,IAAI,CAAC,MAAM,CACzB,GAAI,IAAI,CAAC,KAAK,CAAC,EAAU,IAAI,EAAG,CAC9B,IAeI,EAfE,EAAkCA,EAAM,KAAK,AACnD,KAAI,CAAC,OAAO,CAAG,IAAI,CAAC,oBAAoB,GACxC,IAAMI,EAAU,IAAI,CAAC,gBAAgB,GACrC,GAAI,AAAY,sBAAZ,EAAkC,CACpC,GAAIA,EACF,OAAO,IAAI,SAAkB,CAAC,EAAE,EAElC,IAAM,EAAa,IAAI,CAAC,4BAA4B,GACpD,OAAO,IAAI,SAAkB,CAAC,EAChC,CACA,IAAM,EAAO,CAAmB,CAAC,EAAS,CAC1C,GAAI,CAAC,EACH,MAAM,AAAIF,MAAM,0BAA4B,GAK9C,GAAIE,EAEA,EADE,AAAY,SAAZ,EACY,CAACC,IAAKA,IAAI,CAEV,EAAE,MAGlB,OAAQ,GACN,IAAK,QACH,EAAc,IAAI,CAAC,eAAe,GAClC,KAEF,KAAK,aACH,EAAc,IAAI,CAAC,oBAAoB,GACvC,KAEF,KAAK,UACH,EAAc,IAAI,CAAC,iBAAiB,GACpC,KAEF,KAAK,aACH,EAAc,IAAI,CAAC,oBAAoB,GACvC,KAEF,KAAK,kBACH,EAAc,IAAI,CAAC,yBAAyB,GAC5C,KAEF,KAAK,eACH,EAAc,IAAI,CAAC,sBAAsB,EAK7C,CAGF,OAAO,IAAI,EAAK,EAAa,IAAI,CAAC,OAAO,CAC3C,CACA,MAAM,AAAIH,MAAM,IAAI,CAAC,mBAAmB,GAC1C,CACF,CA8IA,SAAS,EAAoB,CAAI,EAC/B,IAAM,EAAc,EAAK,cAAc,UACvC,AAAI,AAAuB,IAAvB,EAAY,MAAM,CACb,GAEF,EAAY,IAAI,CAAC,IAC1B,CAgCA,SAAS,EAAyB,CAAI,EACpC,IAAM,EAAc,EAAK,cAAc,GACjC,EAAQ,EAAE,CAChB,IAAK,IAAI,EAAI,EAAGE,EAAK,EAAY,MAAM,CAAE,EAAIA,EAAI,EAAE,EACjD,EAAM,IAAI,CAAC,CAAW,CAAC,EAAE,CAAC,IAAI,CAAC,MAEjC,OAAO,EAAM,IAAI,CAAC,IACpB,CAmBA,SAAS,EAAsB,CAAI,EACjC,IAAM,EAAQ,EAAE,CACVE,EAAQ,EAAK,cAAc,GACjC,IAAK,IAAI,EAAI,EAAGF,EAAKE,EAAM,MAAM,CAAE,EAAIF,EAAI,EAAE,EAC3C,EAAM,IAAI,CAAC,IAAM,EAAyBE,CAAK,CAAC,EAAE,EAAI,KAExD,OAAO,EAAM,IAAI,CAAC,IACpB,CAmCA,IAAM,EAAkB,CACtB,MAAS,EACT,WAAc,EACd,QAAW,EACX,WAlGF,SAAkC,CAAI,EACpC,IAAM,EAAQ,EAAE,CACV,EAAa,EAAK,SAAS,GACjC,IAAK,IAAI,EAAI,EAAGF,EAAK,EAAW,MAAM,CAAE,EAAIA,EAAI,EAAE,EAChD,EAAM,IAAI,CAAC,IAAM,EAAoB,CAAU,CAAC,EAAE,EAAI,KAExD,OAAO,EAAM,IAAI,CAAC,IACpB,EA4FE,gBA5DF,SAAuC,CAAI,EACzC,IAAM,EAAQ,EAAE,CACV,EAAa,EAAK,cAAc,GACtC,IAAK,IAAI,EAAI,EAAGA,EAAK,EAAW,MAAM,CAAE,EAAIA,EAAI,EAAE,EAChD,EAAM,IAAI,CAAC,IAAM,EAAyB,CAAU,CAAC,EAAE,EAAI,KAE7D,OAAO,EAAM,IAAI,CAAC,IACpB,EAsDE,aAnCF,SAAoC,CAAI,EACtC,IAAM,EAAQ,EAAE,CACV,EAAa,EAAK,WAAW,GACnC,IAAK,IAAI,EAAI,EAAGA,EAAK,EAAW,MAAM,CAAE,EAAIA,EAAI,EAAE,EAChD,EAAM,IAAI,CAAC,IAAM,EAAsB,CAAU,CAAC,EAAE,EAAI,KAE1D,OAAO,EAAM,IAAI,CAAC,IACpB,EA6BE,mBAxFF,SAA0C,CAAI,EAC5C,IAAM,EAAQ,EAAE,CACV,EAAQ,EAAK,aAAa,GAChC,IAAK,IAAI,EAAI,EAAGA,EAAK,EAAM,MAAM,CAAE,EAAIA,EAAI,EAAE,EAC3C,EAAM,IAAI,CAAC,EAAO,CAAK,CAAC,EAAE,GAE5B,OAAO,EAAM,IAAI,CAAC,IACpB,CAkFA,EAOA,SAAS,EAAO,CAAI,EAClB,IAAM,EAAO,EAAK,OAAO,GAEnB,EAAM,AADY,IAAe,CAAC,EAAK,AAAD,EAChB,GACxB,EAAU,CAAa,CAAC,EAAK,CACjC,GAAI,AAAwD,YAAxD,OAAyB,AAAC,EAAM,kBAAkB,CAAkB,CACtE,IAAM,EAAU,AArCpB,SAA8B,CAAI,EAChC,IAAM,EAAS,EAAK,SAAS,GACzB,EAAU,GAOd,MANI,CAAW,QAAX,GAAoB,AAAW,SAAX,CAAgB,GACtC,IAzwBM,GAywBK,EAET,CAAW,QAAX,GAAoB,AAAW,SAAX,CAAgB,GACtC,IAtwBM,GAswBK,EAEN,CACT,EA4BkE,EAE1D,GAAQ,MAAM,CAAG,GACnB,IAAW,IAAM,CAAM,CAE3B,QACA,AAAI,AAAe,IAAf,EAAI,MAAM,CACL,EAAU,IAAMH,EAElB,EAAU,IAAM,EAAM,GAC/B,CAEA,MAjRA,cAAkB,EAIhB,YAAY,CAAO,CAAE,CACnB,KAAK,GAEL,EAAU,GAAoB,CAAC,EAO/B,IAAI,CAAC,gBAAgB,CACnB,AAA4B,SAA5B,EAAQ,eAAe,EAAiB,EAAQ,eAAe,AACnE,CASA,OAAO,CAAG,CAAE,CAGV,OAAO,AADQ,IAAI,EADL,IAAI,EAAM,IAEV,KAAK,EACrB,CASA,oBAAoBD,CAAI,CAAE,CAAO,CAAE,CACjC,IAAM,EAAO,IAAI,CAAC,oBAAoB,CAACA,EAAM,GACvC,EAAU,IAAI,SAAO,CAE3B,OADA,EAAQ,WAAW,CAAC,GACb,CACT,CASA,qBAAqBA,CAAI,CAAE,CAAO,CAAE,CAClC,IAAI,EAAa,EAAE,CACb,EAAW,IAAI,CAAC,oBAAoB,CAACA,EAAM,GAE/C,EADE,IAAI,CAAC,gBAAgB,EAAI,AAAsB,sBAAtB,EAAS,OAAO,GACI,AAC7C,EACA,kBAAkB,GAEP,CAAC,EAAS,CAEzB,IAAM,EAAW,EAAE,CACnB,IAAK,IAAI,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CACnD,IAAM,EAAU,IAAI,SAAO,CAC3B,EAAQ,WAAW,CAAC,CAAU,CAAC,EAAE,EACjC,EAAS,IAAI,CAAC,EAChB,CACA,OAAO,CACT,CASA,qBAAqBA,CAAI,CAAE,CAAO,CAAE,CAClC,IAAM,EAAW,IAAI,CAAC,MAAM,CAACA,GAC7B,MAAO,SAA6B,EAAU,GAAO,EACvD,CASA,iBAAiB,CAAO,CAAE,CAAO,CAAE,CACjC,IAAM,EAAW,EAAQ,WAAW,UACpC,AAAI,EACK,IAAI,CAAC,iBAAiB,CAAC,EAAU,GAEnC,EACT,CASA,kBAAkB,CAAQ,CAAE,CAAO,CAAE,CACnC,GAAI,AAAmB,GAAnB,EAAS,MAAM,CACjB,OAAO,IAAI,CAAC,gBAAgB,CAAC,CAAQ,CAAC,EAAE,CAAE,GAE5C,IAAM,EAAa,EAAE,CACrB,IAAK,IAAI,EAAI,EAAGI,EAAK,EAAS,MAAM,CAAE,EAAIA,EAAI,EAAE,EAC9C,EAAW,IAAI,CAAC,CAAQ,CAAC,EAAE,CAAC,WAAW,IAEzC,IAAM,EAAa,IAAI,SAAkB,CAAC,GAC1C,OAAO,IAAI,CAAC,iBAAiB,CAAC,EAAY,EAC5C,CASA,kBAAkB,CAAQ,CAAE,CAAO,CAAE,CACnC,OAAO,EAAO,SAA6B,EAAU,GAAM,GAC7D,CACF,C"}