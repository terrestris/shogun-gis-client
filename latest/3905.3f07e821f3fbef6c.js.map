{"version":3,"file":"3905.3f07e821f3fbef6c.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/array.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/asserts.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/contains.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/segments.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/WMTS.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/common.js"],"sourcesContent":["/**\n * @module ol/array\n */\n\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function} [comparator] Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\nexport function binarySearch(haystack, needle, comparator) {\n  let mid, cmp;\n  comparator = comparator || ascending;\n  let low = 0;\n  let high = haystack.length;\n  let found = false;\n\n  while (low < high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + ((high - low) >> 1);\n    cmp = +comparator(haystack[mid], needle);\n\n    if (cmp < 0.0) {\n      /* Too low. */\n      low = mid + 1;\n    } else {\n      /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n\n  /* Key not found. */\n  return found ? low : ~low;\n}\n\n/**\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nexport function ascending(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n/**\n * Compare function sorting arrays in descending order.  Safe to use for numeric values.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is greater than, equal to, or less than the second.\n */\nexport function descending(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\n/**\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\n * of this type to determine which nearest resolution to use.\n *\n * This function takes a `{number}` representing a value between two array entries,\n * a `{number}` representing the value of the nearest higher entry and\n * a `{number}` representing the value of the nearest lower entry\n * as arguments and returns a `{number}`. If a negative number or zero is returned\n * the lower value will be used, if a positive number is returned the higher value\n * will be used.\n * @typedef {function(number, number, number): number} NearestDirectionFunction\n * @api\n */\n\n/**\n * @param {Array<number>} arr Array in descending order.\n * @param {number} target Target.\n * @param {number|NearestDirectionFunction} direction\n *    0 means return the nearest,\n *    > 0 means return the largest nearest,\n *    < 0 means return the smallest nearest.\n * @return {number} Index.\n */\nexport function linearFindNearest(arr, target, direction) {\n  if (arr[0] <= target) {\n    return 0;\n  }\n\n  const n = arr.length;\n  if (target <= arr[n - 1]) {\n    return n - 1;\n  }\n\n  if (typeof direction === 'function') {\n    for (let i = 1; i < n; ++i) {\n      const candidate = arr[i];\n      if (candidate === target) {\n        return i;\n      }\n      if (candidate < target) {\n        if (direction(target, arr[i - 1], candidate) > 0) {\n          return i - 1;\n        }\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  if (direction > 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] < target) {\n        return i - 1;\n      }\n    }\n    return n - 1;\n  }\n\n  if (direction < 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] <= target) {\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  for (let i = 1; i < n; ++i) {\n    if (arr[i] == target) {\n      return i;\n    }\n    if (arr[i] < target) {\n      if (arr[i - 1] - target < target - arr[i]) {\n        return i - 1;\n      }\n      return i;\n    }\n  }\n  return n - 1;\n}\n\n/**\n * @param {Array<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\nexport function reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    const tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n * @template VALUE\n */\nexport function extend(arr, data) {\n  const extension = Array.isArray(data) ? data : [data];\n  const length = extension.length;\n  for (let i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\nexport function remove(arr, obj) {\n  const i = arr.indexOf(obj);\n  const found = i > -1;\n  if (found) {\n    arr.splice(i, 1);\n  }\n  return found;\n}\n\n/**\n * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\nexport function equals(arr1, arr2) {\n  const len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort the passed array such that the relative order of equal elements is preserved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n * @api\n */\nexport function stableSort(arr, compareFnc) {\n  const length = arr.length;\n  const tmp = Array(arr.length);\n  let i;\n  for (i = 0; i < length; i++) {\n    tmp[i] = {index: i, value: arr[i]};\n  }\n  tmp.sort(function (a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n}\n\n/**\n * @param {Array<*>} arr The array to test.\n * @param {Function} [func] Comparison function.\n * @param {boolean} [strict] Strictly sorted (default false).\n * @return {boolean} Return index.\n */\nexport function isSorted(arr, func, strict) {\n  const compare = func || ascending;\n  return arr.every(function (currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n    const res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || (strict && res === 0));\n  });\n}\n","/**\n * @module ol/asserts\n */\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {string} errorMessage Error message.\n */\nexport function assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {import('../../extent.js').Extent} [coordinatesExtent] Coordinates extent\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n  coordinatesExtent,\n) {\n  coordinatesExtent =\n    coordinatesExtent ??\n    extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (\n    (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) ||\n    (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3])\n  ) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/tilegrid/WMTS\n */\n\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from './TileGrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes,\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(\n  matrixSet,\n  extent,\n  matrixLimits,\n) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().startsWith('ne');\n\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (!elt[identifierPropName].includes(':')) {\n          return (\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n            elt_ml[matrixIdsPropName]\n          );\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution =\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([\n          elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0],\n        ]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight],\n      );\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes,\n  });\n}\n","/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport const DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport const DEFAULT_TILE_SIZE = 256;\n"],"names":["binarySearch","haystack","needle","comparator","mid","cmp","ascending","low","high","found","a","b","descending","linearFindNearest","arr","target","direction","n","i","candidate","reverseSubArray","begin","end","tmp","extend","data","extension","Array","length","equals","arr1","arr2","len1","isSorted","func","strict","compare","currentVal","index","res","assert","assertion","errorMessage","Error","linearRingContainsExtent","flatCoordinates","offset","stride","extent","coordinate","linearRingContainsXY","x","y","wn","x1","y1","x2","y2","linearRingsContainsXY","ends","ii","linearRingssContainsXY","endss","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","forEach","callback","ret","WMTSTileGrid","options","z","createFromCapabilitiesMatrixSet","matrixSet","matrixLimits","resolutions","matrixIds","origins","tileSizes","sizes","undefined","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","code","projection","metersPerUnit","switchOriginXY","elt","matrixAvailable","elt_ml","resolution","tileWidth","tileHeight","DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE"],"mappings":"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"}