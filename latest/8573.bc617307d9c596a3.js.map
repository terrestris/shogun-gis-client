{"version":3,"file":"8573.bc617307d9c596a3.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/TextFeature.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/WKT.js"],"sourcesContent":["/**\n * @module ol/format/TextFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for text feature formats.\n *\n * @abstract\n */\nclass TextFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'text';\n  }\n\n  /**\n   * Read the feature from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromText(\n      getText(source),\n      this.adaptOptions(options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the features from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromText(\n      getText(source),\n      this.adaptOptions(options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the geometry from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   * @override\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromText(\n      getText(source),\n      this.adaptOptions(options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    return this.readProjectionFromText(getText(source));\n  }\n\n  /**\n   * @param {string} text Text.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjectionFromText(text) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as a string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   * @override\n   */\n  writeFeature(feature, options) {\n    return this.writeFeatureText(feature, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    return this.writeFeaturesText(features, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Geometry.\n   * @api\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    return this.writeGeometryText(geometry, this.adaptOptions(options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {string} Text.\n */\nfunction getText(source) {\n  if (typeof source === 'string') {\n    return source;\n  }\n  return '';\n}\n\nexport default TextFeature;\n","/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {transformGeometryWithOptions} from './Feature.js';\nimport TextFeature from './TextFeature.js';\n\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\n */\nconst GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon,\n};\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY';\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z';\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M';\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM';\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6,\n};\n\n/**\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\n */\nconst wktTypeLookup = {\n  Point: 'POINT',\n  LineString: 'LINESTRING',\n  Polygon: 'POLYGON',\n  MultiPoint: 'MULTIPOINT',\n  MultiLineString: 'MULTILINESTRING',\n  MultiPolygon: 'MULTIPOLYGON',\n  GeometryCollection: 'GEOMETRYCOLLECTION',\n  Circle: 'CIRCLE',\n};\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean} [decimal] Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, decimal) {\n    decimal = decimal !== undefined ? decimal : false;\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal);\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_);\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_();\n    const position = this.index_;\n    /** @type {number|string} */\n    let value = c;\n    let type;\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n\n    return {position: position, value: value, type: type};\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c;\n    const index = this.index_;\n    let decimal = false;\n    let scientificNotation = false;\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n      c = this.nextChar_();\n    } while (\n      this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      (scientificNotation && (c == '-' || c == '+'))\n    );\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c;\n    const index = this.index_;\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_ = {\n      position: 0,\n      type: TokenType.START,\n    };\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken();\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    return this.token_.type == type;\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_();\n    return this.parseGeometry_();\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n    let layout = 'XY';\n    const dimToken = this.token_;\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value;\n      if (dimInfo === Z) {\n        layout = 'XYZ';\n      } else if (dimInfo === M) {\n        layout = 'XYM';\n      } else if (dimInfo === ZM) {\n        layout = 'XYZM';\n      }\n      if (layout !== 'XY') {\n        this.consume_();\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates;\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = [];\n    const dimensions = this.layout_.length;\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_;\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push(/** @type {number} */ (token.value));\n      } else {\n        break;\n      }\n    }\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty =\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n    if (isEmpty) {\n      this.consume_();\n    }\n    return isEmpty;\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return (\n      'Unexpected `' +\n      this.token_.value +\n      '` at position ' +\n      this.token_.position +\n      ' in `' +\n      this.lexer_.wkt +\n      '`'\n    );\n  }\n\n  /**\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const token = this.token_;\n    if (this.match(TokenType.TEXT)) {\n      const geomType = /** @type {string} */ (token.value);\n      this.layout_ = this.parseGeometryLayout_();\n      const isEmpty = this.isEmptyGeometry_();\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        if (isEmpty) {\n          return new GeometryCollection([]);\n        }\n        const geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      }\n      const ctor = GeometryConstructor[geomType];\n      if (!ctor) {\n        throw new Error('Invalid geometry type: ' + geomType);\n      }\n\n      let coordinates;\n\n      if (isEmpty) {\n        if (geomType == 'POINT') {\n          coordinates = [NaN, NaN];\n        } else {\n          coordinates = [];\n        }\n      } else {\n        switch (geomType) {\n          case 'POINT': {\n            coordinates = this.parsePointText_();\n            break;\n          }\n          case 'LINESTRING': {\n            coordinates = this.parseLineStringText_();\n            break;\n          }\n          case 'POLYGON': {\n            coordinates = this.parsePolygonText_();\n            break;\n          }\n          case 'MULTIPOINT': {\n            coordinates = this.parseMultiPointText_();\n            break;\n          }\n          case 'MULTILINESTRING': {\n            coordinates = this.parseMultiLineStringText_();\n            break;\n          }\n          case 'MULTIPOLYGON': {\n            coordinates = this.parseMultiPolygonText_();\n            break;\n          }\n          default:\n            break;\n        }\n      }\n\n      return new ctor(coordinates, this.layout_);\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n}\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nclass WKT extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    this.splitCollection_ =\n      options.splitCollection !== undefined ? options.splitCollection : false;\n  }\n\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n  parse_(wkt) {\n    const lexer = new Lexer(wkt);\n    const parser = new Parser(lexer);\n    return parser.parse();\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @override\n   */\n  readFeatureFromText(text, options) {\n    const geom = this.readGeometryFromText(text, options);\n    const feature = new Feature();\n    feature.setGeometry(geom);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   * @override\n   */\n  readFeaturesFromText(text, options) {\n    let geometries = [];\n    const geometry = this.readGeometryFromText(text, options);\n    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\n      geometries = /** @type {GeometryCollection} */ (\n        geometry\n      ).getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    const features = [];\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n    return features;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromText(text, options) {\n    const geometry = this.parse_(text);\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   * @override\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    }\n    return '';\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   * @override\n   */\n  writeFeaturesText(features, options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], options);\n    }\n    const geometries = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n    const collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, options);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   * @override\n   */\n  writeGeometryText(geometry, options) {\n    return encode(transformGeometryWithOptions(geometry, true, options));\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  if (coordinates.length === 0) {\n    return '';\n  }\n  return coordinates.join(' ');\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = [];\n  const components = geom.getPoints();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = [];\n  const geoms = geom.getGeometries();\n  for (let i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  const array = [];\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = [];\n  const components = geom.getLineStrings();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = [];\n  const rings = geom.getLinearRings();\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = [];\n  const components = geom.getPolygons();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  const layout = geom.getLayout();\n  let dimInfo = '';\n  if (layout === 'XYZ' || layout === 'XYZM') {\n    dimInfo += Z;\n  }\n  if (layout === 'XYM' || layout === 'XYZM') {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry,\n};\n\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  const type = geom.getType();\n  const geometryEncoder = GeometryEncoder[type];\n  const enc = geometryEncoder(geom);\n  let wktType = wktTypeLookup[type];\n  if (typeof (/** @type {?} */ (geom).getFlatCoordinates) === 'function') {\n    const dimInfo = encodeGeometryLayout(\n      /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom),\n    );\n    if (dimInfo.length > 0) {\n      wktType += ' ' + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return wktType + ' ' + EMPTY;\n  }\n  return wktType + '(' + enc + ')';\n}\n\nexport default WKT;\n"],"names":["TextFeature","source","options","getText","text","feature","features","geometry","GeometryConstructor","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","EMPTY","TokenType","wktTypeLookup","Lexer","wkt","c","decimal","undefined","type","position","value","Error","index","scientificNotation","parseFloat","Parser","lexer","isMatch","layout","dimToken","dimInfo","geometries","coordinates","dimensions","i","token","isEmpty","geomType","GeometryCollection","ctor","NaN","encodePointGeometry","geom","encodeLineStringGeometry","array","ii","encodePolygonGeometry","rings","GeometryEncoder","components","geoms","encode","enc","geometryEncoder","wktType","encodeGeometryLayout","Z","M","WKT","parser","Feature","collection"],"mappings":"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"}