{"version":3,"file":"4104.966b27ba342cbeed.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/Feature.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/GeometryCollection.js"],"sourcesContent":["/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  linearRingsAreOriented,\n  linearRingssAreOriented,\n  orientLinearRings,\n  orientLinearRingsArray,\n} from '../geom/flat/orient.js';\nimport {\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n  transformExtent,\n} from '../proj.js';\nimport RenderFeature from '../render/Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/***\n * @template {import('../Feature.js').FeatureLike} T\n * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass\n */\n\n/***\n * @template {import(\"../Feature.js\").FeatureClass} T\n * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {FeatureToFeatureClass<FeatureType>}\n     */\n    this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */ (\n      Feature\n    );\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection\n        ? getProjection(options.dataProjection)\n        : this.readProjection(source);\n      if (\n        options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === 'tile-pixels'\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n        featureClass: this.featureClass,\n      },\n      options,\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {Feature} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<Feature>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  let transformed = geometry;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    if (write) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    const fromProjection = write ? featureProjection : dataProjection;\n    const toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (\n    write &&\n    options &&\n    /** @type {WriteOptions} */ (options).decimals !== undefined\n  ) {\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\n\nconst GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon,\n};\n\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  const geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry\n      .map((geometry) => createRenderFeature({...object, geometry}))\n      .flat();\n  }\n\n  const geometryType =\n    geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n\n  const stride = geometry.layout.length;\n  return transformGeometryWithOptions(\n    new RenderFeature(\n      geometryType,\n      geometryType === 'Polygon'\n        ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride)\n        : geometry.flatCoordinates,\n      geometry.ends?.flat(),\n      stride,\n      object.properties || {},\n      object.id,\n    ).enableSimplifyTransformed(),\n    false,\n    options,\n  );\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    const geometries = object.map((geometry) =>\n      createGeometry(geometry, options),\n    );\n    return new GeometryCollection(geometries);\n  }\n  const Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(\n    new Geometry(object.flatCoordinates, object.layout || 'XY', object.ends),\n    false,\n    options,\n  );\n}\n","/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {\n  closestSquaredDistanceXY,\n  createOrUpdateEmpty,\n  extend,\n  getCenter,\n} from '../extent.js';\nimport Geometry from './Geometry.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\n *\n * @api\n */\nclass GeometryCollection extends Geometry {\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  constructor(geometries) {\n    super();\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = geometries;\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.changeEventsKeys_ = [];\n\n    this.listenGeometriesChange_();\n  }\n\n  /**\n   * @private\n   */\n  unlistenGeometriesChange_() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  listenGeometriesChange_() {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      this.changeEventsKeys_.push(\n        listen(geometries[i], EventType.CHANGE, this.changed, this),\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const geometryCollection = new GeometryCollection(\n      cloneGeometries(this.geometries_),\n    );\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n        x,\n        y,\n        closestPoint,\n        minSquaredDistance,\n      );\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    createOrUpdateEmpty(extent);\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  }\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  getGeometries() {\n    return cloneGeometries(this.geometries_);\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArray() {\n    return this.geometries_;\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArrayRecursive() {\n    /** @type {Array<Geometry>} */\n    let geometriesArray = [];\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(\n          /** @type {GeometryCollection} */ (\n            geometries[i]\n          ).getGeometriesArrayRecursive(),\n        );\n      } else {\n        geometriesArray.push(geometries[i]);\n      }\n    }\n    return geometriesArray;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {GeometryCollection} Simplified GeometryCollection.\n   * @override\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry =\n        geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(\n        simplifiedGeometries,\n      );\n      return simplifiedGeometryCollection;\n    }\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'GeometryCollection';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.geometries_.length === 0;\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   * @override\n   */\n  scale(sx, sy, anchor) {\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, sy, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  }\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   * @override\n   */\n  applyTransform(transformFn) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   * @override\n   */\n  translate(deltaX, deltaY) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenGeometriesChange_();\n    super.disposeInternal();\n  }\n}\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  return geometries.map((geometry) => geometry.clone());\n}\n\nexport default GeometryCollection;\n"],"names":["createGeometry","object","options","Array","geometries","geometry","transformGeometryWithOptions","GeometryConstructor","createRenderFeature","flatCoordinates","ends","stride","geometryType","Error","write","featureProjection","dataProjection","transformed","fromProjection","toProjection","undefined","power","Math","coordinates","i","ii","transformExtentWithOptions","extent","FeatureFormat","source","Object","feature","features","GeometryCollection","geometryCollection","cloneGeometries","x","y","closestPoint","minSquaredDistance","geometriesArray","squaredTolerance","simplifiedGeometries","simplified","simplifiedGeometry","angle","anchor","sx","sy","transformFn","deltaX","deltaY"],"mappings":"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"}