{"version":3,"file":"4474.0ba1a69d0a07e51a.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/@terrestris/react-util/dist/Hooks/useCoordinateInfo/useCoordinateInfo.js","webpack://@terrestris/shogun-gis-client/./node_modules/@terrestris/react-geo/dist/CoordinateInfo/CoordinateInfo.js"],"sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport { cloneDeep, isString, uniqueId } from 'lodash';\nimport _isNil from 'lodash/isNil';\nimport OlFormatGeoJSON from 'ol/format/GeoJSON';\nimport OlFormatGML2 from 'ol/format/GML2';\nimport OlFormatGml3 from 'ol/format/GML3';\nimport OlFormatGml32 from 'ol/format/GML32';\nimport OlFormatWMSGetFeatureInfo from 'ol/format/WMSGetFeatureInfo';\nimport { getUid } from 'ol/util';\nimport Logger from '@terrestris/base-util/dist/Logger';\nimport { isWfsLayer, isWmsLayer } from '@terrestris/ol-util';\nimport useMap from '../useMap/useMap';\nconst getFeatureType = (feature) => {\n    const id = feature.getId() ?? feature.get('id');\n    return isString(id) ? id.split('.')[0] : id?.toString() ?? uniqueId('UNKNOWN');\n};\nexport const useCoordinateInfo = ({ active, clickEvent = 'click', drillDown = false, featureCount = 1, fetchOpts = {}, getInfoFormat = () => 'application/json', layerFilter = () => true, onError = () => undefined, onSuccess = () => undefined, registerOnClick = true, registerOnPointerMove = false, registerOnPointerRest = false }) => {\n    const map = useMap();\n    const [clickCoordinate, setClickCoordinate] = useState(null);\n    const [pixelCoordinate, setPixelCoordinate] = useState(null);\n    const [featureResults, setFeatureResults] = useState([]);\n    const [loading, setLoading] = useState(false);\n    useEffect(() => {\n        if (map && loading) {\n            map.getTargetElement().style.cursor = 'wait';\n            return () => {\n                map.getTargetElement().style.cursor = 'auto';\n            };\n        }\n        return undefined;\n    }, [loading, map]);\n    const onPointerMove = useCallback((olEvt) => {\n        if (olEvt.dragging || _isNil(map)) {\n            return;\n        }\n        const pixel = map.getEventPixel(olEvt.originalEvent);\n        const hits = map.getAllLayers()\n            .filter(l => layerFilter(l))\n            .filter(l => {\n            const pixelData = l.getData(pixel);\n            return pixelData && pixelData[3] > 0;\n        });\n        map.getTargetElement().style.cursor = hits?.length > 0 ? 'pointer' : '';\n    }, [layerFilter, map]);\n    const handleMapEvent = useCallback(async (olEvt) => {\n        if (_isNil(map)) {\n            return;\n        }\n        if (clickEvent === 'dblclick') {\n            // prevent map zoom on double click\n            olEvt.stopPropagation();\n        }\n        const mapView = map.getView();\n        const viewResolution = mapView.getResolution();\n        const viewProjection = mapView.getProjection();\n        const pixel = map.getEventPixel(olEvt.originalEvent);\n        const coordinate = olEvt.coordinate;\n        let evtPixelCoordinate = [0, 0];\n        if (olEvt.originalEvent instanceof PointerEvent) {\n            evtPixelCoordinate = [olEvt.originalEvent.x, olEvt.originalEvent.y];\n        }\n        const wmsMapLayers = map.getAllLayers()\n            .reverse()\n            .filter(layerFilter)\n            .filter(l => l.getData && l.getData(pixel) && isWmsLayer(l));\n        const wfsMapLayers = map.getAllLayers()\n            .reverse()\n            .filter(layerFilter)\n            .filter(l => isWfsLayer(l));\n        setLoading(true);\n        try {\n            const results = [];\n            for (const layer of wmsMapLayers) {\n                try {\n                    if (!drillDown && results.length > 0) {\n                        break;\n                    }\n                    const wmsLayerSource = layer.getSource();\n                    if (!wmsLayerSource) {\n                        continue;\n                    }\n                    const infoFormat = await getInfoFormat(layer);\n                    const featureInfoUrl = wmsLayerSource.getFeatureInfoUrl(coordinate, viewResolution, viewProjection, {\n                        INFO_FORMAT: infoFormat,\n                        FEATURE_COUNT: featureCount\n                    });\n                    if (featureInfoUrl) {\n                        let opts;\n                        if (fetchOpts instanceof Function) {\n                            opts = fetchOpts(layer);\n                        }\n                        else {\n                            opts = fetchOpts[getUid(layer)];\n                        }\n                        const response = await fetch(featureInfoUrl, opts);\n                        let format = null;\n                        let isJson = false;\n                        if (infoFormat === 'application/vnd.ogc.gml') {\n                            format = new OlFormatWMSGetFeatureInfo();\n                        }\n                        else if (infoFormat.indexOf('gml/2') > -1) {\n                            format = new OlFormatGML2();\n                        }\n                        else if (infoFormat === 'application/vnd.ogc.gml/3.1.1' || infoFormat === 'text/xml; subtype=gml/3.1.1') {\n                            format = new OlFormatGml3();\n                        }\n                        else if (infoFormat === 'application/vnd.ogc.gml/3.2' || infoFormat === 'text/xml; subtype=gml/3.2') {\n                            format = new OlFormatGml32();\n                        }\n                        else if (infoFormat === 'application/json' || infoFormat.indexOf('json') > -1) {\n                            format = new OlFormatGeoJSON();\n                            isJson = true;\n                        }\n                        else {\n                            continue;\n                        }\n                        const text = isJson ? await response.json() : await response.text();\n                        results.push(...format.readFeatures(text).map(f => ({\n                            feature: f,\n                            layer,\n                            featureType: getFeatureType(f)\n                        })));\n                    }\n                }\n                catch (error) {\n                    Logger.error(error);\n                }\n            }\n            for (const layer of wfsMapLayers) {\n                if (!drillDown && results.length > 0) {\n                    break;\n                }\n                const wfsLayerSource = layer.getSource();\n                if (!wfsLayerSource) {\n                    continue;\n                }\n                results.push(...wfsLayerSource.getFeaturesAtCoordinate(coordinate).map(f => ({\n                    feature: f,\n                    layer,\n                    featureType: getFeatureType(f)\n                })));\n            }\n            // We're cloning the click coordinate and features to be able\n            // to alter the features without affecting the original ones\n            // Also note that we explicitly don't use feature.clone() to\n            // keep all feature properties (in particular the id) intact.\n            const clonedResults = cloneDeep(results);\n            const clonedCoordinate = cloneDeep(coordinate);\n            const clonedPixelCoordinate = cloneDeep(evtPixelCoordinate);\n            setFeatureResults(clonedResults);\n            setClickCoordinate(clonedCoordinate);\n            setPixelCoordinate(clonedPixelCoordinate);\n            onSuccess?.({\n                clickCoordinate: clonedCoordinate,\n                pixelCoordinate: clonedPixelCoordinate,\n                loading: false,\n                features: clonedResults\n            });\n        }\n        catch (error) {\n            Logger.error(error);\n            onError?.(error);\n        }\n        setLoading(false);\n    }, [clickEvent, drillDown, featureCount, fetchOpts, getInfoFormat, layerFilter, map, onError, onSuccess]);\n    useEffect(() => {\n        let keyMove;\n        let keyRest;\n        let keyClick;\n        if (active) {\n            if (registerOnClick && clickEvent) {\n                keyClick = map?.on(clickEvent, handleMapEvent);\n            }\n            if (registerOnPointerMove) {\n                keyMove = map?.on('pointermove', onPointerMove);\n            }\n            if (registerOnPointerRest) {\n                // @ts-expect-error pointerrest is no default event\n                keyRest = map?.on('pointerrest', handleMapEvent);\n            }\n        }\n        return () => {\n            if (keyClick && clickEvent) {\n                map?.un(clickEvent, keyClick.listener);\n            }\n            if (keyMove) {\n                map?.un('pointermove', keyMove.listener);\n            }\n            if (keyRest) {\n                // @ts-expect-error pointerrest is no default event\n                map?.un('pointerrest', keyRest.listener);\n            }\n        };\n    }, [\n        active, map, onPointerMove, handleMapEvent, registerOnClick,\n        registerOnPointerMove, registerOnPointerRest, clickEvent\n    ]);\n    // We want to propagate the state here so the variables do\n    // not change on every render cycle.\n    return {\n        clickCoordinate,\n        features: featureResults,\n        loading,\n        pixelCoordinate\n    };\n};\nexport default useCoordinateInfo;\n//# sourceMappingURL=useCoordinateInfo.js.map","import React from 'react';\nimport _isNil from 'lodash/isNil';\nimport useCoordinateInfo from '@terrestris/react-util/dist/Hooks/useCoordinateInfo/useCoordinateInfo';\n/**\n * Constructs a wrapper component for querying features from the clicked\n * coordinate. The returned features can be passed to a child component\n * to be visualized.\n *\n */\nexport const CoordinateInfo = ({ resultRenderer = () => React.createElement(React.Fragment, null), ...passThroughProps }) => {\n    const result = useCoordinateInfo(passThroughProps);\n    if (_isNil(result)) {\n        return null;\n    }\n    return (React.createElement(React.Fragment, null, resultRenderer(result)));\n};\nexport default CoordinateInfo;\n//# sourceMappingURL=CoordinateInfo.js.map"],"names":["v","PointerEvent","Function","r","fetch","e"],"mappings":"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"}