{"version":3,"file":"768.5d02d5e1eebc8f44.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/Feature.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/MultiPoint.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/MultiPolygon.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/center.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/render/Feature.js"],"sourcesContent":["/**\n * @module ol/Feature\n */\nimport BaseObject from './Object.js';\nimport {assert} from './asserts.js';\nimport EventType from './events/EventType.js';\nimport {listen, unlistenByKey} from './events.js';\n\n/**\n * @typedef {typeof Feature|typeof import(\"./render/Feature.js\").default} FeatureClass\n */\n\n/**\n * @typedef {Feature|import(\"./render/Feature.js\").default} FeatureLike\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types|'change:geometry', import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types\n *     |'change:geometry', Return>} FeatureOnSignature\n */\n\n/***\n * @template {import(\"./geom/Geometry.js\").default} [Geometry=import(\"./geom/Geometry.js\").default]\n * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry\n */\n\n/**\n * @classdesc\n * A vector object for geographic features with a geometry and other\n * attribute properties, similar to the features in vector file formats like\n * GeoJSON.\n *\n * Features can be styled individually with `setStyle`; otherwise they use the\n * style of their vector layer.\n *\n * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on\n * the feature object, so they are observable, and have get/set accessors.\n *\n * Typically, a feature has a single geometry property. You can set the\n * geometry using the `setGeometry` method and get it with `getGeometry`.\n * It is possible to store more than one geometry on a feature using attribute\n * properties. By default, the geometry used for rendering is identified by\n * the property name `geometry`. If you want to use another geometry property\n * for rendering, use the `setGeometryName` method to change the attribute\n * property associated with the geometry for the feature.  For example:\n *\n * ```js\n *\n * import Feature from 'ol/Feature.js';\n * import Polygon from 'ol/geom/Polygon.js';\n * import Point from 'ol/geom/Point.js';\n *\n * const feature = new Feature({\n *   geometry: new Polygon(polyCoords),\n *   labelPoint: new Point(labelCoords),\n *   name: 'My Polygon',\n * });\n *\n * // get the polygon geometry\n * const poly = feature.getGeometry();\n *\n * // Render the feature as a point using the coordinates from labelPoint\n * feature.setGeometryName('labelPoint');\n *\n * // get the point geometry\n * const point = feature.getGeometry();\n * ```\n *\n * @api\n * @template {import(\"./geom/Geometry.js\").default} [Geometry=import(\"./geom/Geometry.js\").default]\n */\nclass Feature extends BaseObject {\n  /**\n   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]\n   *     You may pass a Geometry object directly, or an object literal containing\n   *     properties. If you pass an object literal, you may include a Geometry\n   *     associated with a `geometry` key.\n   */\n  constructor(geometryOrProperties) {\n    super();\n\n    /***\n     * @type {FeatureOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {FeatureOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {FeatureOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = undefined;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.geometryName_ = 'geometry';\n\n    /**\n     * User provided style.\n     * @private\n     * @type {import(\"./style/Style.js\").StyleLike}\n     */\n    this.style_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction_ = undefined;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.geometryChangeKey_ = null;\n\n    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);\n\n    if (geometryOrProperties) {\n      if (\n        typeof (\n          /** @type {?} */ (geometryOrProperties).getSimplifiedGeometry\n        ) === 'function'\n      ) {\n        const geometry = /** @type {Geometry} */ (geometryOrProperties);\n        this.setGeometry(geometry);\n      } else {\n        /** @type {Object<string, *>} */\n        const properties = geometryOrProperties;\n        this.setProperties(properties);\n      }\n    }\n  }\n\n  /**\n   * Clone this feature. If the original feature has a geometry it\n   * is also cloned. The feature id is not set in the clone.\n   * @return {Feature<Geometry>} The clone.\n   * @api\n   */\n  clone() {\n    const clone = /** @type {Feature<Geometry>} */ (\n      new Feature(this.hasProperties() ? this.getProperties() : null)\n    );\n    clone.setGeometryName(this.getGeometryName());\n    const geometry = this.getGeometry();\n    if (geometry) {\n      clone.setGeometry(/** @type {Geometry} */ (geometry.clone()));\n    }\n    const style = this.getStyle();\n    if (style) {\n      clone.setStyle(style);\n    }\n    return clone;\n  }\n\n  /**\n   * Get the feature's default geometry.  A feature may have any number of named\n   * geometries.  The \"default\" geometry (the one that is rendered by default) is\n   * set when calling {@link module:ol/Feature~Feature#setGeometry}.\n   * @return {Geometry|undefined} The default geometry for the feature.\n   * @api\n   * @observable\n   */\n  getGeometry() {\n    return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is either set when reading data from a remote source or set explicitly by\n   * calling {@link module:ol/Feature~Feature#setId}.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * Get the name of the feature's default geometry.  By default, the default\n   * geometry is named `geometry`.\n   * @return {string} Get the property name associated with the default geometry\n   *     for this feature.\n   * @api\n   */\n  getGeometryName() {\n    return this.geometryName_;\n  }\n\n  /**\n   * Get the feature's style. Will return what was provided to the\n   * {@link module:ol/Feature~Feature#setStyle} method.\n   * @return {import(\"./style/Style.js\").StyleLike|undefined} The feature style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Get the feature's style function.\n   * @return {import(\"./style/Style.js\").StyleFunction|undefined} Return a function\n   * representing the current style of this feature.\n   * @api\n   */\n  getStyleFunction() {\n    return this.styleFunction_;\n  }\n\n  /**\n   * @private\n   */\n  handleGeometryChange_() {\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  handleGeometryChanged_() {\n    if (this.geometryChangeKey_) {\n      unlistenByKey(this.geometryChangeKey_);\n      this.geometryChangeKey_ = null;\n    }\n    const geometry = this.getGeometry();\n    if (geometry) {\n      this.geometryChangeKey_ = listen(\n        geometry,\n        EventType.CHANGE,\n        this.handleGeometryChange_,\n        this,\n      );\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the default geometry for the feature.  This will update the property\n   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.\n   * @param {Geometry|undefined} geometry The new geometry.\n   * @api\n   * @observable\n   */\n  setGeometry(geometry) {\n    this.set(this.geometryName_, geometry);\n  }\n\n  /**\n   * Set the style for the feature to override the layer style.  This can be a\n   * single style object, an array of styles, or a function that takes a\n   * resolution and returns an array of styles. To unset the feature style, call\n   * `setStyle()` without arguments or a falsey value.\n   * @param {import(\"./style/Style.js\").StyleLike} [style] Style for this feature.\n   * @api\n   * @fires module:ol/events/Event~BaseEvent#event:change\n   */\n  setStyle(style) {\n    this.style_ = style;\n    this.styleFunction_ = !style ? undefined : createStyleFunction(style);\n    this.changed();\n  }\n\n  /**\n   * Set the feature id.  The feature id is considered stable and may be used when\n   * requesting features or comparing identifiers returned from a remote source.\n   * The feature id can be used with the\n   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.\n   * @param {number|string|undefined} id The feature id.\n   * @api\n   * @fires module:ol/events/Event~BaseEvent#event:change\n   */\n  setId(id) {\n    this.id_ = id;\n    this.changed();\n  }\n\n  /**\n   * Set the property name to be used when getting the feature's default geometry.\n   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with\n   * this name will be returned.\n   * @param {string} name The property name of the default geometry.\n   * @api\n   */\n  setGeometryName(name) {\n    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);\n    this.geometryName_ = name;\n    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);\n    this.handleGeometryChanged_();\n  }\n}\n\n/**\n * Convert the provided object into a feature style function.  Functions passed\n * through unchanged.  Arrays of Style or single style objects wrapped\n * in a new feature style function.\n * @param {!import(\"./style/Style.js\").StyleFunction|!Array<import(\"./style/Style.js\").default>|!import(\"./style/Style.js\").default} obj\n *     A feature style function, a single style, or an array of styles.\n * @return {import(\"./style/Style.js\").StyleFunction} A style function.\n */\nexport function createStyleFunction(obj) {\n  if (typeof obj === 'function') {\n    return obj;\n  }\n  /**\n   * @type {Array<import(\"./style/Style.js\").default>}\n   */\n  let styles;\n  if (Array.isArray(obj)) {\n    styles = obj;\n  } else {\n    assert(\n      typeof (/** @type {?} */ (obj).getZIndex) === 'function',\n      'Expected an `ol/style/Style` or an array of `ol/style/Style.js`',\n    );\n    const style = /** @type {import(\"./style/Style.js\").default} */ (obj);\n    styles = [style];\n  }\n  return function () {\n    return styles;\n  };\n}\nexport default Feature;\n","/**\n * @module ol/geom/MultiPoint\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport {squaredDistance as squaredDx} from '../math.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nclass MultiPoint extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    if (layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  appendPoint(point) {\n    extend(this.flatCoordinates, point.getFlatCoordinates());\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const multiPoint = new MultiPoint(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    multiPoint.applyProperties(this);\n    return multiPoint;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const squaredDistance = squaredDx(\n        x,\n        y,\n        flatCoordinates[i],\n        flatCoordinates[i + 1],\n      );\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (let j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  getPoint(index) {\n    const n = this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(\n      this.flatCoordinates.slice(\n        index * this.stride,\n        (index + 1) * this.stride,\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  getPoints() {\n    const flatCoordinates = this.flatCoordinates;\n    const layout = this.layout;\n    const stride = this.stride;\n    /** @type {Array<Point>} */\n    const points = [];\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiPoint';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default MultiPoint;\n","/**\n * @module ol/geom/MultiPolygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {\n  assignClosestMultiArrayPoint,\n  multiArrayMaxSquaredDelta,\n} from './flat/closest.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {\n  linearRingssAreOriented,\n  orientLinearRingsArray,\n} from './flat/orient.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout =\n        polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    const multiPolygon = new MultiPolygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      newEndss,\n    );\n    multiPolygon.applyProperties(this);\n\n    return multiPolygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        multiArrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.endss_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      x,\n      y,\n    );\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n        right,\n      );\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.endss_,\n        this.stride,\n        flatCenters,\n      );\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatInteriorPoints_);\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\n      ) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\n          this.orientedFlatCoordinates_,\n          0,\n          this.endss_,\n          this.stride,\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEndss,\n    );\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(\n      this.flatCoordinates.slice(offset, end),\n      this.layout,\n      ends,\n    );\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(\n        flatCoordinates.slice(offset, end),\n        layout,\n        ends,\n      );\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.endss_,\n    );\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length =\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\nexport default MultiPolygon;\n","/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  const flatCenters = [];\n  let extent = createEmpty();\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(\n      flatCoordinates,\n      offset,\n      ends[0],\n      stride,\n    );\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n","/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport {extend} from '../array.js';\nimport {\n  createOrUpdateFromCoordinate,\n  createOrUpdateFromFlatCoordinates,\n  getCenter,\n  getHeight,\n} from '../extent.js';\nimport {memoizeOne} from '../functions.js';\nimport {linearRingss as linearRingssCenter} from '../geom/flat/center.js';\nimport {\n  getInteriorPointOfArray,\n  getInteriorPointsOfMultiArray,\n} from '../geom/flat/interiorpoint.js';\nimport {interpolatePoint} from '../geom/flat/interpolate.js';\nimport {inflateEnds} from '../geom/flat/orient.js';\nimport {\n  douglasPeucker,\n  douglasPeuckerArray,\n  quantizeArray,\n} from '../geom/flat/simplify.js';\nimport {transform2D} from '../geom/flat/transform.js';\nimport {\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, stride, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.ends_ = ends || null;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.squaredTolerance_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.stride_ = stride;\n\n    /**\n     * @private\n     * @type {RenderFeature}\n     */\n    this.simplifiedGeometry_;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ =\n        this.type_ === 'Point'\n          ? createOrUpdateFromCoordinate(this.flatCoordinates_)\n          : createOrUpdateFromFlatCoordinates(\n              this.flatCoordinates_,\n              0,\n              this.flatCoordinates_.length,\n              2,\n            );\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(\n        this.flatCoordinates_,\n        0,\n        this.ends_,\n        2,\n        flatCenter,\n        0,\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const ends = inflateEnds(this.flatCoordinates_, this.ends_);\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0, ends, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.flatCoordinates_,\n        0,\n        ends,\n        2,\n        flatCenters,\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        0.5,\n      );\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */ (this.ends_);\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * Get an object of all property names and values.  This has the same behavior as getProperties,\n   * but is here to conform with the {@link module:ol/Feature~Feature} interface.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride_;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(\n        tmpTransform,\n        projectedExtent[0],\n        projectedExtent[3],\n        scale,\n        -scale,\n        0,\n        0,\n        0,\n      );\n      transform2D(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        tmpTransform,\n        this.flatCoordinates_,\n      );\n    }\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   */\n  applyTransform(transformFn) {\n    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);\n  }\n\n  /**\n   * @return {RenderFeature} A cloned render feature.\n   */\n  clone() {\n    return new RenderFeature(\n      this.type_,\n      this.flatCoordinates_.slice(),\n      this.ends_?.slice(),\n      this.stride_,\n      Object.assign({}, this.properties_),\n      this.id_,\n    );\n  }\n\n  /**\n   * @return {Array<number>|null} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Add transform and resolution based geometry simplification to this instance.\n   * @return {RenderFeature} This render feature.\n   */\n  enableSimplifyTransformed() {\n    this.simplifyTransformed = memoizeOne((squaredTolerance, transform) => {\n      if (squaredTolerance === this.squaredTolerance_) {\n        return this.simplifiedGeometry_;\n      }\n      this.simplifiedGeometry_ = this.clone();\n      if (transform) {\n        this.simplifiedGeometry_.applyTransform(transform);\n      }\n      const simplifiedFlatCoordinates =\n        this.simplifiedGeometry_.getFlatCoordinates();\n      let simplifiedEnds;\n      switch (this.type_) {\n        case 'LineString':\n          simplifiedFlatCoordinates.length = douglasPeucker(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.flatCoordinates_.length,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0,\n          );\n          simplifiedEnds = [simplifiedFlatCoordinates.length];\n          break;\n        case 'MultiLineString':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = douglasPeuckerArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds,\n          );\n          break;\n        case 'Polygon':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = quantizeArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            Math.sqrt(squaredTolerance),\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds,\n          );\n          break;\n        default:\n      }\n      if (simplifiedEnds) {\n        this.simplifiedGeometry_ = new RenderFeature(\n          this.type_,\n          simplifiedFlatCoordinates,\n          simplifiedEnds,\n          2,\n          this.properties_,\n          this.id_,\n        );\n      }\n      this.squaredTolerance_ = squaredTolerance;\n      return this.simplifiedGeometry_;\n    });\n    return this;\n  }\n}\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates =\n  RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(\n        renderFeature.getFlatCoordinates(),\n        'XY',\n        /** @type {Array<number>} */ (renderFeature.getEnds()),\n      );\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = renderFeature.getEnds();\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1\n        ? new MultiPolygon(flatCoordinates, 'XY', endss)\n        : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\n\nexport default RenderFeature;\n"],"names":["Feature","geometryOrProperties","undefined","clone","geometry","style","createStyleFunction","id","name","obj","styles","Array","MultiPoint","coordinates","layout","point","multiPoint","x","y","closestPoint","minSquaredDistance","flatCoordinates","stride","i","ii","squaredDistance","j","index","n","points","extent","MultiPolygon","endss","polygons","thisEndss","polygon","offset","ends","jj","len","newEndss","multiPolygon","Math","right","flatCenters","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","prevEnds","end","lastEnds","linearRingss","tmpTransform","RenderFeature","type","properties","key","flatCenter","midpoint","transform","projection","pixelExtent","projectedExtent","scale","transformFn","Object","simplifiedEnds","toGeometry","renderFeature","geometryType","Error","toFeature","geometryName","feature"],"mappings":"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"}