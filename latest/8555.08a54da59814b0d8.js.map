{"version":3,"file":"8555.08a54da59814b0d8.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/ImageTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/layer/TileProperty.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/DataTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/structs/LRUCache.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/ImageTile\n */\nimport {listenImage} from './Image.js';\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/reproj/Tile\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {releaseCanvas} from '../dom.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n"],"names":["ImageTile","tileCoord","state","src","crossOrigin","tileLoadFunction","options","Image","element","getBlankImage","ctx","image","asImageLike","data","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","disposedError","Error","defaultSize","Tile","TileState","imageData","self","error","highWaterMark","undefined","entry","Disposable","keep","key","f","keys","Array","i","values","value","size","getCacheKey","sourceKey","z","x","y","addTileToLookup","tilesByZ","tile","Set","set","existing","getRenderExtent","frameState","extent","layerState","source","gridExtent","CanvasTileLayerRenderer","tileLayer","TileRange","cacheSize","tileCache","tileSource","cacheKey","pixel","layer","coordinate","layerExtent","viewState","tileGrid","tilePixelRatio","tileOrigin","tileSize","tileResolution","col","Math","row","gutter","sourceRevision","initialZ","preload","tileSourceKey","wantedTiles","map","minZ","rotation","viewport","tileRange","tileQueueKey","staleKeys","altZ","covered","loaded","target","currentClip","allTilesIdle","projection","viewResolution","viewCenter","pixelRatio","frameExtent","width","height","dx","dy","canvasExtent","targetZ","nextExtent","renderExtent","setTimeout","uid","time","tileState","alpha","removeTileFromLookup","minZoom","parentZ","canvasScale","context","zs","Object","Number","clips","clipZs","currentZ","currentTilePixelSize","currentScale","currentResolution","originTileCoord","originTileExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","tilesCount","tileCount","alphaChanged","usedTiles","ReprojTile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","wrappedTileCoord","getTileFunction","errorThreshold","renderEdges","targetExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","sourceProjExtent","targetResolution","sourceResolution","isFinite","errorThresholdInPixels","sourceExtent","worldWidth","worldsAway","sourceExtents","sourceRange","srcX","srcY","offset","sources","clipExtent","leftToLoad","sourceListenKey","e","arr"],"mappings":"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"}