{"version":3,"file":"2034.bce23a8888ffbabf.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/TileRange.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/length.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/layer/VectorTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilecoord.js"],"sourcesContent":["/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  let length = 0;\n  for (let i = offset + stride; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n","/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {ascending} from '../../array.js';\nimport {wrapX} from '../../coordinate.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {toSize} from '../../size.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(\n      tile,\n      frameState.pixelRatio,\n      frameState.viewState.projection,\n    );\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n      this.getOrCreateTile(z, x, y, frameState)\n    );\n    if (!tile) {\n      return null;\n    }\n\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tempExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(layer);\n    const declutter = layer.getDeclutter();\n    const declutteredFeatures = declutter\n      ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n      : null;\n    let found;\n    foundFeature: for (let i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const executorGroups = tile.executorGroups[layerUid];\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        found = executorGroups[t].forEachFeatureAtCoordinate(\n          coordinate,\n          resolution,\n          rotation,\n          hitTolerance,\n          featureCallback,\n          declutteredFeatures,\n        );\n        if (found) {\n          break foundFeature;\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    if (this.renderedTiles.length === 0) {\n      return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoordString = tileGrid\n        .getTileCoordForCoordAndResolution(coordinate, resolution)\n        .toString();\n      const tile =\n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n          this.renderedTiles\n        ).find(\n          (tile) =>\n            tile.tileCoord.toString() === tileCoordString &&\n            tile.getState() === TileState.LOADED,\n        );\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      if (\n        source.getWrapX() &&\n        projection.canWrapX() &&\n        !containsExtent(\n          projectionExtent,\n          tileGrid.getTileCoordExtent(tile.tileCoord),\n        )\n      ) {\n        wrapX(coordinate, projection);\n      }\n      const layerUid = getUid(layer);\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      const features = tile\n        .getSourceTiles()\n        .reduce(\n          (accumulator, sourceTile) =>\n            accumulator.concat(sourceTile.getFeatures()),\n          /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */ ([]),\n        );\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    /** @type {Array<import('../../Feature.js').FeatureLike>} */\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      this.frameState.viewState.projection,\n    );\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    /** @type {Object<string, true>} */\n    const visitedSourceTiles = {};\n    tileCache.forEach((tile) => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const key = sourceTile.getKey();\n        if (key in visitedSourceTiles) {\n          continue;\n        }\n        visitedSourceTiles[key] = true;\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const scaledCanvasSize = [\n      this.context.canvas.width,\n      this.context.canvas.height,\n    ];\n    const declutter = this.getLayer().getDeclutter();\n    const declutterTree = declutter\n      ? frameState.declutter?.[declutter]\n      : undefined;\n    const layerUid = getUid(this.getLayer());\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[layerUid];\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            scaledCanvasSize,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutterTree,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(this.getLayer());\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[layerUid].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */ ([]));\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    /** @type {Object<number, true>} */\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).map(Number).sort(ascending);\n    zIndexKeys.forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile The tile\n   * @param {import('../../Map.js').FrameState} frameState Current frame state\n   * @return {import('../../transform.js').Transform} Transform to use to render this tile\n   */\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] -\n      tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    const layerUid = getUid(layer);\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[layerUid].filter((group) =>\n        group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/layer/VectorTile\n */\nimport {assert} from '../asserts.js';\nimport CanvasVectorTileLayerRenderer from '../renderer/canvas/VectorTileLayer.js';\nimport BaseVectorLayer from './BaseVector.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature\n */\n\n/**\n * @typedef {'hybrid' | 'vector'} VectorTileRenderType\n */\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/VectorTile.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:\n *  `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views, but get lifted above all polygon and line elements.\n *  `'vector'`: Everything is rendered as vectors and the original render order is maintained. Use\n *    this mode for improved performance and visual epxerience on vector tile layers with not too many\n *    rendered features (e.g. for highlighting a subset of features of another layer with the same\n *    source).\n * @property {VectorTileSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\n * layers or groups of layers separately, use different truthy values for `declutter`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer\n * style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no\n * background will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=0] The internal tile cache size.  If too small, this will auto-grow to hold\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * Layer for vector tile data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @extends {BaseVectorLayer<FeatureType, VectorTileSourceType, CanvasVectorTileLayerRenderer>}\n * @api\n */\nclass VectorTileLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.preload;\n    const cacheSize = options.cacheSize === undefined ? 0 : options.cacheSize;\n    delete options.cacheSize;\n    delete baseOptions.useInterimTilesOnError;\n\n    super(baseOptions);\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    const renderMode = options.renderMode || 'hybrid';\n    assert(\n      renderMode == 'hybrid' || renderMode == 'vector',\n      \"`renderMode` must be `'hybrid'` or `'vector'`\",\n    );\n\n    /**\n     * @private\n     * @type {VectorTileRenderType}\n     */\n    this.renderMode_ = renderMode;\n\n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n\n    /**\n     * @return {import(\"./Base.js\").BackgroundColor} Background color.\n     * @function\n     * @api\n     */\n    this.getBackground;\n\n    /**\n     * @param {import(\"./Base.js\").BackgroundColor} background Background color.\n     * @function\n     * @api\n     */\n    this.setBackground;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasVectorTileLayerRenderer(this, {\n      cacheSize: this.cacheSize_,\n    });\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   * @override\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    return /** @type {Array<FeatureType>} */ (\n      /** @type {*} */ (this.getRenderer().getFeaturesInExtent(extent))\n    );\n  }\n\n  /**\n   * @return {VectorTileRenderType} The render mode.\n   */\n  getRenderMode() {\n    return this.renderMode_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default VectorTileLayer;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n"],"names":["l","Math","i","t","Promise","r","e","s","d","Object","Number","m","c","Array"],"mappings":"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"}