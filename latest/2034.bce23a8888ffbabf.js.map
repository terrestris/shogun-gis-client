{"version":3,"file":"2034.bce23a8888ffbabf.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/TileRange.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/length.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/layer/VectorTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilecoord.js"],"sourcesContent":["/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  let length = 0;\n  for (let i = offset + stride; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n","/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {ascending} from '../../array.js';\nimport {wrapX} from '../../coordinate.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {toSize} from '../../size.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(\n      tile,\n      frameState.pixelRatio,\n      frameState.viewState.projection,\n    );\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n      this.getOrCreateTile(z, x, y, frameState)\n    );\n    if (!tile) {\n      return null;\n    }\n\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tempExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(layer);\n    const declutter = layer.getDeclutter();\n    const declutteredFeatures = declutter\n      ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n      : null;\n    let found;\n    foundFeature: for (let i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const executorGroups = tile.executorGroups[layerUid];\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        found = executorGroups[t].forEachFeatureAtCoordinate(\n          coordinate,\n          resolution,\n          rotation,\n          hitTolerance,\n          featureCallback,\n          declutteredFeatures,\n        );\n        if (found) {\n          break foundFeature;\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    if (this.renderedTiles.length === 0) {\n      return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoordString = tileGrid\n        .getTileCoordForCoordAndResolution(coordinate, resolution)\n        .toString();\n      const tile =\n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n          this.renderedTiles\n        ).find(\n          (tile) =>\n            tile.tileCoord.toString() === tileCoordString &&\n            tile.getState() === TileState.LOADED,\n        );\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      if (\n        source.getWrapX() &&\n        projection.canWrapX() &&\n        !containsExtent(\n          projectionExtent,\n          tileGrid.getTileCoordExtent(tile.tileCoord),\n        )\n      ) {\n        wrapX(coordinate, projection);\n      }\n      const layerUid = getUid(layer);\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      const features = tile\n        .getSourceTiles()\n        .reduce(\n          (accumulator, sourceTile) =>\n            accumulator.concat(sourceTile.getFeatures()),\n          /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */ ([]),\n        );\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    /** @type {Array<import('../../Feature.js').FeatureLike>} */\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      this.frameState.viewState.projection,\n    );\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    /** @type {Object<string, true>} */\n    const visitedSourceTiles = {};\n    tileCache.forEach((tile) => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const key = sourceTile.getKey();\n        if (key in visitedSourceTiles) {\n          continue;\n        }\n        visitedSourceTiles[key] = true;\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const scaledCanvasSize = [\n      this.context.canvas.width,\n      this.context.canvas.height,\n    ];\n    const declutter = this.getLayer().getDeclutter();\n    const declutterTree = declutter\n      ? frameState.declutter?.[declutter]\n      : undefined;\n    const layerUid = getUid(this.getLayer());\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[layerUid];\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            scaledCanvasSize,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutterTree,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(this.getLayer());\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[layerUid].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */ ([]));\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    /** @type {Object<number, true>} */\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).map(Number).sort(ascending);\n    zIndexKeys.forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile The tile\n   * @param {import('../../Map.js').FrameState} frameState Current frame state\n   * @return {import('../../transform.js').Transform} Transform to use to render this tile\n   */\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] -\n      tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    const layerUid = getUid(layer);\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[layerUid].filter((group) =>\n        group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/layer/VectorTile\n */\nimport {assert} from '../asserts.js';\nimport CanvasVectorTileLayerRenderer from '../renderer/canvas/VectorTileLayer.js';\nimport BaseVectorLayer from './BaseVector.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature\n */\n\n/**\n * @typedef {'hybrid' | 'vector'} VectorTileRenderType\n */\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/VectorTile.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:\n *  `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views, but get lifted above all polygon and line elements.\n *  `'vector'`: Everything is rendered as vectors and the original render order is maintained. Use\n *    this mode for improved performance and visual epxerience on vector tile layers with not too many\n *    rendered features (e.g. for highlighting a subset of features of another layer with the same\n *    source).\n * @property {VectorTileSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\n * layers or groups of layers separately, use different truthy values for `declutter`.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no\n * background will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=0] The internal tile cache size.  If too small, this will auto-grow to hold\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * Layer for vector tile data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @extends {BaseVectorLayer<FeatureType, VectorTileSourceType, CanvasVectorTileLayerRenderer>}\n * @api\n */\nclass VectorTileLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.preload;\n    const cacheSize = options.cacheSize === undefined ? 0 : options.cacheSize;\n    delete options.cacheSize;\n    delete baseOptions.useInterimTilesOnError;\n\n    super(baseOptions);\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    const renderMode = options.renderMode || 'hybrid';\n    assert(\n      renderMode == 'hybrid' || renderMode == 'vector',\n      \"`renderMode` must be `'hybrid'` or `'vector'`\",\n    );\n\n    /**\n     * @private\n     * @type {VectorTileRenderType}\n     */\n    this.renderMode_ = renderMode;\n\n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n\n    /**\n     * @return {import(\"./Base.js\").BackgroundColor} Background color.\n     * @function\n     * @api\n     */\n    this.getBackground;\n\n    /**\n     * @param {import(\"./Base.js\").BackgroundColor} background Background color.\n     * @function\n     * @api\n     */\n    this.setBackground;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasVectorTileLayerRenderer(this, {\n      cacheSize: this.cacheSize_,\n    });\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   * @override\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    return /** @type {Array<FeatureType>} */ (\n      /** @type {*} */ (this.getRenderer().getFeaturesInExtent(extent))\n    );\n  }\n\n  /**\n   * @return {VectorTileRenderType} The render mode.\n   */\n  getRenderMode() {\n    return this.renderMode_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default VectorTileLayer;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n"],"names":["TileRange","minX","maxX","minY","maxY","tileCoord","tileRange","x","y","createOrUpdate","undefined","lineStringLength","flatCoordinates","offset","end","stride","x1","y1","length","i","x2","y2","Math","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","layer","options","tile","frameState","w","h","gutter","transition","z","resolution","viewState","viewHints","hifi","ViewHint","layerRevision","pixelRatio","projection","revision","renderOrder","builderState","source","declutter","sourceTileGrid","tileExtent","tileGrid","sourceTiles","layerUid","t","tt","sourceTile","TileState","sourceTileCoord","sourceTileExtent","sharedExtent","builderExtent","bufferedExtent","builderGroup","squaredTolerance","render","feature","index","styles","styleFunction","dirty","features","ii","executorGroupInstructions","replayExtent","renderingReplayGroup","coordinate","hitTolerance","callback","matches","found","rotation","hitExtent","featureCallback","geometry","distanceSq","key","match","renderedTiles","declutteredFeatures","item","foundFeature","executorGroups","pixel","Promise","resolve","reject","projectionExtent","tileCoordString","extent","corner","tilePixel","accumulator","hitDetectionImageData","tileSize","transforms","tileCache","visitedSourceTiles","tileFeatures","j","jj","candidate","event","layerState","context","alpha","scaledCanvasSize","declutterTree","tiles","acc","executorGroup","executorGroupZIndexContexts","usedZIndices","executorGroupZindexContext","zIndexKeys","Object","Number","zIndex","zIndexContexts","zIndexContext","tileClipContext","center","size","width","height","worldOffset","renderMode","replayTypes","type","tileSource","clips","clipZs","tileClipContexts","ready","group","transform","currentZ","contextSaved","currentClip","clipContext","ZIndexContext","clip","loading","Array","replayState","tileResolution","renderPixelRatio","renderScale","canvasTransform","pixelScale","BaseVector","baseOptions","cacheSize","TileProperty","preload","useInterimTilesOnError","getKeyZXY","hash","withinExtentAndZ"],"mappings":"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"}