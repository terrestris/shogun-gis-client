{"version":3,"file":"4097.fe9e22258222536d.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/Disposable.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/array.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/events/Event.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/events/EventType.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/events/Target.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/GML2.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/GMLBase.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/XMLFeature.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/functions.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/obj.js"],"sourcesContent":["/**\n * @module ol/Disposable\n */\n\n/**\n * @classdesc\n * Objects that need to clean up after themselves.\n */\nclass Disposable {\n  constructor() {\n    /**\n     * The object has already been disposed.\n     * @type {boolean}\n     * @protected\n     */\n    this.disposed = false;\n  }\n\n  /**\n   * Clean up.\n   */\n  dispose() {\n    if (!this.disposed) {\n      this.disposed = true;\n      this.disposeInternal();\n    }\n  }\n\n  /**\n   * Extension point for disposable objects.\n   * @protected\n   */\n  disposeInternal() {}\n}\n\nexport default Disposable;\n","/**\n * @module ol/array\n */\n\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function} [comparator] Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\nexport function binarySearch(haystack, needle, comparator) {\n  let mid, cmp;\n  comparator = comparator || ascending;\n  let low = 0;\n  let high = haystack.length;\n  let found = false;\n\n  while (low < high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + ((high - low) >> 1);\n    cmp = +comparator(haystack[mid], needle);\n\n    if (cmp < 0.0) {\n      /* Too low. */\n      low = mid + 1;\n    } else {\n      /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n\n  /* Key not found. */\n  return found ? low : ~low;\n}\n\n/**\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nexport function ascending(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n/**\n * Compare function sorting arrays in descending order.  Safe to use for numeric values.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is greater than, equal to, or less than the second.\n */\nexport function descending(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\n/**\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\n * of this type to determine which nearest resolution to use.\n *\n * This function takes a `{number}` representing a value between two array entries,\n * a `{number}` representing the value of the nearest higher entry and\n * a `{number}` representing the value of the nearest lower entry\n * as arguments and returns a `{number}`. If a negative number or zero is returned\n * the lower value will be used, if a positive number is returned the higher value\n * will be used.\n * @typedef {function(number, number, number): number} NearestDirectionFunction\n * @api\n */\n\n/**\n * @param {Array<number>} arr Array in descending order.\n * @param {number} target Target.\n * @param {number|NearestDirectionFunction} direction\n *    0 means return the nearest,\n *    > 0 means return the largest nearest,\n *    < 0 means return the smallest nearest.\n * @return {number} Index.\n */\nexport function linearFindNearest(arr, target, direction) {\n  if (arr[0] <= target) {\n    return 0;\n  }\n\n  const n = arr.length;\n  if (target <= arr[n - 1]) {\n    return n - 1;\n  }\n\n  if (typeof direction === 'function') {\n    for (let i = 1; i < n; ++i) {\n      const candidate = arr[i];\n      if (candidate === target) {\n        return i;\n      }\n      if (candidate < target) {\n        if (direction(target, arr[i - 1], candidate) > 0) {\n          return i - 1;\n        }\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  if (direction > 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] < target) {\n        return i - 1;\n      }\n    }\n    return n - 1;\n  }\n\n  if (direction < 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] <= target) {\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  for (let i = 1; i < n; ++i) {\n    if (arr[i] == target) {\n      return i;\n    }\n    if (arr[i] < target) {\n      if (arr[i - 1] - target < target - arr[i]) {\n        return i - 1;\n      }\n      return i;\n    }\n  }\n  return n - 1;\n}\n\n/**\n * @param {Array<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\nexport function reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    const tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n * @template VALUE\n */\nexport function extend(arr, data) {\n  const extension = Array.isArray(data) ? data : [data];\n  const length = extension.length;\n  for (let i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\nexport function remove(arr, obj) {\n  const i = arr.indexOf(obj);\n  const found = i > -1;\n  if (found) {\n    arr.splice(i, 1);\n  }\n  return found;\n}\n\n/**\n * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\nexport function equals(arr1, arr2) {\n  const len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort the passed array such that the relative order of equal elements is preserved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n * @api\n */\nexport function stableSort(arr, compareFnc) {\n  const length = arr.length;\n  const tmp = Array(arr.length);\n  let i;\n  for (i = 0; i < length; i++) {\n    tmp[i] = {index: i, value: arr[i]};\n  }\n  tmp.sort(function (a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n}\n\n/**\n * @param {Array<*>} arr The array to test.\n * @param {Function} [func] Comparison function.\n * @param {boolean} [strict] Strictly sorted (default false).\n * @return {boolean} Return index.\n */\nexport function isSorted(arr, func, strict) {\n  const compare = func || ascending;\n  return arr.every(function (currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n    const res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || (strict && res === 0));\n  });\n}\n","/**\n * @module ol/events/Event\n */\n\n/**\n * @classdesc\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\n * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\n *\n * This implementation only provides `type` and `target` properties, and\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\n * for higher level events defined in the library, and works with\n * {@link module:ol/events/Target~Target}.\n */\nclass BaseEvent {\n  /**\n   * @param {string} type Type.\n   */\n  constructor(type) {\n    /**\n     * @type {boolean}\n     */\n    this.propagationStopped;\n\n    /**\n     * @type {boolean}\n     */\n    this.defaultPrevented;\n\n    /**\n     * The event type.\n     * @type {string}\n     * @api\n     */\n    this.type = type;\n\n    /**\n     * The event target.\n     * @type {Object}\n     * @api\n     */\n    this.target = null;\n  }\n\n  /**\n   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events\n   * will be fired.\n   * @api\n   */\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n\n  /**\n   * Stop event propagation.\n   * @api\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function stopPropagation(evt) {\n  evt.stopPropagation();\n}\n\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function preventDefault(evt) {\n  evt.preventDefault();\n}\n\nexport default BaseEvent;\n","/**\n * @module ol/events/EventType\n */\n\n/**\n * @enum {string}\n * @const\n */\nexport default {\n  /**\n   * Generic change event. Triggered when the revision counter is increased.\n   * @event module:ol/events/Event~BaseEvent#change\n   * @api\n   */\n  CHANGE: 'change',\n\n  /**\n   * Generic error event. Triggered when an error occurs.\n   * @event module:ol/events/Event~BaseEvent#error\n   * @api\n   */\n  ERROR: 'error',\n\n  BLUR: 'blur',\n  CLEAR: 'clear',\n  CONTEXTMENU: 'contextmenu',\n  CLICK: 'click',\n  DBLCLICK: 'dblclick',\n  DRAGENTER: 'dragenter',\n  DRAGOVER: 'dragover',\n  DROP: 'drop',\n  FOCUS: 'focus',\n  KEYDOWN: 'keydown',\n  KEYPRESS: 'keypress',\n  LOAD: 'load',\n  RESIZE: 'resize',\n  TOUCHMOVE: 'touchmove',\n  WHEEL: 'wheel',\n};\n","/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport {VOID} from '../functions.js';\nimport {clear} from '../obj.js';\nimport Event from './Event.js';\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nclass Target extends Disposable {\n  /**\n   * @param {*} [target] Default event target for dispatched events.\n   */\n  constructor(target) {\n    super();\n\n    /**\n     * @private\n     * @type {*}\n     */\n    this.eventTarget_ = target;\n\n    /**\n     * @private\n     * @type {Object<string, number>|null}\n     */\n    this.pendingRemovals_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, number>|null}\n     */\n    this.dispatching_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>|null}\n     */\n    this.listeners_ = null;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  addEventListener(type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n    const listeners = this.listeners_ || (this.listeners_ = {});\n    const listenersForType = listeners[type] || (listeners[type] = []);\n    if (!listenersForType.includes(listener)) {\n      listenersForType.push(listener);\n    }\n  }\n\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n  dispatchEvent(event) {\n    const isString = typeof event === 'string';\n    const type = isString ? event : event.type;\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n\n    const evt = isString ? new Event(event) : /** @type {Event} */ (event);\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\n    const pendingRemovals =\n      this.pendingRemovals_ || (this.pendingRemovals_ = {});\n    if (!(type in dispatching)) {\n      dispatching[type] = 0;\n      pendingRemovals[type] = 0;\n    }\n    ++dispatching[type];\n    let propagate;\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      if ('handleEvent' in listeners[i]) {\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */ (\n          listeners[i]\n        ).handleEvent(evt);\n      } else {\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (\n          listeners[i]\n        ).call(this, evt);\n      }\n      if (propagate === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n    if (--dispatching[type] === 0) {\n      let pr = pendingRemovals[type];\n      delete pendingRemovals[type];\n      while (pr--) {\n        this.removeEventListener(type, VOID);\n      }\n      delete dispatching[type];\n    }\n    return propagate;\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.listeners_ && clear(this.listeners_);\n  }\n\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n   */\n  getListeners(type) {\n    return (this.listeners_ && this.listeners_[type]) || undefined;\n  }\n\n  /**\n   * @param {string} [type] Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n  hasListener(type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return type\n      ? type in this.listeners_\n      : Object.keys(this.listeners_).length > 0;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  removeEventListener(type, listener) {\n    if (!this.listeners_) {\n      return;\n    }\n    const listeners = this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n        // make listener a no-op, and remove later in #dispatchEvent()\n        listeners[index] = VOID;\n        ++this.pendingRemovals_[type];\n      } else {\n        listeners.splice(index, 1);\n        if (listeners.length === 0) {\n          delete this.listeners_[type];\n        }\n      }\n    }\n  }\n}\n\nexport default Target;\n","/**\n * @module ol/format/GML2\n */\nimport {createOrUpdate} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  createElementNS,\n  getAllTextContent,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {writeStringTextNode} from './xsd.js';\n\n/**\n * @const\n * @type {string}\n */\nconst schemaLocation =\n  GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @api\n */\nclass GML2 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(\n      this.readFeaturesInternal,\n    );\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatCoordinates(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n      objectStack[0]\n    );\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    const coordsGroups = s.trim().split(/\\s+/);\n    const flatCoordinates = [];\n    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n      const coords = coordsGroups[i].split(/,+/);\n      const x = parseFloat(coords[0]);\n      const y = parseFloat(coords[1]);\n      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.startsWith('en')) {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readBox(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.BOX_PARSERS_,\n      node,\n      objectStack,\n      this,\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[1][3],\n      flatCoordinates[1][4],\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  innerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  outerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml', nodeName);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null && value !== undefined) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this,\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context,\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context,\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @return {Element} coordinates node.\n   * @private\n   */\n  createCoordinatesNode_(namespaceURI) {\n    const coordinates = createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n\n    return coordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LineString.js\").default|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCoordinates_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      const point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this,\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs',\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    const axisOrientation = srsName\n      ? getProjection(srsName).getAxisOrientation()\n      : 'enu';\n    let coords = axisOrientation.startsWith('en')\n      ? point[0] + ',' + point[1]\n      : point[1] + ',' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ',' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    const point = geometry.getCoordinates();\n    const coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates, coord);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this,\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      'http://www.opengis.net/gml',\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName],\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML2.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML2.prototype.writeMultiCurveOrLineString,\n    ),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n    'curveMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n    'polygonMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\nexport default GML2;\n","/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport {extend} from '../array.js';\nimport Geometry from '../geom/Geometry.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  getAllTextContent,\n  getAttributeNS,\n  makeArrayPusher,\n  makeReplacer,\n  parseNode,\n  pushParseAndPop,\n} from '../xml.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport XMLFeature from './XMLFeature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal),\n    };\n\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop(\n        [],\n        this.FEATURE_COLLECTION_PARSERS,\n        node,\n        objectStack,\n        this,\n      );\n    } else if (\n      localName == 'featureMembers' ||\n      localName == 'featureMember' ||\n      localName == 'member'\n    ) {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        (featureType = []), (featureNS = {});\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */ (node.childNodes[i]);\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType)\n        ? featureType\n        : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':')\n            ? featureTypes[i].split(':')[0]\n            : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n              localName == 'featureMembers'\n                ? makeArrayPusher(this.readFeatureElement, this)\n                : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] =\n      node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const extent = /** @type {import(\"../extent.js\").Extent} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return geometry\n      ? transformGeometryWithOptions(geometry, false, context)\n      : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (\n        n.childNodes.length === 0 ||\n        (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))\n      ) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value =\n            localName === 'boundedBy'\n              ? this.readExtentElement(n, objectStack)\n              : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      const len = n.attributes.length;\n      if (len > 0 && !(value instanceof Geometry)) {\n        value = {_content_: value};\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    }\n    const feature = new Feature(values);\n    if (geometryName) {\n      feature.setGeometryName(geometryName);\n    }\n    const fid =\n      node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n    if (fid) {\n      feature.setId(fid);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop(\n      [],\n      this.MULTIPOINT_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTILINESTRING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTIPOLYGON_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (ring) {\n      return ring;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [\n      this.getReadOptions(node, options ? options : {}),\n    ]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @override\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS,\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @override\n   */\n  readProjectionFromNode(node) {\n    return getProjection(\n      this.srsName\n        ? this.srsName\n        : node.firstElementChild.getAttribute('srsName'),\n    );\n  }\n}\n\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n  },\n};\n\nexport default GMLBase;\n","/**\n * @module ol/format/XMLFeature\n */\nimport {extend} from '../array.js';\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readFeatureFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readFeaturesFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options),\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readGeometryFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    }\n    return this.readProjectionFromNode(/** @type {Element} */ (source));\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @override\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n","/**\n * @module ol/functions\n */\n\nimport {equals as arrayEquals} from './array.js';\n\n/**\n * Always returns true.\n * @return {boolean} true.\n */\nexport function TRUE() {\n  return true;\n}\n\n/**\n * Always returns false.\n * @return {boolean} false.\n */\nexport function FALSE() {\n  return false;\n}\n\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() {}\n\n/**\n * Wrap a function in another function that remembers the last return.  If the\n * returned function is called twice in a row with the same arguments and the same\n * this object, it will return the value from the first call in the second call.\n *\n * @param {function(...any): ReturnType} fn The function to memoize.\n * @return {function(...any): ReturnType} The memoized function.\n * @template ReturnType\n */\nexport function memoizeOne(fn) {\n  /** @type {ReturnType} */\n  let lastResult;\n\n  /** @type {Array<any>|undefined} */\n  let lastArgs;\n\n  let lastThis;\n\n  /**\n   * @this {*} Only need to know if `this` changed, don't care what type\n   * @return {ReturnType} Memoized value\n   */\n  return function () {\n    const nextArgs = Array.prototype.slice.call(arguments);\n    if (!lastArgs || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\n      lastThis = this;\n      lastArgs = nextArgs;\n      lastResult = fn.apply(this, arguments);\n    }\n    return lastResult;\n  };\n}\n\n/**\n * @template T\n * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.\n * @return {Promise<T>} A promise for the value.\n */\nexport function toPromise(getter) {\n  function promiseGetter() {\n    let value;\n    try {\n      value = getter();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    if (value instanceof Promise) {\n      return value;\n    }\n    return Promise.resolve(value);\n  }\n  return promiseGetter();\n}\n","/**\n * @module ol/obj\n */\n\n/**\n * Removes all properties from an object.\n * @param {Object<string, unknown>} object The object to clear.\n */\nexport function clear(object) {\n  for (const property in object) {\n    delete object[property];\n  }\n}\n\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */\nexport function isEmpty(object) {\n  let property;\n  for (property in object) {\n    return false;\n  }\n  return !property;\n}\n"],"names":["t","n","i","Array","e","Object","parseFloat","s","l","g","r","Node","arguments","Promise"],"mappings":"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"}