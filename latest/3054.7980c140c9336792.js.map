{"version":3,"file":"3054.7980c140c9336792.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/Image.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/TileRange.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/layer/BaseTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/layer/Tile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/size.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilecoord.js"],"sourcesContent":["/**\n * @module ol/Image\n */\nimport ImageState from './ImageState.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {listenOnce, unlistenByKey} from './events.js';\nimport {toPromise} from './functions.js';\nimport {CREATE_IMAGE_BITMAP, IMAGE_DECODE} from './has.js';\n\n/**\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\n * @api\n */\n\n/**\n * @typedef {Object} ImageObject\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * For images that cover any extent and resolution (static images), the loader function should not accept\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\n * correct `extent`, `resolution` and `pixelRatio`.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\n * @api\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\n */\n\nclass ImageWrapper extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\n   * resolution will be assumed.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default|Loader} stateOrLoader State.\n   */\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number|Array<number>|undefined}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n    this.state =\n      typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\n\n    /**\n     * @private\n     * @type {import('./DataTile.js').ImageLike|null}\n     */\n    this.image_ = null;\n\n    /**\n     * @protected\n     * @type {Loader|null}\n     */\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\n   * @return {import('./DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * @return {number} PixelRatio.\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\n   * @return {number|Array<number>} Resolution.\n   */\n  getResolution() {\n    return /** @type {number} */ (this.resolution);\n  }\n\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      if (this.loader) {\n        this.state = ImageState.LOADING;\n        this.changed();\n        const resolution = this.getResolution();\n        const requestResolution = Array.isArray(resolution)\n          ? resolution[0]\n          : resolution;\n        toPromise(() =>\n          this.loader(\n            this.getExtent(),\n            requestResolution,\n            this.getPixelRatio(),\n          ),\n        )\n          .then((image) => {\n            if ('image' in image) {\n              this.image_ = image.image;\n            }\n            if ('extent' in image) {\n              this.extent = image.extent;\n            }\n            if ('resolution' in image) {\n              this.resolution = image.resolution;\n            }\n            if ('pixelRatio' in image) {\n              this.pixelRatio_ = image.pixelRatio;\n            }\n            if (\n              image instanceof HTMLImageElement ||\n              (CREATE_IMAGE_BITMAP && image instanceof ImageBitmap) ||\n              image instanceof HTMLCanvasElement ||\n              image instanceof HTMLVideoElement\n            ) {\n              this.image_ = image;\n            }\n            this.state = ImageState.LOADED;\n          })\n          .catch((error) => {\n            this.state = ImageState.ERROR;\n            console.error(error); // eslint-disable-line no-console\n          })\n          .finally(() => this.changed());\n      }\n    }\n  }\n\n  /**\n   * @param {import('./DataTile.js').ImageLike} image The image.\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\n   * @param {number|Array<number>} resolution Resolution.\n   */\n  setResolution(resolution) {\n    this.resolution = resolution;\n  }\n}\n\n/**\n * @param {import('./DataTile.js').ImageLike} image Image element.\n * @param {function():any} loadHandler Load callback function.\n * @param {function():any} errorHandler Error callback function.\n * @return {function():void} Callback to stop listening.\n */\nexport function listenImage(image, loadHandler, errorHandler) {\n  const img = /** @type {HTMLImageElement} */ (image);\n  let listening = true;\n  let decoding = false;\n  let loaded = false;\n\n  const listenerKeys = [\n    listenOnce(img, EventType.LOAD, function () {\n      loaded = true;\n      if (!decoding) {\n        loadHandler();\n      }\n    }),\n  ];\n\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img\n      .decode()\n      .then(function () {\n        if (listening) {\n          loadHandler();\n        }\n      })\n      .catch(function (error) {\n        if (listening) {\n          if (loaded) {\n            loadHandler();\n          } else {\n            errorHandler();\n          }\n        }\n      });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\n\n/**\n * Loads an image.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n * @api\n */\nexport function load(image, src) {\n  return new Promise((resolve, reject) => {\n    function handleLoad() {\n      unlisten();\n      resolve(image);\n    }\n    function handleError() {\n      unlisten();\n      reject(new Error('Image load error'));\n    }\n    function unlisten() {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    }\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n    if (src) {\n      image.src = src;\n    }\n  });\n}\n\n/**\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n */\nexport function decodeFallback(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE\n    ? new Promise((resolve, reject) =>\n        image\n          .decode()\n          .then(() => resolve(image))\n          .catch((e) =>\n            image.complete && image.width ? resolve(image) : reject(e),\n          ),\n      )\n    : load(image);\n}\n\n/**\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\n * the loaded image otherwise.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\n * @api\n */\nexport function decode(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP\n    ? image\n        .decode()\n        .then(() => createImageBitmap(image))\n        .catch((e) => {\n          if (image.complete && image.width) {\n            return image;\n          }\n          throw e;\n        })\n    : decodeFallback(image);\n}\n\nexport default ImageWrapper;\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/layer/Tile\n */\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\nimport BaseTileLayer from './BaseTile.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this, {\n      cacheSize: this.getCacheSize(),\n    });\n  }\n}\n\nexport default TileLayer;\n","/**\n * @module ol/size\n */\n\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = size[0] + 2 * num;\n  dest[1] = size[1] + 2 * num;\n  return dest;\n}\n\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\n\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = (size[0] * ratio + 0.5) | 0;\n  dest[1] = (size[1] * ratio + 0.5) | 0;\n  return dest;\n}\n\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, dest) {\n  if (Array.isArray(size)) {\n    return size;\n  }\n  if (dest === undefined) {\n    dest = [size, size];\n  } else {\n    dest[0] = size;\n    dest[1] = size;\n  }\n  return dest;\n}\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {number} Hash.\n */\nexport function hashZXY(z, x, y) {\n  return (x << z) + y;\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n"],"names":["ImageWrapper","extent","resolution","pixelRatio","stateOrLoader","requestResolution","Array","image","HTMLImageElement","ImageBitmap","HTMLCanvasElement","HTMLVideoElement","error","console","listenImage","loadHandler","errorHandler","listening","decoding","loaded","listenerKeys","img","decodeFallback","src","Promise","resolve","reject","e","handleLoad","unlisten","handleError","Error","decode","createImageBitmap","TileRange","minX","maxX","minY","maxY","tileCoord","tileRange","x","y","createOrUpdate","undefined","BaseTileLayer","Layer","options","baseOptions","Object","cacheSize","TileProperty","preload","useInterimTilesOnError","pixel","BaseTile","hasArea","size","scale","ratio","dest","toSize","z","getKeyZXY","hash","hashZXY","withinExtentAndZ","tileGrid"],"mappings":"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"}