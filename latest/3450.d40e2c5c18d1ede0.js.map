{"version":3,"file":"3450.d40e2c5c18d1ede0.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/GML3.js"],"sourcesContent":["/**\n * @module ol/format/GML3\n */\nimport {extend} from '../array.js';\nimport {createOrUpdate} from '../extent.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport GML2 from './GML2.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation =\n  GMLNS +\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n  '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ =\n      options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ =\n      options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Polygon.\n   */\n  readFlatCurveRing(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    const flatCoordinates = [];\n    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n      extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTISURFACE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.PATCHES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.SURFACE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.CURVE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.ENVELOPE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[2][0],\n      flatCoordinates[2][1],\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const axisOrientation = containerSrs\n      ? getProjection(containerSrs).getAxisOrientation()\n      : 'enu';\n    if (axisOrientation === 'neu') {\n      for (let i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    const axisOrientation = containerSrs\n      ? getProjection(containerSrs).getAxisOrientation()\n      : 'enu';\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n    ) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension'),\n      );\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    const asXYZ = axisOrientation.startsWith('en');\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (asXYZ) {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    const axisOrientation = srsName\n      ? getProjection(srsName).getAxisOrientation()\n      : 'enu';\n    const point = value.getCoordinates();\n    // only 2d for simple features profile\n    let coords = axisOrientation.startsWith('en')\n      ? point[0] + ' ' + point[1]\n      : point[1] + ' ' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    const axisOrientation = srsName\n      ? getProjection(srsName).getAxisOrientation()\n      : 'enu';\n    let coords = axisOrientation.startsWith('en')\n      ? point[0] + ' ' + point[1]\n      : point[1] + ' ' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior',\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this,\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context,\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context,\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null && value !== undefined) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this,\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement,\n      this,\n    );\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS),\n      features,\n      objectStack,\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName],\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   * @override\n   */\n  writeGeometryNode(geometry, options) {\n    options = this.adaptOptions(options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Element} Node.\n   * @api\n   * @override\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation,\n    );\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment,\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember,\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember,\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString,\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML3;\n"],"names":["parseFloat","l","p","Array","s","Object"],"mappings":"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"}