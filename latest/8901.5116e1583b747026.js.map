{"version":3,"file":"8901.5116e1583b747026.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/GML2.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/GMLBase.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/XMLFeature.js"],"sourcesContent":["/**\n * @module ol/format/GML2\n */\nimport {createOrUpdate} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  createElementNS,\n  getAllTextContent,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {writeStringTextNode} from './xsd.js';\n\n/**\n * @const\n * @type {string}\n */\nconst schemaLocation =\n  GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @api\n */\nclass GML2 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(\n      this.readFeaturesInternal,\n    );\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatCoordinates(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n      objectStack[0]\n    );\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    const coordsGroups = s.trim().split(/\\s+/);\n    const flatCoordinates = [];\n    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n      const coords = coordsGroups[i].split(/,+/);\n      const x = parseFloat(coords[0]);\n      const y = parseFloat(coords[1]);\n      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.startsWith('en')) {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readBox(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.BOX_PARSERS_,\n      node,\n      objectStack,\n      this,\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[1][3],\n      flatCoordinates[1][4],\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  innerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  outerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml', nodeName);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null && value !== undefined) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this,\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context,\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context,\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @return {Element} coordinates node.\n   * @private\n   */\n  createCoordinatesNode_(namespaceURI) {\n    const coordinates = createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n\n    return coordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LineString.js\").default|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCoordinates_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      const point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this,\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs',\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    const axisOrientation = srsName\n      ? getProjection(srsName).getAxisOrientation()\n      : 'enu';\n    let coords = axisOrientation.startsWith('en')\n      ? point[0] + ',' + point[1]\n      : point[1] + ',' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ',' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    const point = geometry.getCoordinates();\n    const coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates, coord);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this,\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      'http://www.opengis.net/gml',\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName],\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML2.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML2.prototype.writeMultiCurveOrLineString,\n    ),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n    'curveMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n    'polygonMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\nexport default GML2;\n","/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport {extend} from '../array.js';\nimport Geometry from '../geom/Geometry.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  getAllTextContent,\n  getAttributeNS,\n  makeArrayPusher,\n  makeReplacer,\n  parseNode,\n  pushParseAndPop,\n} from '../xml.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport XMLFeature from './XMLFeature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal),\n    };\n\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop(\n        [],\n        this.FEATURE_COLLECTION_PARSERS,\n        node,\n        objectStack,\n        this,\n      );\n    } else if (\n      localName == 'featureMembers' ||\n      localName == 'featureMember' ||\n      localName == 'member'\n    ) {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        (featureType = []), (featureNS = {});\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */ (node.childNodes[i]);\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType)\n        ? featureType\n        : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':')\n            ? featureTypes[i].split(':')[0]\n            : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n              localName == 'featureMembers'\n                ? makeArrayPusher(this.readFeatureElement, this)\n                : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] =\n      node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const extent = /** @type {import(\"../extent.js\").Extent} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return geometry\n      ? transformGeometryWithOptions(geometry, false, context)\n      : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (\n        n.childNodes.length === 0 ||\n        (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))\n      ) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value =\n            localName === 'boundedBy'\n              ? this.readExtentElement(n, objectStack)\n              : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      const len = n.attributes.length;\n      if (len > 0 && !(value instanceof Geometry)) {\n        value = {_content_: value};\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    }\n    const feature = new Feature(values);\n    if (geometryName) {\n      feature.setGeometryName(geometryName);\n    }\n    const fid =\n      node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n    if (fid) {\n      feature.setId(fid);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop(\n      [],\n      this.MULTIPOINT_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTILINESTRING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTIPOLYGON_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (ring) {\n      return ring;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [\n      this.getReadOptions(node, options ? options : {}),\n    ]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @override\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS,\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @override\n   */\n  readProjectionFromNode(node) {\n    return getProjection(\n      this.srsName\n        ? this.srsName\n        : node.firstElementChild.getAttribute('srsName'),\n    );\n  }\n}\n\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n  },\n};\n\nexport default GMLBase;\n","/**\n * @module ol/format/XMLFeature\n */\nimport {extend} from '../array.js';\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readFeatureFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readFeaturesFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options),\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readGeometryFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    }\n    return this.readProjectionFromNode(/** @type {Element} */ (source));\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @override\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n"],"names":["schemaLocation","MULTIGEOMETRY_TO_MEMBER_NODENAME","GML2","options","node","objectStack","s","containerSrs","context","axisOrientation","proj","coordsGroups","flatCoordinates","i","ii","coords","x","parseFloat","y","z","flatLinearRing","undefined","flatLinearRings","value","nodeName","multiSurface","surface","multiCurve","Array","feature","fid","featureNS","geometryName","keys","values","properties","key","item","Object","geometry","srsName","coordinates","segments","line","child","hasZ","curve","lines","namespaceURI","points","len","parts","point","rings","patches","parentNode","exteriorWritten","polygon","ring","linearRing","coord","polygons","extent","GMLNS","ONLY_WHITESPACE_RE","GMLBase","localName","features","featureType","ft","count","uri","candidate","prefix","ns","parsersNS","featureTypes","p","parsers","asFeature","n","lineStrings","ends","internalOptions","XMLFeature","source","doc","Node"],"mappings":"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"}