{"version":3,"file":"8778.363889b7ff2b6a30.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/console.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/coordinate.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/math.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj/epsg3857.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj/epsg4326.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj/utm.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj/Projection.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj/Units.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj/projections.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/proj/transforms.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/sphere.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/string.js"],"sourcesContent":["/**\n * @module ol/console\n */\n\n/**\n * @typedef {'info'|'warn'|'error'|'none'} Level\n */\n\n/**\n * @type {Object<Level, number>}\n */\nconst levels = {\n  info: 1,\n  warn: 2,\n  error: 3,\n  none: 4,\n};\n\n/**\n * @type {number}\n */\nlet level = levels.info;\n\n/**\n * Set the logging level.  By default, the level is set to 'info' and all\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\n *\n * @param {Level} l The new level.\n */\nexport function setLevel(l) {\n  level = levels[l];\n}\n\n/**\n * @param  {...any} args Arguments to log\n */\nexport function log(...args) {\n  if (level > levels.info) {\n    return;\n  }\n  console.log(...args); // eslint-disable-line no-console\n}\n\n/**\n * @param  {...any} args Arguments to log\n */\nexport function warn(...args) {\n  if (level > levels.warn) {\n    return;\n  }\n  console.warn(...args); // eslint-disable-line no-console\n}\n\n/**\n * @param  {...any} args Arguments to log\n */\nexport function error(...args) {\n  if (level > levels.error) {\n    return;\n  }\n  console.error(...args); // eslint-disable-line no-console\n}\n","/**\n * @module ol/coordinate\n */\nimport {getWidth} from './extent.js';\nimport {modulo, toFixed} from './math.js';\nimport {padNumber} from './string.js';\n\n/**\n * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.\n * Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n  coordinate[0] += +delta[0];\n  coordinate[1] += +delta[1];\n  return coordinate;\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n  const r = circle.getRadius();\n  const center = circle.getCenter();\n  const x0 = center[0];\n  const y0 = center[1];\n  const x1 = coordinate[0];\n  const y1 = coordinate[1];\n\n  let dx = x1 - x0;\n  const dy = y1 - y0;\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const x = x0 + (r * dx) / d;\n  const y = y0 + (r * dy) / d;\n\n  return [x, y];\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n  const x0 = coordinate[0];\n  const y0 = coordinate[1];\n  const start = segment[0];\n  const end = segment[1];\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const along =\n    dx === 0 && dy === 0\n      ? 0\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  let x, y;\n  if (along <= 0) {\n    x = x1;\n    y = y1;\n  } else if (along >= 1) {\n    x = x2;\n    y = y2;\n  } else {\n    x = x1 + along * dx;\n    y = y1 + along * dy;\n  }\n  return [x, y];\n}\n\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY();\n *     const out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY(2);\n *     const out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(fractionDigits) {\n  return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n      return toStringXY(coordinate, fractionDigits);\n    }\n  );\n}\n\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\n  const x = Math.abs(3600 * normalizedDegrees);\n  const decimals = fractionDigits || 0;\n\n  let deg = Math.floor(x / 3600);\n  let min = Math.floor((x - deg * 3600) / 60);\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\n\n  if (sec >= 60) {\n    sec = 0;\n    min += 1;\n  }\n\n  if (min >= 60) {\n    min = 0;\n    deg += 1;\n  }\n\n  let hdms = deg + '\\u00b0';\n  if (min !== 0 || sec !== 0) {\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\n  }\n  if (sec !== 0) {\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\n  }\n  if (normalizedDegrees !== 0) {\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\n  }\n\n  return hdms;\n}\n\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, fractionDigits) {\n  if (coordinate) {\n    return template\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\n  }\n  return '';\n}\n\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n  let equals = true;\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\n    if (coordinate1[i] != coordinate2[i]) {\n      equals = false;\n      break;\n    }\n  }\n  return equals;\n}\n\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x;\n  coordinate[1] = y;\n  return coordinate;\n}\n\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n  coordinate[0] *= scale;\n  coordinate[1] *= scale;\n  return coordinate;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n  const dx = coord1[0] - coord2[0];\n  const dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\n\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord);\n *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord, 1);\n *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, fractionDigits) {\n  if (coordinate) {\n    return (\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\n      ' ' +\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\n    );\n  }\n  return '';\n}\n\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, fractionDigits) {\n  return format(coordinate, '{x}, {y}', fractionDigits);\n}\n\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n  if (projection.canWrapX()) {\n    const worldWidth = getWidth(projection.getExtent());\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n    if (worldsAway) {\n      coordinate[0] -= worldsAway * worldWidth;\n    }\n  }\n  return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number} [sourceExtentWidth] Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\n  const projectionExtent = projection.getExtent();\n  let worldsAway = 0;\n  if (\n    projection.canWrapX() &&\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\n  ) {\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\n    worldsAway = Math.floor(\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth,\n    );\n  }\n  return worldsAway;\n}\n","/**\n * @module ol/math\n */\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\nexport function clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n  return squaredDistance(x, y, x1, y1);\n}\n\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredDistance(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>|null} The resulting vector.\n */\nexport function solveLinearSystem(mat) {\n  const n = mat.length;\n\n  for (let i = 0; i < n; i++) {\n    // Find max in the i-th column (ignoring i - 1 first rows)\n    let maxRow = i;\n    let maxEl = Math.abs(mat[i][i]);\n    for (let r = i + 1; r < n; r++) {\n      const absValue = Math.abs(mat[r][i]);\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r;\n      }\n    }\n\n    if (maxEl === 0) {\n      return null; // matrix is singular\n    }\n\n    // Swap max row with i-th (current) row\n    const tmp = mat[maxRow];\n    mat[maxRow] = mat[i];\n    mat[i] = tmp;\n\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n    for (let j = i + 1; j < n; j++) {\n      const coef = -mat[j][i] / mat[i][i];\n      for (let k = i; k < n + 1; k++) {\n        if (i == k) {\n          mat[j][k] = 0;\n        } else {\n          mat[j][k] += coef * mat[i][k];\n        }\n      }\n    }\n  }\n\n  // Solve Ax=b for upper triangular matrix A (mat)\n  const x = new Array(n);\n  for (let l = n - 1; l >= 0; l--) {\n    x[l] = mat[l][n] / mat[l][l];\n    for (let m = l - 1; m >= 0; m--) {\n      mat[m][n] -= mat[m][l] * x[l];\n    }\n  }\n  return x;\n}\n\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\nexport function toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\nexport function toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\nexport function modulo(a, b) {\n  const r = a % b;\n  return r * b < 0 ? r + b : r;\n}\n\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\nexport function lerp(a, b, x) {\n  return a + x * (b - a);\n}\n\n/**\n * Returns a number with a limited number of decimal digits.\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The input number with a limited number of decimal digits.\n */\nexport function toFixed(n, decimals) {\n  const factor = Math.pow(10, decimals);\n  return Math.round(n * factor) / factor;\n}\n\n/**\n * Rounds a number to the nearest integer value considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The nearest integer.\n */\nexport function round(n, decimals) {\n  return Math.round(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next smaller integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next smaller integer.\n */\nexport function floor(n, decimals) {\n  return Math.floor(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next bigger integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next bigger integer.\n */\nexport function ceil(n, decimals) {\n  return Math.ceil(toFixed(n, decimals));\n}\n\n/**\n * Wraps a number between some minimum and maximum values.\n * @param {number} n The number to wrap.\n * @param {number} min The minimum of the range (inclusive).\n * @param {number} max The maximum of the range (exclusive).\n * @return {number} The wrapped number.\n */\nexport function wrap(n, min, max) {\n  if (n >= min && n < max) {\n    return n;\n  }\n  const range = max - min;\n  return ((((n - min) % range) + range) % range) + min;\n}\n","/**\n * @module ol/proj/epsg3857\n */\nimport Projection from './Projection.js';\n\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * @const\n * @type {number}\n */\nexport const HALF_SIZE = Math.PI * RADIUS;\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\n\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nclass EPSG3857Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   */\n  constructor(code) {\n    super({\n      code: code,\n      units: 'm',\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function (resolution, point) {\n        return resolution / Math.cosh(point[1] / RADIUS);\n      },\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG3857Projection('EPSG:3857'),\n  new EPSG3857Projection('EPSG:102100'),\n  new EPSG3857Projection('EPSG:102113'),\n  new EPSG3857Projection('EPSG:900913'),\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\n];\n\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @param {number} [stride] Stride (default is `dimension`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function fromEPSG4326(input, output, dimension, stride) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  stride = stride ?? dimension;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += stride) {\n    output[i] = (HALF_SIZE * input[i]) / 180;\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\n    if (y > MAX_SAFE_Y) {\n      y = MAX_SAFE_Y;\n    } else if (y < -MAX_SAFE_Y) {\n      y = -MAX_SAFE_Y;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n}\n\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @param {number} [stride] Stride (default is `dimension`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function toEPSG4326(input, output, dimension, stride) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  stride = stride ?? dimension;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += stride) {\n    output[i] = (180 * input[i]) / HALF_SIZE;\n    output[i + 1] =\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\n  }\n  return output;\n}\n","/**\n * @module ol/proj/epsg4326\n */\nimport Projection from './Projection.js';\n\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-180, -90, 180, 90];\n\n/**\n * @const\n * @type {number}\n */\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\n\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nclass EPSG4326Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   * @param {string} [axisOrientation] Axis orientation.\n   */\n  constructor(code, axisOrientation) {\n    super({\n      code: code,\n      units: 'degrees',\n      extent: EXTENT,\n      axisOrientation: axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: EXTENT,\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG4326Projection('CRS:84'),\n  new EPSG4326Projection('EPSG:4326', 'neu'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\n];\n","/**\n * @module ol/proj/utm\n */\n\n/**\n * Adapted from https://github.com/Turbo87/utm\n * Copyright (c) 2012-2017 Tobias Bieniek\n *\n * The functions here provide approximate transforms to and from UTM.\n * They are not appropriate for use beyond the validity extend of a UTM\n * zone, and the accuracy of the transform decreases toward the zone\n * edges.\n */\n\nimport {toDegrees, toRadians, wrap} from '../math.js';\nimport Projection from './Projection.js';\n\n/**\n * @typedef {Object} UTMZone\n * @property {number} number The zone number (1 - 60).\n * @property {boolean} north The northern hemisphere.\n */\n\nconst K0 = 0.9996;\n\nconst E = 0.00669438;\nconst E2 = E * E;\nconst E3 = E2 * E;\nconst E_P2 = E / (1 - E);\n\nconst SQRT_E = Math.sqrt(1 - E);\nconst _E = (1 - SQRT_E) / (1 + SQRT_E);\nconst _E2 = _E * _E;\nconst _E3 = _E2 * _E;\nconst _E4 = _E3 * _E;\nconst _E5 = _E4 * _E;\n\nconst M1 = 1 - E / 4 - (3 * E2) / 64 - (5 * E3) / 256;\nconst M2 = (3 * E) / 8 + (3 * E2) / 32 + (45 * E3) / 1024;\nconst M3 = (15 * E2) / 256 + (45 * E3) / 1024;\nconst M4 = (35 * E3) / 3072;\n\nconst P2 = (3 / 2) * _E - (27 / 32) * _E3 + (269 / 512) * _E5;\nconst P3 = (21 / 16) * _E2 - (55 / 32) * _E4;\nconst P4 = (151 / 96) * _E3 - (417 / 128) * _E5;\nconst P5 = (1097 / 512) * _E4;\n\nconst R = 6378137;\n\n/**\n * @param {number} easting Easting value of coordinate.\n * @param {number} northing Northing value of coordinate.\n * @param {UTMZone} zone The UTM zone.\n * @return {import(\"../coordinate.js\").Coordinate} The transformed coordinate.\n */\nfunction toLonLat(easting, northing, zone) {\n  const x = easting - 500000;\n  const y = zone.north ? northing : northing - 10000000;\n\n  const m = y / K0;\n  const mu = m / (R * M1);\n\n  const pRad =\n    mu +\n    P2 * Math.sin(2 * mu) +\n    P3 * Math.sin(4 * mu) +\n    P4 * Math.sin(6 * mu) +\n    P5 * Math.sin(8 * mu);\n\n  const pSin = Math.sin(pRad);\n  const pSin2 = pSin * pSin;\n\n  const pCos = Math.cos(pRad);\n\n  const pTan = pSin / pCos;\n  const pTan2 = pTan * pTan;\n  const pTan4 = pTan2 * pTan2;\n\n  const epSin = 1 - E * pSin2;\n  const epSinSqrt = Math.sqrt(1 - E * pSin2);\n\n  const n = R / epSinSqrt;\n  const r = (1 - E) / epSin;\n\n  const c = E_P2 * pCos ** 2;\n  const c2 = c * c;\n\n  const d = x / (n * K0);\n  const d2 = d * d;\n  const d3 = d2 * d;\n  const d4 = d3 * d;\n  const d5 = d4 * d;\n  const d6 = d5 * d;\n\n  const latitude =\n    pRad -\n    (pTan / r) *\n      (d2 / 2 - (d4 / 24) * (5 + 3 * pTan2 + 10 * c - 4 * c2 - 9 * E_P2)) +\n    (d6 / 720) * (61 + 90 * pTan2 + 298 * c + 45 * pTan4 - 252 * E_P2 - 3 * c2);\n\n  let longitude =\n    (d -\n      (d3 / 6) * (1 + 2 * pTan2 + c) +\n      (d5 / 120) * (5 - 2 * c + 28 * pTan2 - 3 * c2 + 8 * E_P2 + 24 * pTan4)) /\n    pCos;\n\n  longitude = wrap(\n    longitude + toRadians(zoneToCentralLongitude(zone.number)),\n    -Math.PI,\n    Math.PI,\n  );\n\n  return [toDegrees(longitude), toDegrees(latitude)];\n}\n\nconst MIN_LATITUDE = -80;\nconst MAX_LATITUDE = 84;\nconst MIN_LONGITUDE = -180;\nconst MAX_LONGITUDE = 180;\n\n/**\n * @param {number} longitude The longitude.\n * @param {number} latitude The latitude.\n * @param {UTMZone} zone The UTM zone.\n * @return {import('../coordinate.js').Coordinate} The UTM coordinate.\n */\nfunction fromLonLat(longitude, latitude, zone) {\n  longitude = wrap(longitude, MIN_LONGITUDE, MAX_LONGITUDE);\n\n  if (latitude < MIN_LATITUDE) {\n    latitude = MIN_LATITUDE;\n  } else if (latitude > MAX_LATITUDE) {\n    latitude = MAX_LATITUDE;\n  }\n\n  const latRad = toRadians(latitude);\n  const latSin = Math.sin(latRad);\n  const latCos = Math.cos(latRad);\n\n  const latTan = latSin / latCos;\n  const latTan2 = latTan * latTan;\n  const latTan4 = latTan2 * latTan2;\n\n  const lonRad = toRadians(longitude);\n  const centralLon = zoneToCentralLongitude(zone.number);\n  const centralLonRad = toRadians(centralLon);\n\n  const n = R / Math.sqrt(1 - E * latSin ** 2);\n  const c = E_P2 * latCos ** 2;\n\n  const a = latCos * wrap(lonRad - centralLonRad, -Math.PI, Math.PI);\n  const a2 = a * a;\n  const a3 = a2 * a;\n  const a4 = a3 * a;\n  const a5 = a4 * a;\n  const a6 = a5 * a;\n\n  const m =\n    R *\n    (M1 * latRad -\n      M2 * Math.sin(2 * latRad) +\n      M3 * Math.sin(4 * latRad) -\n      M4 * Math.sin(6 * latRad));\n\n  const easting =\n    K0 *\n      n *\n      (a +\n        (a3 / 6) * (1 - latTan2 + c) +\n        (a5 / 120) * (5 - 18 * latTan2 + latTan4 + 72 * c - 58 * E_P2)) +\n    500000;\n\n  let northing =\n    K0 *\n    (m +\n      n *\n        latTan *\n        (a2 / 2 +\n          (a4 / 24) * (5 - latTan2 + 9 * c + 4 * c ** 2) +\n          (a6 / 720) * (61 - 58 * latTan2 + latTan4 + 600 * c - 330 * E_P2)));\n\n  if (!zone.north) {\n    northing += 10000000;\n  }\n\n  return [easting, northing];\n}\n\n/**\n * @param {number} zone The zone number.\n * @return {number} The central longitude in degrees.\n */\nfunction zoneToCentralLongitude(zone) {\n  return (zone - 1) * 6 - 180 + 3;\n}\n\n/**\n * @type {Array<RegExp>}\n */\nconst epsgRegExes = [\n  /^EPSG:(\\d+)$/,\n  /^urn:ogc:def:crs:EPSG::(\\d+)$/,\n  /^http:\\/\\/www\\.opengis\\.net\\/def\\/crs\\/EPSG\\/0\\/(\\d+)$/,\n];\n\n/**\n * @param {string} code The projection code.\n * @return {UTMZone|null} The UTM zone info (or null if not UTM).\n */\nexport function zoneFromCode(code) {\n  let epsgId = 0;\n  for (const re of epsgRegExes) {\n    const match = code.match(re);\n    if (match) {\n      epsgId = parseInt(match[1]);\n      break;\n    }\n  }\n  if (!epsgId) {\n    return null;\n  }\n\n  let number = 0;\n  let north = false;\n  if (epsgId > 32700 && epsgId < 32761) {\n    number = epsgId - 32700;\n  } else if (epsgId > 32600 && epsgId < 32661) {\n    north = true;\n    number = epsgId - 32600;\n  }\n  if (!number) {\n    return null;\n  }\n\n  return {number, north};\n}\n\n/**\n * @param {function(number, number, UTMZone): import('../coordinate.js').Coordinate} transformer The transformer.\n * @param {UTMZone} zone The UTM zone.\n * @return {import('../proj.js').TransformFunction} The transform function.\n */\nfunction makeTransformFunction(transformer, zone) {\n  return function (input, output, dimension, stride) {\n    const length = input.length;\n    dimension = dimension > 1 ? dimension : 2;\n    stride = stride ?? dimension;\n    if (!output) {\n      if (dimension > 2) {\n        output = input.slice();\n      } else {\n        output = new Array(length);\n      }\n    }\n    for (let i = 0; i < length; i += stride) {\n      const x = input[i];\n      const y = input[i + 1];\n      const coord = transformer(x, y, zone);\n      output[i] = coord[0];\n      output[i + 1] = coord[1];\n    }\n    return output;\n  };\n}\n\n/**\n * @param {string} code The projection code.\n * @return {import('./Projection.js').default|null} A projection or null if unable to create one.\n */\nexport function makeProjection(code) {\n  const zone = zoneFromCode(code);\n  if (!zone) {\n    return null;\n  }\n  return new Projection({code, units: 'm'});\n}\n\n/**\n * @param {import('./Projection.js').default} projection The projection.\n * @return {import('../proj.js').Transforms|null} The transforms lookup or null if unable to handle projection.\n */\nexport function makeTransforms(projection) {\n  const zone = zoneFromCode(projection.getCode());\n  if (!zone) {\n    return null;\n  }\n\n  return {\n    forward: makeTransformFunction(fromLonLat, zone),\n    inverse: makeTransformFunction(toLonLat, zone),\n  };\n}\n","/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport {warn} from './console.js';\nimport {equals, getWorldsAway} from './coordinate.js';\nimport {applyTransform, getWidth} from './extent.js';\nimport {clamp, modulo} from './math.js';\nimport Projection from './proj/Projection.js';\nimport {METERS_PER_UNIT} from './proj/Units.js';\nimport {\n  PROJECTIONS as EPSG3857_PROJECTIONS,\n  fromEPSG4326,\n  toEPSG4326,\n} from './proj/epsg3857.js';\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\nimport {\n  add as addProj,\n  clear as clearProj,\n  get as getProj,\n} from './proj/projections.js';\nimport {\n  add as addTransformFunc,\n  clear as clearTransformFuncs,\n  get as getTransformFunc,\n} from './proj/transforms.js';\nimport {\n  makeProjection as makeUTMProjection,\n  makeTransforms as makeUTMTransforms,\n} from './proj/utm.js';\nimport {getDistance} from './sphere.js';\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * @typedef {Object} Transforms\n * @property {TransformFunction} forward The forward transform (from geographic).\n * @property {TransformFunction} inverse The inverse transform (to geographic).\n */\n\n/**\n * @type {Array<function(Projection): Transforms|null>}\n */\nconst transformFactories = [makeUTMTransforms];\n\n/**\n * @type {Array<function(string): Projection|null>}\n */\nconst projectionFactories = [makeUTMProjection];\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @callback TransformFunction\n * @param {Array<number>} input\n * @param {Array<number>} [output]\n * @param {number} [dimension]\n * @param {number} [stride]\n * @return {Array<number>}\n *\n * @api\n */\n\nexport {METERS_PER_UNIT};\n\nexport {Projection};\n\nlet showCoordinateWarning = true;\n\n/**\n * @param {boolean} [disable] Disable console info about `useGeographic()`\n */\nexport function disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, output) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    output = output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, output) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    input = output;\n  }\n  return input;\n}\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n  if (!(typeof projectionLike === 'string')) {\n    return projectionLike;\n  }\n  const projection = getProj(projectionLike);\n  if (projection) {\n    return projection;\n  }\n  for (const makeProjection of projectionFactories) {\n    const projection = makeProjection(projectionLike);\n    if (projection) {\n      return projection;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution =\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(\n        projection,\n        get('EPSG:4326'),\n      );\n      if (!toEPSG4326 && projUnits !== 'degrees') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2,\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      const metersPerUnit = units\n        ? METERS_PER_UNIT[units]\n        : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(\n  projections1,\n  projections2,\n  forwardTransform,\n  inverseTransform,\n) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  }\n  if (typeof projection === 'string') {\n    return get(projection);\n  }\n  return /** @type {Projection} */ (projection);\n}\n\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimensions that should be transformed.\n     * @param {number} [stride] Stride.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension, stride) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      stride = stride ?? dimension;\n      output = output !== undefined ? output : new Array(length);\n      for (let i = 0; i < length; i += stride) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n        for (let j = 0, jj = stride; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n      return output;\n    }\n  );\n}\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(\n    sourceProj,\n    destProj,\n    createTransformFromCoordinateTransform(forward),\n  );\n  addTransformFunc(\n    destProj,\n    sourceProj,\n    createTransformFromCoordinateTransform(inverse),\n  );\n}\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(\n    coordinate,\n    'EPSG:4326',\n    projection !== undefined ? projection : 'EPSG:3857',\n  );\n}\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, projection) {\n  const lonLat = transform(\n    coordinate,\n    projection !== undefined ? projection : 'EPSG:3857',\n    'EPSG:4326',\n  );\n  const lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  }\n  const transformFunc = getTransformFromProjections(projection1, projection2);\n  return transformFunc === cloneTransform && equalUnits;\n}\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} source Source Projection object.\n * @param {Projection} destination Destination Projection\n *     object.\n * @return {TransformFunction|null} Transform function.\n */\nexport function getTransformFromProjections(source, destination) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\n  if (transformFunc) {\n    return transformFunc;\n  }\n\n  /**\n   * @type {Transforms|null}\n   */\n  let sourceTransforms = null;\n\n  /**\n   * @type {Transforms|null}\n   */\n  let destinationTransforms = null;\n\n  // lazily add projections if we have supported transforms\n  for (const makeTransforms of transformFactories) {\n    if (!sourceTransforms) {\n      sourceTransforms = makeTransforms(source);\n    }\n    if (!destinationTransforms) {\n      destinationTransforms = makeTransforms(destination);\n    }\n  }\n\n  if (!sourceTransforms && !destinationTransforms) {\n    return null;\n  }\n\n  const intermediateCode = 'EPSG:4326';\n  if (!destinationTransforms) {\n    const toDestination = getTransformFunc(intermediateCode, destinationCode);\n    if (toDestination) {\n      transformFunc = composeTransformFuncs(\n        sourceTransforms.inverse,\n        toDestination,\n      );\n    }\n  } else if (!sourceTransforms) {\n    const fromSource = getTransformFunc(sourceCode, intermediateCode);\n    if (fromSource) {\n      transformFunc = composeTransformFuncs(\n        fromSource,\n        destinationTransforms.forward,\n      );\n    }\n  } else {\n    transformFunc = composeTransformFuncs(\n      sourceTransforms.inverse,\n      destinationTransforms.forward,\n    );\n  }\n\n  if (transformFunc) {\n    addProjection(source);\n    addProjection(destination);\n    addTransformFunc(source, destination, transformFunc);\n  }\n\n  return transformFunc;\n}\n\n/**\n * @param {TransformFunction} t1 The first transform function.\n * @param {TransformFunction} t2 The second transform function.\n * @return {TransformFunction} The composed transform function.\n */\nfunction composeTransformFuncs(t1, t2) {\n  return function (input, output, dimensions, stride) {\n    output = t1(input, output, dimensions, stride);\n    return t2(output, output, dimensions, stride);\n  };\n}\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original). If there\n * is no available transform between the two projection, the function will throw\n * an error.\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  if (!transformFunc) {\n    const sourceCode = get(source).getCode();\n    const destinationCode = get(destination).getCode();\n    throw new Error(\n      `No transform available between ${sourceCode} and ${destinationCode}`,\n    );\n  }\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, stops);\n}\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(\n  point,\n  sourceProjection,\n  destinationProjection,\n) {\n  const transformFunc = getTransformFromProjections(\n    sourceProjection,\n    destinationProjection,\n  );\n  return transformFunc(point);\n}\n\n/**\n * @type {Projection|null}\n */\nlet userProjection = null;\n\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n\n/**\n * Clear the user projection if set.\n * @api\n */\nexport function clearUserProjection() {\n  userProjection = null;\n}\n\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nexport function getUserProjection() {\n  return userProjection;\n}\n\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @api\n */\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (\n      showCoordinateWarning &&\n      !equals(coordinate, [0, 0]) &&\n      coordinate[0] >= -180 &&\n      coordinate[0] <= 180 &&\n      coordinate[1] >= -90 &&\n      coordinate[1] <= 90\n    ) {\n      showCoordinateWarning = false;\n      warn(\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.',\n      );\n    }\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nexport function toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\n  return sourceMetersPerUnit && userMetersPerUnit\n    ? (resolution * sourceMetersPerUnit) / userMetersPerUnit\n    : resolution;\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nexport function fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const destMetersPerUnit = get(destProjection).getMetersPerUnit();\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\n  return destMetersPerUnit && userMetersPerUnit\n    ? (resolution * userMetersPerUnit) / destMetersPerUnit\n    : resolution;\n}\n\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destination).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destination).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(\n    EPSG4326_PROJECTIONS,\n    EPSG3857_PROJECTIONS,\n    fromEPSG4326,\n    toEPSG4326,\n  );\n}\n\naddCommon();\n","/**\n * @module ol/proj/Projection\n */\nimport {METERS_PER_UNIT} from './Units.js';\n\n/**\n * The function is called with a `number` view resolution and a\n * {@link module:ol/coordinate~Coordinate} as arguments, and returns the `number` resolution\n * in projection units at the passed coordinate.\n * @typedef {function(number, import(\"../coordinate.js\").Coordinate):number} GetPointResolution\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {GetPointResolution} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution} function will be used.\n */\n\n/**\n * @classdesc\n * In most cases, you should not need to create instances of this class.\n * Instead, where projection information is required, you can use a string\n * projection code or identifier (e.g. `EPSG:4326`) instead of a projection\n * instance.\n *\n * The library includes support for transforming coordinates between the following\n * projections:\n *\n *  WGS 84 / Geographic - Using codes `EPSG:4326`, `CRS:84`, `urn:ogc:def:crs:EPSG:6.6:4326`,\n *    `urn:ogc:def:crs:OGC:1.3:CRS84`, `urn:ogc:def:crs:OGC:2:84`, `http://www.opengis.net/gml/srs/epsg.xml#4326`,\n *    or `urn:x-ogc:def:crs:EPSG:4326`\n *  WGS 84 / Spherical Mercator - Using codes `EPSG:3857`, `EPSG:102100`, `EPSG:102113`, `EPSG:900913`,\n *    `urn:ogc:def:crs:EPSG:6.18:3:3857`, or `http://www.opengis.net/gml/srs/epsg.xml#3857`\n *  WGS 84 / UTM zones - Using codes `EPSG:32601` through `EPSG:32660` for northern zones\n *    and `EPSG:32701` through `EPSG:32760` for southern zones. Note that the built-in UTM transforms\n *    are lower accuracy (with errors on the order of 0.1 m) than those that you might get in a\n *    library like [proj4js](https://github.com/proj4js/proj4js).\n *\n * For additional projection support, or to use higher accuracy transforms than the built-in ones, you can use\n * the [proj4js](https://github.com/proj4js/proj4js) library. With `proj4js`, after adding any new projection\n * definitions, call the {@link module:ol/proj/proj4.register} function.\n *\n * You can use the {@link module:ol/proj.get} function to retrieve a projection instance\n * for one of the registered projections.\n *\n * @api\n */\nclass Projection {\n  /**\n   * @param {Options} options Projection options.\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n\n    /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import(\"./Units.js\").Units}\n     */\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\n\n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n\n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.worldExtent_ =\n      options.worldExtent !== undefined ? options.worldExtent : null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ =\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n\n    /**\n     * @private\n     * @type {GetPointResolution|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.defaultTileGrid_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n\n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  canWrapX() {\n    return this.canWrapX_;\n  }\n\n  /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */\n  getCode() {\n    return this.code_;\n  }\n\n  /**\n   * Get the validity extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the units of this projection.\n   * @return {import(\"./Units.js\").Units} Units.\n   * @api\n   */\n  getUnits() {\n    return this.units_;\n  }\n\n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  getMetersPerUnit() {\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n  }\n\n  /**\n   * Get the world extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getWorldExtent() {\n    return this.worldExtent_;\n  }\n\n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  getAxisOrientation() {\n    return this.axisOrientation_;\n  }\n\n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  isGlobal() {\n    return this.global_;\n  }\n\n  /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */\n  setGlobal(global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  }\n\n  /**\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n   */\n  getDefaultTileGrid() {\n    return this.defaultTileGrid_;\n  }\n\n  /**\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n   */\n  setDefaultTileGrid(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  }\n\n  /**\n   * Set the validity extent for this projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  setExtent(extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  }\n\n  /**\n   * Set the world extent for this projection.\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  setWorldExtent(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  }\n\n  /**\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n   * for this projection.\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n   * @api\n   */\n  setGetPointResolution(func) {\n    this.getPointResolutionFunc_ = func;\n  }\n\n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {GetPointResolution|undefined} The custom point\n   * resolution function (if set).\n   */\n  getPointResolutionFunc() {\n    return this.getPointResolutionFunc_;\n  }\n}\n\nexport default Projection;\n","/**\n * @module ol/proj/Units\n */\n\n/**\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\n * Projection units.\n */\n\n/**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */\nconst unitByCode = {\n  '9001': 'm',\n  '9002': 'ft',\n  '9003': 'us-ft',\n  '9101': 'radians',\n  '9102': 'degrees',\n};\n\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */\nexport function fromCode(code) {\n  return unitByCode[code];\n}\n\n/**\n * @typedef {Object} MetersPerUnitLookup\n * @property {number} radians Radians\n * @property {number} degrees Degrees\n * @property {number} ft  Feet\n * @property {number} m Meters\n * @property {number} us-ft US feet\n */\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {MetersPerUnitLookup}\n * @api\n */\nexport const METERS_PER_UNIT = {\n  // use the radius of the Normal sphere\n  'radians': 6370997 / (2 * Math.PI),\n  'degrees': (2 * Math.PI * 6370997) / 360,\n  'ft': 0.3048,\n  'm': 1,\n  'us-ft': 1200 / 3937,\n};\n","/**\n * @module ol/proj/projections\n */\n\n/**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */\nlet cache = {};\n\n/**\n * Clear the projections cache.\n */\nexport function clear() {\n  cache = {};\n}\n\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default|null} The projection (if cached).\n */\nexport function get(code) {\n  return (\n    cache[code] ||\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\n    null\n  );\n}\n\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */\nexport function add(code, projection) {\n  cache[code] = projection;\n}\n","/**\n * @module ol/proj/transforms\n */\nimport {isEmpty} from '../obj.js';\n\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nlet transforms = {};\n\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  const transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|null} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    return transforms[sourceCode][destinationCode];\n  }\n  return null;\n}\n","/**\n * @module ol/sphere\n */\nimport {toDegrees, toRadians} from './math.js';\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport const DEFAULT_RADIUS = 6371008.8;\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lat2 = toRadians(c2[1]);\n  const deltaLatBy2 = (lat2 - lat1) / 2;\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  const a =\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n    Math.sin(deltaLonBy2) *\n      Math.sin(deltaLonBy2) *\n      Math.cos(lat1) *\n      Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  let length = 0;\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let length = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint': {\n      break;\n    }\n    case 'LineString':\n    case 'LinearRing': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      length = getLengthInternal(coordinates, radius);\n      break;\n    }\n    case 'MultiLineString':\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += getLengthInternal(coordinates[i], radius);\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += getLengthInternal(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += getLength(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n}\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area +=\n      toRadians(x2 - x1) *\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return (area * radius * radius) / 2.0;\n}\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let area = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'LinearRing': {\n      break;\n    }\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(getAreaInternal(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(getAreaInternal(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += getArea(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n}\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lon1 = toRadians(c1[0]);\n  const dByR = distance / radius;\n  const lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing),\n  );\n  const lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat),\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n","/**\n * @module ol/string\n */\n\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number} [precision] Precision of the output string (i.e. number of decimal places)\n * @return {string} Formatted string\n */\nexport function padNumber(number, width, precision) {\n  const numberString =\n    precision !== undefined ? number.toFixed(precision) : '' + number;\n  let decimal = numberString.indexOf('.');\n  decimal = decimal === -1 ? numberString.length : decimal;\n  return decimal > width\n    ? numberString\n    : new Array(1 + width - decimal).join('0') + numberString;\n}\n\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @return {number} Value\n */\nexport function compareVersions(v1, v2) {\n  const s1 = ('' + v1).split('.');\n  const s2 = ('' + v2).split('.');\n\n  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {\n    const n1 = parseInt(s1[i] || '0', 10);\n    const n2 = parseInt(s2[i] || '0', 10);\n\n    if (n1 > n2) {\n      return 1;\n    }\n    if (n2 > n1) {\n      return -1;\n    }\n  }\n\n  return 0;\n}\n"],"names":["warn","args","console","add","coordinate","delta","closestOnCircle","circle","r","center","x0","y0","x1","y1","dx","dy","d","Math","closestOnSegment","segment","x","y","start","end","x2","y2","along","createStringXY","fractionDigits","toStringXY","degreesToStringHDMS","hemispheres","degrees","normalizedDegrees","decimals","deg","min","sec","hdms","format","template","equals","coordinate1","coordinate2","i","rotate","angle","cosAngle","sinAngle","scale","squaredDistance","coord1","coord2","distance","squaredDistanceToSegment","toStringHDMS","wrapX","projection","worldWidth","worldsAway","getWorldsAway","sourceExtentWidth","projectionExtent","clamp","value","max","squaredSegmentDistance","t","solveLinearSystem","mat","n","maxRow","maxEl","absValue","tmp","j","coef","k","Array","l","m","toDegrees","angleInRadians","toRadians","angleInDegrees","modulo","a","b","lerp","toFixed","factor","round","floor","ceil","wrap","range","HALF_SIZE","EXTENT","WORLD_EXTENT","MAX_SAFE_Y","RADIUS","EPSG3857Projection","Projection","code","resolution","point","PROJECTIONS","fromEPSG4326","input","output","dimension","stride","length","undefined","METERS_PER_UNIT","EPSG4326Projection","axisOrientation","E_P2","E","SQRT_E","_E","_E2","_E3","_E4","_E5","M1","M2","M3","M4","P2","P3","P4","P5","toLonLat","easting","northing","zone","mu","R","pRad","pSin","pSin2","pCos","pTan","pTan2","pTan4","c","c2","d2","d3","d4","d5","latitude","longitude","zoneToCentralLongitude","fromLonLat","latRad","latSin","latCos","latTan","latTan2","latTan4","lonRad","centralLon","centralLonRad","a2","a3","a4","a5","K0","epsgRegExes","zoneFromCode","epsgId","re","match","parseInt","number","north","makeTransformFunction","transformer","coord","transformFactories","projectionFactories","showCoordinateWarning","disableCoordinateWarning","disable","cloneTransform","ii","identityTransform","addProjection","addProjections","projections","get","projectionLike","makeProjection","getPointResolution","units","pointResolution","getter","metersPerUnit","projUnits","toEPSG4326","getTransformFromProjections","vertices","width","addEquivalentProjections","source","destination","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","clearAllProjections","createProjection","defaultCode","createTransformFromCoordinateTransform","coordTransform","pointLength","jj","addCoordinateTransforms","forward","inverse","sourceProj","destProj","lonLat","lon","equivalent","equalUnits","transformFunc","sourceCode","destinationCode","sourceTransforms","destinationTransforms","makeTransforms","intermediateCode","composeTransformFuncs","fromSource","toDestination","t1","t2","dimensions","getTransform","Error","transformExtent","extent","stops","transformWithProjections","sourceProjection","destinationProjection","userProjection","setUserProjection","clearUserProjection","getUserProjection","useGeographic","toUserCoordinate","fromUserCoordinate","destProjection","toUserExtent","fromUserExtent","toUserResolution","sourceMetersPerUnit","userMetersPerUnit","fromUserResolution","destMetersPerUnit","createSafeCoordinateTransform","transform","transformed","sourceExtent","addCommon","options","global","tileGrid","worldExtent","func","unitByCode","fromCode","cache","clear","transforms","transformFn","getArea","geometry","coordinates","coords","radius","DEFAULT_RADIUS","type","area","getAreaInternal","geometries","getLength","getLengthInternal","getDistance","c1","lat1","lat2","deltaLatBy2","deltaLonBy2","len","offset","bearing","lon1","dByR","lat","padNumber","precision","numberString","decimal","compareVersions","v1","v2","s1","s2","n1","n2"],"mappings":"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"}