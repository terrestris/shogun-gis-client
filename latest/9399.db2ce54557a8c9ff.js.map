{"version":3,"file":"9399.db2ce54557a8c9ff.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/@terrestris/ol-util/dist/MeasureUtil/MeasureUtil.js","webpack://@terrestris/shogun-gis-client/./node_modules/@terrestris/react-util/dist/Context/MapContext/MapContext.js","webpack://@terrestris/shogun-gis-client/./node_modules/@terrestris/react-util/dist/Hooks/useMap/useMap.js","webpack://@terrestris/shogun-gis-client/./node_modules/@terrestris/react-util/dist/Hooks/useOlLayer/useOlLayer.js"],"sourcesContent":["import _isNil from 'lodash/isNil';\nimport OlGeomCircle from 'ol/geom/Circle';\nimport { getArea, getLength } from 'ol/sphere';\n/**\n * This class provides some static methods which might be helpful when working\n * with measurements.\n *\n * @class MeasureUtil\n */\nclass MeasureUtil {\n    /**\n     * Get the length of a OlGeomLineString.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                    \t  is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     * @param {number} decimalPrecision Set the decimal precision on length value\n     *                    \t  for non-geodesic map (default value 6)\n     *\n     * @return {number} The length of line in meters.\n     */\n    static getLength(line, map, geodesic = true, radius = 6371008.8, decimalPrecision = 6) {\n        const decimalHelper = Math.pow(10, decimalPrecision);\n        if (geodesic) {\n            const opts = {\n                projection: map.getView().getProjection().getCode(),\n                radius\n            };\n            return getLength(line, opts);\n        }\n        else {\n            return Math.round(line.getLength() * decimalHelper) / decimalHelper;\n        }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     *\n     * @return {string} The formatted length of the line (units: km, m or mm).\n     */\n    static formatLength(line, map, decimalPlacesInToolTips, geodesic = true) {\n        const decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n        const length = MeasureUtil.getLength(line, map, geodesic);\n        let output;\n        if (length > 1000) {\n            output = (Math.round(length / 1000 * decimalHelper) /\n                decimalHelper) + ' km';\n        }\n        else if (length > 1) {\n            output = (Math.round(length * decimalHelper) / decimalHelper) +\n                ' m';\n        }\n        else {\n            output = (Math.round(length * 1000 * decimalHelper) / decimalHelper) +\n                ' mm';\n        }\n        return output;\n    }\n    /**\n     * Get the area of an OlGeomPolygon.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The area of the polygon in square meter.\n     */\n    static getArea(polygon, map, geodesic = true, radius = 6371008.8) {\n        if (geodesic) {\n            const opts = {\n                projection: map.getView().getProjection().getCode(),\n                radius\n            };\n            return getArea(polygon, opts);\n        }\n        else {\n            return polygon.getArea();\n        }\n    }\n    /**\n     * Get the estimated area of an OlGeomCircle.\n     *\n     * @param {OlGeomCircle} circleGeom The drawn circle.\n     * @param {OlMap} map An OlMap.\n     *\n     * @return {number} The area of the circle in square meter.\n     */\n    static getAreaOfCircle(circleGeom, map) {\n        if (_isNil(map.getView().getProjection())) {\n            return NaN;\n        }\n        const sphericalUnits = ['radians', 'degrees'];\n        const projectionUnits = map.getView().getProjection().getUnits();\n        const useSpherical = sphericalUnits.includes(projectionUnits);\n        if (useSpherical) {\n            // see https://math.stackexchange.com/questions/1832110/area-of-a-circle-on-sphere\n            // the radius of the earth - Clarke 1866 authalic Sphere\n            const earthRadius = 6371008.8;\n            const radius = circleGeom.getRadius();\n            let area = 2.0 * Math.PI * Math.pow(earthRadius, 2);\n            area *= (1 - Math.cos(radius / earthRadius));\n            return area;\n        }\n        else {\n            return Math.PI * Math.pow(circleGeom.getRadius(), 2);\n        }\n    }\n    /**\n     * Format area output for the tooltip.\n     *\n     * @param {OlGeomPolygon | OlGeomCircle} geom The drawn geometry (circle or polygon).\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     * @param {boolean} geodesic Is the measurement geodesic.\n     *\n     * @return {string} The formatted area of the polygon.\n     */\n    static formatArea(geom, map, decimalPlacesInToolTips, geodesic = true) {\n        const decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n        let area;\n        if (geom instanceof OlGeomCircle) {\n            area = MeasureUtil.getAreaOfCircle(geom, map);\n        }\n        else {\n            area = MeasureUtil.getArea(geom, map, geodesic);\n        }\n        let output;\n        if (area > 10000) {\n            output = (Math.round(area / 1000000 * decimalHelper) /\n                decimalHelper) + ' km<sup>2</sup>';\n        }\n        else if (area > 0.01) {\n            output = (Math.round(area * decimalHelper) / decimalHelper) +\n                ' m<sup>2</sup>';\n        }\n        else {\n            output = (Math.round(area * 1000000 * decimalHelper) / decimalHelper) +\n                ' mm<sup>2</sup>';\n        }\n        return output;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * -180° and 180°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from -180° to 180°.\n     */\n    static angle(start, end) {\n        const dx = start[0] - end[0];\n        const dy = start[1] - end[1];\n        // range (-PI, PI]\n        let theta = Math.atan2(dy, dx);\n        // rads to degs, range (-180, 180]\n        theta *= 180 / Math.PI;\n        return theta;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * 0° and 360°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from 0° and 360°.\n     */\n    static angle360(start, end) {\n        // range (-180, 180]\n        let theta = MeasureUtil.angle(start, end);\n        if (theta < 0) {\n            // range [0, 360)\n            theta = 360 + theta;\n        }\n        return theta;\n    }\n    /**\n     * Given an angle between 0° and 360° this angle returns the exact opposite\n     * of the angle, e.g. for 90° you'll get back 270°. This effectively turns\n     * the direction of the angle from counter-clockwise to clockwise.\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise.\n     *\n     * @return {number} The clockwise angle.\n     */\n    static makeClockwise(angle360) {\n        return 360 - angle360;\n    }\n    /**\n     * This methods adds an offset of 90° to an counter-clockwise increasing\n     * angle of a line so that the origin (0°) lies at the top (in the north).\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise, with\n     *     0° degrees being in the east.\n     *\n     * @return {number} The adjusted angle, with 0° being in the north.\n     */\n    static makeZeroDegreesAtNorth(angle360) {\n        let corrected = angle360 + 90;\n        if (corrected > 360) {\n            corrected = corrected - 360;\n        }\n        return corrected;\n    }\n    /**\n     * Returns the angle of the passed linestring in degrees, with 'N' being the\n     * 0°-line and the angle increases in clockwise direction.\n     *\n     * @param {OlGeomLineString} line The linestring to get the\n     *   angle from. As this line is coming from our internal draw\n     *   interaction, we know that it will only consist of two points.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     *\n     * @return {string} The formatted angle of the line.\n     */\n    static formatAngle(line, decimalPlacesInToolTips = 2) {\n        const coords = line.getCoordinates();\n        const numCoords = coords.length;\n        if (numCoords < 2) {\n            return '';\n        }\n        const lastPoint = coords[numCoords - 1];\n        const prevPoint = coords[numCoords - 2];\n        let angle = MeasureUtil.angle360(prevPoint, lastPoint);\n        angle = MeasureUtil.makeZeroDegreesAtNorth(angle);\n        angle = MeasureUtil.makeClockwise(angle);\n        return `${angle.toFixed(decimalPlacesInToolTips)}°`;\n    }\n}\nexport default MeasureUtil;\n//# sourceMappingURL=MeasureUtil.js.map","import React from 'react';\nconst MapContext = React.createContext(null);\nexport default MapContext;\n//# sourceMappingURL=MapContext.js.map","import { useContext } from 'react';\nimport MapContext from '../../Context/MapContext/MapContext';\nexport const useMap = () => {\n    return useContext(MapContext);\n};\nexport default useMap;\n//# sourceMappingURL=useMap.js.map","import { useEffect, useState } from 'react';\nimport { isNil } from 'lodash';\nimport useMap from '../useMap/useMap';\n/**\n * This hook adds a layer to the map and removes/updates it if the dependency array changes.\n * It accepts an optional visible parameter that toggles the visible state of the layer. If it is undefined the\n * visible state will not get changed.\n * @param constructor returns a layer to be added to the map, will be called again, if the layer needs\n * to be updated\n * @param dependencies\n * @param visible\n */\nexport const useOlLayer = (constructor, dependencies, visible) => {\n    const map = useMap();\n    const [layer, setLayer] = useState();\n    useEffect(() => {\n        if (!map) {\n            return undefined;\n        }\n        const newLayer = constructor();\n        if (!newLayer) {\n            return undefined;\n        }\n        map.addLayer(newLayer);\n        setLayer(newLayer);\n        return () => {\n            map.removeLayer(newLayer);\n            setLayer(undefined);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [map, ...dependencies]);\n    useEffect(() => {\n        if (!layer || isNil(visible)) {\n            return;\n        }\n        layer.setVisible(visible);\n    }, [layer, visible]);\n    return layer;\n};\nexport default useOlLayer;\n//# sourceMappingURL=useOlLayer.js.map"],"names":["Math","NaN","a","n","u","s"],"mappings":"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"}