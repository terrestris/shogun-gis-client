{"version":3,"file":"5778.1034aba72f8154aa.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/asserts.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/contains.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/segments.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/WMTS.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/common.js"],"sourcesContent":["/**\n * @module ol/asserts\n */\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {string} errorMessage Error message.\n */\nexport function assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {import('../../extent.js').Extent} [coordinatesExtent] Coordinates extent\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n  coordinatesExtent,\n) {\n  coordinatesExtent =\n    coordinatesExtent ??\n    extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (\n    (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) ||\n    (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3])\n  ) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/tilegrid/WMTS\n */\n\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from './TileGrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes,\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(\n  matrixSet,\n  extent,\n  matrixLimits,\n) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().startsWith('ne');\n\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (!elt[identifierPropName].includes(':')) {\n          return (\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n            elt_ml[matrixIdsPropName]\n          );\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution =\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([\n          elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0],\n        ]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight],\n      );\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes,\n  });\n}\n","/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport const DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport const DEFAULT_TILE_SIZE = 256;\n"],"names":["Error","e"],"mappings":"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"}