{"version":3,"file":"5778.1034aba72f8154aa.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/asserts.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/contains.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/segments.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/WMTS.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/common.js"],"sourcesContent":["/**\n * @module ol/asserts\n */\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {string} errorMessage Error message.\n */\nexport function assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {import('../../extent.js').Extent} [coordinatesExtent] Coordinates extent\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n  coordinatesExtent,\n) {\n  coordinatesExtent =\n    coordinatesExtent ??\n    extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (\n    (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) ||\n    (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3])\n  ) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/tilegrid/WMTS\n */\n\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from './TileGrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes,\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(\n  matrixSet,\n  extent,\n  matrixLimits,\n) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().startsWith('ne');\n\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (!elt[identifierPropName].includes(':')) {\n          return (\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n            elt_ml[matrixIdsPropName]\n          );\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution =\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([\n          elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0],\n        ]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight],\n      );\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes,\n  });\n}\n","/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport const DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport const DEFAULT_TILE_SIZE = 256;\n"],"names":["assert","assertion","errorMessage","Error","linearRingContainsExtent","flatCoordinates","offset","end","stride","extent","coordinate","linearRingContainsXY","x","y","wn","x1","y1","x2","y2","linearRingsContainsXY","ends","i","ii","linearRingssContainsXY","endss","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","forEach","callback","ret","WMTSTileGrid","options","z","createFromCapabilitiesMatrixSet","matrixSet","matrixLimits","resolutions","matrixIds","origins","tileSizes","sizes","undefined","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","code","projection","metersPerUnit","switchOriginXY","a","b","elt","matrixAvailable","elt_ml","resolution","tileWidth","tileHeight","DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE"],"mappings":"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"}