{"version":3,"file":"1850.3e4231e12cec9b8d.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/asserts.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/contains.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/segments.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/math.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/common.js"],"sourcesContent":["/**\n * @module ol/asserts\n */\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {string} errorMessage Error message.\n */\nexport function assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {import('../../extent.js').Extent} [coordinatesExtent] Coordinates extent\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n  coordinatesExtent,\n) {\n  coordinatesExtent =\n    coordinatesExtent ??\n    extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (\n    (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) ||\n    (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3])\n  ) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/math\n */\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\nexport function clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n  return squaredDistance(x, y, x1, y1);\n}\n\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredDistance(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>|null} The resulting vector.\n */\nexport function solveLinearSystem(mat) {\n  const n = mat.length;\n\n  for (let i = 0; i < n; i++) {\n    // Find max in the i-th column (ignoring i - 1 first rows)\n    let maxRow = i;\n    let maxEl = Math.abs(mat[i][i]);\n    for (let r = i + 1; r < n; r++) {\n      const absValue = Math.abs(mat[r][i]);\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r;\n      }\n    }\n\n    if (maxEl === 0) {\n      return null; // matrix is singular\n    }\n\n    // Swap max row with i-th (current) row\n    const tmp = mat[maxRow];\n    mat[maxRow] = mat[i];\n    mat[i] = tmp;\n\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n    for (let j = i + 1; j < n; j++) {\n      const coef = -mat[j][i] / mat[i][i];\n      for (let k = i; k < n + 1; k++) {\n        if (i == k) {\n          mat[j][k] = 0;\n        } else {\n          mat[j][k] += coef * mat[i][k];\n        }\n      }\n    }\n  }\n\n  // Solve Ax=b for upper triangular matrix A (mat)\n  const x = new Array(n);\n  for (let l = n - 1; l >= 0; l--) {\n    x[l] = mat[l][n] / mat[l][l];\n    for (let m = l - 1; m >= 0; m--) {\n      mat[m][n] -= mat[m][l] * x[l];\n    }\n  }\n  return x;\n}\n\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\nexport function toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\nexport function toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\nexport function modulo(a, b) {\n  const r = a % b;\n  return r * b < 0 ? r + b : r;\n}\n\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\nexport function lerp(a, b, x) {\n  return a + x * (b - a);\n}\n\n/**\n * Returns a number with a limited number of decimal digits.\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The input number with a limited number of decimal digits.\n */\nexport function toFixed(n, decimals) {\n  const factor = Math.pow(10, decimals);\n  return Math.round(n * factor) / factor;\n}\n\n/**\n * Rounds a number to the nearest integer value considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The nearest integer.\n */\nexport function round(n, decimals) {\n  return Math.round(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next smaller integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next smaller integer.\n */\nexport function floor(n, decimals) {\n  return Math.floor(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next bigger integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next bigger integer.\n */\nexport function ceil(n, decimals) {\n  return Math.ceil(toFixed(n, decimals));\n}\n\n/**\n * Wraps a number between some minimum and maximum values.\n * @param {number} n The number to wrap.\n * @param {number} min The minimum of the range (inclusive).\n * @param {number} max The maximum of the range (exclusive).\n * @return {number} The wrapped number.\n */\nexport function wrap(n, min, max) {\n  if (n >= min && n < max) {\n    return n;\n  }\n  const range = max - min;\n  return ((((n - min) % range) + range) % range) + min;\n}\n","/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport const DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport const DEFAULT_TILE_SIZE = 256;\n"],"names":["assert","assertion","errorMessage","Error","linearRingContainsExtent","flatCoordinates","offset","end","stride","extent","coordinate","linearRingContainsXY","x","y","wn","x1","y1","x2","y2","linearRingsContainsXY","ends","i","ii","linearRingssContainsXY","endss","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","forEach","callback","ret","clamp","value","min","max","Math","squaredSegmentDistance","dx","dy","t","squaredDistance","solveLinearSystem","mat","n","maxRow","maxEl","r","absValue","tmp","j","coef","k","Array","l","m","toDegrees","angleInRadians","toRadians","angleInDegrees","modulo","a","b","lerp","toFixed","decimals","factor","round","floor","ceil","wrap","range","DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE"],"mappings":"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"}