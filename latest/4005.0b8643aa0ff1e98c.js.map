{"version":3,"file":"4005.0b8643aa0ff1e98c.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/closest.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/contains.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/deflate.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/inflate.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/segments.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/simplify.js"],"sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint,\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t,\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1],\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1,\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/deflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(\n  flatCoordinates,\n  offset,\n  coordinates,\n  stride,\n) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    const coordinate = coordinates[i];\n    for (let j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatess,\n  stride,\n  ends,\n) {\n  ends = ends ? ends : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\n    const end = deflateCoordinates(\n      flatCoordinates,\n      offset,\n      coordinatess[j],\n      stride,\n    );\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatesss,\n  stride,\n  endss,\n) {\n  endss = endss ? endss : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    const ends = deflateCoordinatesArray(\n      flatCoordinates,\n      offset,\n      coordinatesss[j],\n      stride,\n      endss[i],\n    );\n    if (ends.length === 0) {\n      ends[0] = offset;\n    }\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n}\n","/**\n * @module ol/geom/flat/inflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  coordinates,\n) {\n  coordinates = coordinates !== undefined ? coordinates : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  coordinatess,\n) {\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\n  let i = 0;\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\n    const end = ends[j];\n    coordinatess[i++] = inflateCoordinates(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      coordinatess[i],\n    );\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  coordinatesss,\n) {\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\n  let i = 0;\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\n    const ends = endss[j];\n    coordinatesss[i++] =\n      ends.length === 1 && ends[0] === offset\n        ? []\n        : inflateCoordinatesArray(\n            flatCoordinates,\n            offset,\n            ends,\n            stride,\n            coordinatesss[i],\n          );\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {import('../../extent.js').Extent} [coordinatesExtent] Coordinates extent\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n  coordinatesExtent,\n) {\n  coordinatesExtent =\n    coordinatesExtent ??\n    extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (\n    (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) ||\n    (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3])\n  ) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates,\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0,\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n"],"names":["assignClosest","flatCoordinates","offset1","offset2","stride","x","y","closestPoint","offset","x1","y1","dx","dy","t","i","maxSquaredDelta","end","max","x2","y2","squaredDelta","arrayMaxSquaredDelta","ends","ii","multiArrayMaxSquaredDelta","endss","assignClosestPoint","maxDelta","isRing","minSquaredDistance","tmpPoint","squaredDistance","NaN","index","Math","assignClosestArrayPoint","assignClosestMultiArrayPoint","linearRingContainsExtent","extent","coordinate","linearRingContainsXY","wn","linearRingsContainsXY","linearRingssContainsXY","deflateCoordinate","deflateCoordinates","coordinates","j","deflateCoordinatesArray","coordinatess","jj","deflateMultiCoordinatesArray","coordinatesss","inflateCoordinates","undefined","inflateCoordinatesArray","inflateMultiCoordinatesArray","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","forEach","callback","ret","douglasPeucker","squaredTolerance","simplifiedFlatCoordinates","simplifiedOffset","n","markers","Array","stack","last","first","maxSquaredDistance","douglasPeuckerArray","simplifiedEnds","snap","value","tolerance","quantizeArray","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeMultiArray","simplifiedEndss"],"mappings":"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"}