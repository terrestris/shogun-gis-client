{"version":3,"file":"4005.0b8643aa0ff1e98c.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/closest.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/contains.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/deflate.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/inflate.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/segments.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/simplify.js"],"sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint,\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t,\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1],\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1,\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://web.archive.org/web/20210504233957/http://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/deflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(\n  flatCoordinates,\n  offset,\n  coordinates,\n  stride,\n) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    const coordinate = coordinates[i];\n    for (let j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatess,\n  stride,\n  ends,\n) {\n  ends = ends ? ends : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\n    const end = deflateCoordinates(\n      flatCoordinates,\n      offset,\n      coordinatess[j],\n      stride,\n    );\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatesss,\n  stride,\n  endss,\n) {\n  endss = endss ? endss : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    const ends = deflateCoordinatesArray(\n      flatCoordinates,\n      offset,\n      coordinatesss[j],\n      stride,\n      endss[i],\n    );\n    if (ends.length === 0) {\n      ends[0] = offset;\n    }\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n}\n","/**\n * @module ol/geom/flat/inflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  coordinates,\n) {\n  coordinates = coordinates !== undefined ? coordinates : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  coordinatess,\n) {\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\n  let i = 0;\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\n    const end = ends[j];\n    coordinatess[i++] = inflateCoordinates(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      coordinatess[i],\n    );\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  coordinatesss,\n) {\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\n  let i = 0;\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\n    const ends = endss[j];\n    coordinatesss[i++] =\n      ends.length === 1 && ends[0] === offset\n        ? []\n        : inflateCoordinatesArray(\n            flatCoordinates,\n            offset,\n            ends,\n            stride,\n            coordinatesss[i],\n          );\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {import('../../extent.js').Extent} [coordinatesExtent] Coordinates extent\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n  coordinatesExtent,\n) {\n  coordinatesExtent =\n    coordinatesExtent ??\n    extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (\n    (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) ||\n    (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3])\n  ) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n\n/**\n * Calculate the intersection point of two line segments.\n * Reference: https://stackoverflow.com/a/72474223/2389327\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} segment1 The first line segment as an array of two points.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} segment2 The second line segment as an array of two points.\n * @return {import(\"../../coordinate.js\").Coordinate|undefined} The intersection point or `undefined` if no intersection.\n */\nexport function getIntersectionPoint(segment1, segment2) {\n  const [a, b] = segment1;\n  const [c, d] = segment2;\n  const t =\n    ((a[0] - c[0]) * (c[1] - d[1]) - (a[1] - c[1]) * (c[0] - d[0])) /\n    ((a[0] - b[0]) * (c[1] - d[1]) - (a[1] - b[1]) * (c[0] - d[0]));\n  const u =\n    ((a[0] - c[0]) * (a[1] - b[1]) - (a[1] - c[1]) * (a[0] - b[0])) /\n    ((a[0] - b[0]) * (c[1] - d[1]) - (a[1] - b[1]) * (c[0] - d[0]));\n\n  // Check if lines actually intersect\n  if (0 <= t && t <= 1 && 0 <= u && u <= 1) {\n    return [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1])];\n  }\n  return undefined;\n}\n","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates,\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0,\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n"],"names":["e","NaN","Math","c","l","i","f","Array","d"],"mappings":"+TAiBA,SAAS,EACP,CAAe,CACf,CAAO,CACP,CAAO,CACP,CAAM,CACN,CAAC,CACD,CAAC,CACD,CAAY,EAEZ,IAII,EAJE,EAAK,CAAe,CAAC,EAAQ,CAC7B,EAAK,CAAe,CAAC,EAAU,EAAE,CACjC,EAAK,CAAe,CAAC,EAAQ,CAAG,EAChC,EAAK,CAAe,CAAC,EAAU,EAAE,CAAG,EAE1C,GAAI,AAAO,IAAP,GAAY,AAAO,IAAP,EACd,EAAS,MACJ,CACL,IAAM,EAAI,AAAC,CAAC,GAAI,CAAC,EAAK,EAAK,AAAC,GAAI,CAAC,EAAK,CAAC,EAAM,GAAK,EAAK,EAAK,CAAC,EAC7D,GAAI,EAAI,EACN,EAAS,OACJ,GAAI,EAAI,EAAG,CAChB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,EAAE,EAC5B,CAAY,CAAC,EAAE,CAAG,SAChB,CAAe,CAAC,EAAU,EAAE,CAC5B,CAAe,CAAC,EAAU,EAAE,CAC5B,EAGJ,GAAa,MAAM,CAAG,EACtB,MACF,MACE,EAAS,CAEb,CACA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,EAAE,EAC5B,CAAY,CAAC,EAAE,CAAG,CAAe,CAAC,EAAS,EAAE,AAE/C,GAAa,MAAM,CAAG,CACxB,CAYO,SAAS,EAAgB,CAAe,CAAE,CAAM,CAAEA,CAAG,CAAE,CAAM,CAAE,CAAG,EACvE,IAAI,EAAK,CAAe,CAAC,EAAO,CAC5B,EAAK,CAAe,CAAC,EAAS,EAAE,CACpC,IAAK,GAAU,EAAQ,EAASA,EAAK,GAAU,EAAQ,CACrD,IAAM,EAAK,CAAe,CAAC,EAAO,CAC5B,EAAK,CAAe,CAAC,EAAS,EAAE,CAChC,EAAe,SAAU,EAAI,EAAI,EAAI,EACvC,GAAe,GACjB,GAAM,CAAW,EAEnB,EAAK,EACL,EAAK,CACP,CACA,OAAO,CACT,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAI,CACJ,CAAM,CACN,CAAG,EAEH,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC7C,IAAM,EAAMA,CAAI,CAAC,EAAE,CACnB,EAAM,EAAgB,EAAiB,EAAQ,EAAK,EAAQ,GAC5D,EAAS,CACX,CACA,OAAO,CACT,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAK,CACL,CAAM,CACN,CAAG,EAEH,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAM,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC9C,IAAM,EAAOA,CAAK,CAAC,EAAE,CACrB,EAAM,EAAqB,EAAiB,EAAQ,EAAM,EAAQ,GAClE,EAAS,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,AAChC,CACA,OAAO,CACT,CAgBO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAG,CACH,CAAM,CACN,CAAQ,CACR,CAAM,CACN,CAAC,CACD,CAAC,CACD,CAAY,CACZ,CAAkB,CAClB,CAAQ,MAKJ,EAAG,EAHP,GAAI,GAAUA,EACZ,OAAO,EAGT,GAAI,AAAa,IAAb,EAAgB,CAQlB,GAAI,AANJ,GAAkB,SAChB,EACA,EACA,CAAe,CAAC,EAAO,CACvB,CAAe,CAAC,EAAS,EAAE,CAC7B,EACsB,EAAoB,CACxC,IAAK,EAAI,EAAG,EAAI,EAAQ,EAAE,EACxB,CAAY,CAAC,EAAE,CAAG,CAAe,CAAC,EAAS,EAAE,CAG/C,OADA,EAAa,MAAM,CAAG,EACf,CACT,CACA,OAAO,CACT,CACA,EAAW,GAAsB,CAACC,IAAKA,IAAI,CAC3C,IAAI,EAAQ,EAAS,EACrB,KAAO,EAAQD,GAWb,GAVA,EACE,EACA,EAAQ,EACR,EACA,EACA,EACA,EACA,GAGE,AADJ,GAAkB,SAAU,EAAG,EAAG,CAAQ,CAAC,EAAE,CAAE,CAAQ,CAAC,EAAE,GACpC,EAAoB,CAExC,IAAK,EAAI,EADT,EAAqB,EACT,EAAI,EAAQ,EAAE,EACxB,CAAY,CAAC,EAAE,CAAG,CAAQ,CAAC,EAAE,AAE/B,GAAa,MAAM,CAAG,EACtB,GAAS,CACX,MAWE,GACE,EACAE,KAAK,GAAG,CACN,AAAEA,CAAAA,KAAK,IAAI,CAAC,GAAmBA,KAAK,IAAI,CAAC,EAAkB,EACzD,EACA,EACF,GAIR,GAAI,IAEF,EACE,EACAF,EAAM,EACN,EACA,EACA,EACA,EACA,GAGE,AADJ,GAAkB,SAAU,EAAG,EAAG,CAAQ,CAAC,EAAE,CAAE,CAAQ,CAAC,EAAE,GACpC,GAAoB,CAExC,IAAK,EAAI,EADT,EAAqB,EACT,EAAI,EAAQ,EAAE,EACxB,CAAY,CAAC,EAAE,CAAG,CAAQ,CAAC,EAAE,AAE/B,GAAa,MAAM,CAAG,CACxB,CAEF,OAAO,CACT,CAgBO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAI,CACJ,CAAM,CACN,CAAQ,CACR,CAAM,CACN,CAAC,CACD,CAAC,CACDG,CAAY,CACZ,CAAkB,CAClB,CAAQ,EAER,EAAW,GAAsB,CAACF,IAAKA,IAAI,CAC3C,IAAK,IAAI,EAAI,EAAG,EAAKD,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC7C,IAAM,EAAMA,CAAI,CAAC,EAAE,CACnB,EAAqB,EACnB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAG,EACA,EACA,GAEF,EAAS,CACX,CACA,OAAO,CACT,CAgBO,SAAS,EACd,CAAe,CACf,CAAM,CACNH,CAAK,CACL,CAAM,CACN,CAAQ,CACR,CAAM,CACN,CAAC,CACD,CAAC,CACD,CAAY,CACZ,CAAkB,CAClB,CAAQ,EAER,EAAW,GAAsB,CAACC,IAAKA,IAAI,CAC3C,IAAK,IAAI,EAAI,EAAG,EAAKD,EAAM,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC9C,IAAM,EAAOA,CAAK,CAAC,EAAE,CACrB,EAAqB,EACnB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEF,EAAS,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,AAChC,CACA,OAAO,CACT,C,gJClUO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAG,CACH,CAAM,CACN,CAAM,EAmBN,MAAO,CAjBS,oBACd,EAKA,SAAU,CAAU,EAClB,MAAO,CAAC,EACN,EACA,EACAA,EACA,EACA,CAAU,CAAC,EAAE,CACb,CAAU,CAAC,EAAE,CAEjB,EAGJ,CAWO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAG,CACH,CAAM,CACN,CAAC,CACD,CAAC,EASD,IAAI,EAAK,EACL,EAAK,CAAe,CAACA,EAAM,EAAO,CAClC,EAAK,CAAe,CAACA,EAAM,EAAS,EAAE,CAC1C,KAAO,EAASA,EAAK,GAAU,EAAQ,CACrC,IAAM,EAAK,CAAe,CAAC,EAAO,CAC5B,EAAK,CAAe,CAAC,EAAS,EAAE,AAClC,IAAM,EACJ,EAAK,GAAK,AAAC,GAAK,CAAC,EAAM,GAAI,CAAC,EAAK,AAAC,GAAI,CAAC,EAAM,GAAK,CAAC,EAAK,GAC1D,IAEO,GAAM,GAAK,AAAC,GAAK,CAAC,EAAM,GAAI,CAAC,EAAK,AAAC,GAAI,CAAC,EAAM,GAAK,CAAC,EAAK,GAClE,IAEF,EAAK,EACL,EAAK,CACP,CACA,OAAO,AAAO,IAAP,CACT,CAWO,SAASI,EACd,CAAe,CACf,CAAM,CACNJ,CAAI,CACJ,CAAM,CACN,CAAC,CACD,CAAC,EAED,GAAoB,IAAhBA,EAAK,MAAM,EAGX,CAAC,EAAqB,EAAiB,EAAQA,CAAI,CAAC,EAAE,CAAE,EAAQ,EAAG,GAFrE,MAAO,GAKT,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAC1C,GACE,EAAqB,EAAiBA,CAAI,CAAC,EAAI,EAAE,CAAEA,CAAI,CAAC,EAAE,CAAE,EAAQ,EAAG,GAEvE,MAAO,GAGX,MAAO,EACT,CAWO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAK,CACL,CAAM,CACN,CAAC,CACD,CAAC,EAED,GAAIA,AAAiB,IAAjBA,EAAM,MAAM,CACd,MAAO,GAET,IAAK,IAAI,EAAI,EAAGK,EAAKL,EAAM,MAAM,CAAE,EAAIK,EAAI,EAAE,EAAG,CAC9C,IAAM,EAAOL,CAAK,CAAC,EAAE,CACrB,GAAII,EAAsB,EAAiB,EAAQ,EAAM,EAAQ,EAAG,GAClE,MAAO,GAET,EAAS,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,AAChC,CACA,MAAO,EACT,C,wBCrIO,SAAS,EAAkB,CAAe,CAAE,CAAM,CAAE,CAAU,CAAE,CAAM,EAC3E,IAAK,IAAI,EAAI,EAAG,EAAK,EAAW,MAAM,CAAE,EAAI,EAAI,EAAE,EAChD,CAAe,CAAC,IAAS,CAAG,CAAU,CAAC,EAAE,CAE3C,OAAO,CACT,CASO,SAAS,EACd,CAAe,CACf,CAAM,CACN,CAAW,CACX,CAAM,EAEN,IAAK,IAAI,EAAI,EAAG,EAAK,EAAY,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CACpD,IAAM,EAAa,CAAW,CAAC,EAAE,CACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,EAAE,EAC5B,CAAe,CAAC,IAAS,CAAG,CAAU,CAAC,EAAE,AAE7C,CACA,OAAO,CACT,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACN,CAAY,CACZ,CAAM,CACN,CAAI,EAEJ,EAAO,GAAc,EAAE,CACvB,IAAI,EAAI,EACR,IAAK,IAAI,EAAI,EAAG,EAAK,EAAa,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CACrD,IAAM,EAAM,EACV,EACA,EACA,CAAY,CAAC,EAAE,CACf,EAEF,EAAI,CAAC,IAAI,CAAG,EACZ,EAAS,CACX,CAEA,OADA,EAAK,MAAM,CAAG,EACP,CACT,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACN,CAAa,CACb,CAAM,CACN,CAAK,EAEL,EAAQ,GAAgB,EAAE,CAC1B,IAAI,EAAI,EACR,IAAK,IAAI,EAAI,EAAG,EAAK,EAAc,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CACtD,IAAM,EAAO,EACX,EACA,EACA,CAAa,CAAC,EAAE,CAChB,EACA,CAAK,CAAC,EAAE,CAEN,AAAgB,KAAhB,EAAK,MAAM,EACb,EAAI,CAAC,EAAE,CAAG,CAAK,EAEjB,CAAK,CAAC,IAAI,CAAG,EACb,EAAS,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,AAChC,CAEA,OADA,EAAM,MAAM,CAAG,EACR,CACT,C,gIC5FO,SAAS,EACd,CAAe,CACf,CAAM,CACNJ,CAAG,CACH,CAAM,CACN,CAAW,EAEX,EAAc,AAAgB,SAAhB,EAA4B,EAAc,EAAE,CAC1D,IAAI,EAAI,EACR,IAAK,IAAI,EAAI,EAAQ,EAAIA,EAAK,GAAK,EACjC,CAAW,CAAC,IAAI,CAAG,EAAgB,KAAK,CAAC,EAAG,EAAI,GAGlD,OADA,EAAY,MAAM,CAAG,EACd,CACT,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAI,CACJ,CAAM,CACN,CAAY,EAEZ,EAAe,AAAiB,SAAjB,EAA6B,EAAe,EAAE,CAC7D,IAAI,EAAI,EACR,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC7C,IAAM,EAAMA,CAAI,CAAC,EAAE,AACnB,EAAY,CAAC,IAAI,CAAG,EAClB,EACA,EACA,EACA,EACA,CAAY,CAAC,EAAE,EAEjB,EAAS,CACX,CAEA,OADA,EAAa,MAAM,CAAG,EACf,CACT,CAWO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAK,CACL,CAAM,CACN,CAAa,EAEb,EAAgB,AAAkB,SAAlB,EAA8B,EAAgB,EAAE,CAChE,IAAI,EAAI,EACR,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAM,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC9C,IAAM,EAAOA,CAAK,CAAC,EAAE,AACrB,EAAa,CAAC,IAAI,CAChB,AAAgB,IAAhB,EAAK,MAAM,EAAU,CAAI,CAAC,EAAE,GAAK,EAC7B,EAAE,CACF,EACE,EACA,EACA,EACA,EACA,CAAa,CAAC,EAAE,EAExB,EAAS,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,AAChC,CAEA,OADA,EAAc,MAAM,CAAG,EAChB,CACT,C,8QCzEO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAG,CACH,CAAM,CACN,CAAM,CACN,CAAiB,SAKjB,AAHA,EACE,GACA,4BAAsB,oBAAe,EAAiB,EAAQA,EAAK,IACjE,CAAC,iBAAW,EAAQ,KAIrB,CAAiB,CAAC,EAAE,EAAI,CAAM,CAAC,EAAE,EAAI,CAAiB,CAAC,EAAE,EAAI,CAAM,CAAC,EAAE,EACtE,CAAiB,CAAC,EAAE,EAAI,CAAM,CAAC,EAAE,EAAI,CAAiB,CAAC,EAAE,EAAI,CAAM,CAAC,EAAE,EAIlE,GAAAM,EAAA,GACL,EACA,EACAN,EACA,EAOA,SAAU,CAAM,CAAE,CAAM,EACtB,MAAO,wBAAkB,EAAQ,EAAQ,EAC3C,GAEJ,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAI,CACJ,CAAM,CACN,CAAM,EAEN,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC7C,GACE,EAAqB,EAAiB,EAAQA,CAAI,CAAC,EAAE,CAAE,EAAQ,GAE/D,MAAO,GAET,EAASA,CAAI,CAAC,EAAE,AAClB,CACA,MAAO,EACT,CAUO,SAASK,EACd,CAAe,CACf,CAAM,CACNL,CAAG,CACH,CAAM,CACN,CAAM,WAEF,EAAqB,EAAiB,EAAQA,EAAK,EAAQ,IAI7D,SACE,EACA,EACAA,EACA,EACA,CAAM,CAAC,EAAE,CACT,CAAM,CAAC,EAAE,GAMX,SACE,EACA,EACAA,EACA,EACA,CAAM,CAAC,EAAE,CACT,CAAM,CAAC,EAAE,GAMX,SACE,EACA,EACAA,EACA,EACA,CAAM,CAAC,EAAE,CACT,CAAM,CAAC,EAAE,GAMX,SACE,EACA,EACAA,EACA,EACA,CAAM,CAAC,EAAE,CACT,CAAM,CAAC,EAAE,EAMf,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAI,CACJ,CAAM,CACN,CAAM,EAEN,GAAI,CAACK,EAAqB,EAAiB,EAAQL,CAAI,CAAC,EAAE,CAAE,EAAQ,GAClE,MAAO,GAET,GAAIA,AAAgB,IAAhBA,EAAK,MAAM,CACb,MAAO,GAET,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAC1C,GACE,SACE,EACAA,CAAI,CAAC,EAAI,EAAE,CACXA,CAAI,CAAC,EAAE,CACP,EACA,IAIA,CAAC,EACC,EACAA,CAAI,CAAC,EAAI,EAAE,CACXA,CAAI,CAAC,EAAE,CACP,EACA,GAGF,MAAO,GAIb,MAAO,EACT,CAUO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAK,CACL,CAAM,CACN,CAAM,EAEN,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAM,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC9C,IAAM,EAAOA,CAAK,CAAC,EAAE,CACrB,GACE,EAA0B,EAAiB,EAAQ,EAAM,EAAQ,GAEjE,MAAO,GAET,EAAS,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,AAChC,CACA,MAAO,EACT,C,wDChNO,SAAS,EAAQ,CAAe,CAAE,CAAM,CAAEA,CAAG,CAAE,CAAM,CAAE,CAAQ,EACpE,IAAI,EAEJ,IADA,GAAU,EACH,EAASA,EAAK,GAAU,EAK7B,GAJA,EAAM,EACJ,EAAgB,KAAK,CAAC,EAAS,EAAQ,GACvC,EAAgB,KAAK,CAAC,EAAQ,EAAS,IAGvC,OAAO,EAGX,MAAO,EACT,C,wKC4DO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAG,CACH,CAAM,CACN,CAAgB,CAChB,CAAyB,CACzB,CAAgB,EAEhB,IAAM,EAAI,AAACA,CAAAA,EAAM,CAAK,EAAK,EAC3B,GAAI,EAAI,EAAG,CACT,KAAO,EAASA,EAAK,GAAU,EAC7B,CAAyB,CAAC,IAAmB,CAAG,CAAe,CAAC,EAAO,CACvE,CAAyB,CAAC,IAAmB,CAC3C,CAAe,CAAC,EAAS,EAAE,CAE/B,OAAO,CACT,CAEA,IAAM,EAAU,AAAIO,MAAM,EAC1B,EAAO,CAAC,EAAE,CAAG,EACb,CAAO,CAAC,EAAI,EAAE,CAAG,EAEjB,IAAM,EAAQ,CAAC,EAAQP,EAAM,EAAO,CAChC,EAAQ,EACZ,KAAO,EAAM,MAAM,CAAG,GAAG,CACvB,IAAM,EAAO,EAAM,GAAG,GAChB,EAAQ,EAAM,GAAG,GACnB,EAAqB,EACnB,EAAK,CAAe,CAAC,EAAM,CAC3B,EAAK,CAAe,CAAC,EAAQ,EAAE,CAC/B,EAAK,CAAe,CAAC,EAAK,CAC1B,EAAK,CAAe,CAAC,EAAO,EAAE,CACpC,IAAK,IAAI,EAAI,EAAQ,EAAQ,EAAI,EAAM,GAAK,EAAQ,CAClD,IAAM,EAAI,CAAe,CAAC,EAAE,CACtB,EAAI,CAAe,CAAC,EAAI,EAAE,CAC1B,EAAkB,SAAuB,EAAG,EAAG,EAAI,EAAI,EAAI,GAC7D,EAAkB,IACpB,EAAQ,EACR,EAAqB,EAEzB,CACI,EAAqB,IACvB,CAAO,CAAC,AAAC,GAAQ,CAAK,EAAK,EAAO,CAAG,EACjC,EAAQ,EAAS,GACnB,EAAM,IAAI,CAAC,EAAO,GAEhB,EAAQ,EAAS,GACnB,EAAM,IAAI,CAAC,EAAO,GAGxB,CACA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAG,EAAE,EACnB,CAAO,CAAC,EAAE,GACZ,CAAyB,CAAC,IAAmB,CAC3C,CAAe,CAAC,EAAS,EAAI,EAAO,CACtC,CAAyB,CAAC,IAAmB,CAC3C,CAAe,CAAC,EAAS,EAAI,EAAS,EAAE,EAG9C,OAAO,CACT,CAcO,SAAS,EACd,CAAe,CACf,CAAM,CACNA,CAAI,CACJ,CAAM,CACN,CAAgB,CAChB,CAAyB,CACzB,CAAgB,CAChB,CAAc,EAEd,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC7C,IAAM,EAAMA,CAAI,CAAC,EAAE,CACnB,EAAmB,EACjB,EACA,EACA,EACA,EACA,EACA,EACA,GAEF,EAAe,IAAI,CAAC,GACpB,EAAS,CACX,CACA,OAAO,CACT,CAwGO,SAAS,EAAK,CAAK,CAAE,CAAS,EACnC,OAAO,EAAYE,KAAK,KAAK,CAAC,EAAQ,EACxC,CAkHO,SAAS,EACd,CAAe,CACf,CAAM,CACNF,CAAI,CACJ,CAAM,CACN,CAAS,CACT,CAAyB,CACzB,CAAgB,CAChB,CAAc,EAEd,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAK,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC7C,IAAM,EAAMA,CAAI,CAAC,EAAE,CACnB,EAAmB,AAzGhB,SACL,CAAe,CACf,CAAM,CACNA,CAAG,CACH,CAAM,CACN,CAAS,CACT,CAAyB,CACzB,CAAgB,MAeZ,EAAI,EAZR,GAAI,GAAUA,EACZ,OAAO,EAGT,IAAI,EAAK,EAAK,CAAe,CAAC,EAAO,CAAE,GACnC,EAAK,EAAK,CAAe,CAAC,EAAS,EAAE,CAAE,GAC3C,GAAU,EAEV,CAAyB,CAAC,IAAmB,CAAG,EAChD,CAAyB,CAAC,IAAmB,CAAG,EAIhD,GAIE,GAHA,EAAK,EAAK,CAAe,CAAC,EAAO,CAAE,GACnC,EAAK,EAAK,CAAe,CAAC,EAAS,EAAE,CAAE,GAEnC,AADJ,IAAU,CAAK,GACDA,EAOZ,OAFA,CAAyB,CAAC,IAAmB,CAAG,EAChD,CAAyB,CAAC,IAAmB,CAAG,EACzC,QAEF,GAAM,GAAM,GAAM,EAAI,CAC/B,KAAO,EAASA,GAAK,CAEnB,IAAM,EAAK,EAAK,CAAe,CAAC,EAAO,CAAE,GACnC,EAAK,EAAK,CAAe,CAAC,EAAS,EAAE,CAAE,GAG7C,GAFA,GAAU,EAEN,GAAM,GAAM,GAAM,EACpB,SAGF,IAAM,EAAM,EAAK,EACXQ,EAAM,EAAK,EAEX,EAAM,EAAK,EACX,EAAM,EAAK,EAIjB,GACE,EAAM,GAAOA,EAAM,GAClB,CAAC,EAAM,GAAK,EAAM,GAAQ,GAAO,GAAQ,EAAM,GAAK,EAAM,CAAG,GAC7D,CAACA,EAAM,GAAK,EAAMA,GAAQA,GAAO,GAAQA,EAAM,GAAK,EAAMA,CAAG,EAC9D,CAEA,EAAK,EACL,EAAK,EACL,QACF,CAIA,CAAyB,CAAC,IAAmB,CAAG,EAChD,CAAyB,CAAC,IAAmB,CAAG,EAChD,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,CACP,CAIA,OAFA,CAAyB,CAAC,IAAmB,CAAG,EAChD,CAAyB,CAAC,IAAmB,CAAG,EACzC,CACT,EA2BM,EACA,EACA,EACA,EACA,EACA,EACA,GAEF,EAAe,IAAI,CAAC,GACpB,EAAS,CACX,CACA,OAAO,CACT,CAcO,SAAS,EACd,CAAe,CACf,CAAM,CACNR,CAAK,CACL,CAAM,CACN,CAAS,CACT,CAAyB,CACzB,CAAgB,CAChB,CAAe,EAEf,IAAK,IAAI,EAAI,EAAG,EAAKA,EAAM,MAAM,CAAE,EAAI,EAAI,EAAE,EAAG,CAC9C,IAAM,EAAOA,CAAK,CAAC,EAAE,CAEf,EAAiB,EAAE,CACzB,EAAmB,EACjB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEF,EAAgB,IAAI,CAAC,GACrB,EAAS,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,AAChC,CACA,OAAO,CACT,C"}