{"version":3,"file":"8901.81e2e8f7babbc7e1.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/GML2.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/GMLBase.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/XMLFeature.js"],"sourcesContent":["/**\n * @module ol/format/GML2\n */\nimport {createOrUpdate} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  createElementNS,\n  getAllTextContent,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {writeStringTextNode} from './xsd.js';\n\n/**\n * @const\n * @type {string}\n */\nconst schemaLocation =\n  GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @api\n */\nclass GML2 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(\n      this.readFeaturesInternal,\n    );\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatCoordinates(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n      objectStack[0]\n    );\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    const coordsGroups = s.trim().split(/\\s+/);\n    const flatCoordinates = [];\n    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n      const coords = coordsGroups[i].split(/,+/);\n      const x = parseFloat(coords[0]);\n      const y = parseFloat(coords[1]);\n      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.startsWith('en')) {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readBox(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.BOX_PARSERS_,\n      node,\n      objectStack,\n      this,\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[1][3],\n      flatCoordinates[1][4],\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  innerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  outerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml', nodeName);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null && value !== undefined) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this,\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context,\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context,\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @return {Element} coordinates node.\n   * @private\n   */\n  createCoordinatesNode_(namespaceURI) {\n    const coordinates = createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n\n    return coordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LineString.js\").default|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCoordinates_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      const point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this,\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs',\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    const axisOrientation = srsName\n      ? getProjection(srsName).getAxisOrientation()\n      : 'enu';\n    let coords = axisOrientation.startsWith('en')\n      ? point[0] + ',' + point[1]\n      : point[1] + ',' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ',' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    const point = geometry.getCoordinates();\n    const coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates, coord);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this,\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      'http://www.opengis.net/gml',\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName],\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML2.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML2.prototype.writeMultiCurveOrLineString,\n    ),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n    'curveMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n    'polygonMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\nexport default GML2;\n","/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport {extend} from '../array.js';\nimport Geometry from '../geom/Geometry.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  getAllTextContent,\n  getAttributeNS,\n  makeArrayPusher,\n  makeReplacer,\n  parseNode,\n  pushParseAndPop,\n} from '../xml.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport XMLFeature from './XMLFeature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal),\n    };\n\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop(\n        [],\n        this.FEATURE_COLLECTION_PARSERS,\n        node,\n        objectStack,\n        this,\n      );\n    } else if (\n      localName == 'featureMembers' ||\n      localName == 'featureMember' ||\n      localName == 'member'\n    ) {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        (featureType = []), (featureNS = {});\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */ (node.childNodes[i]);\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType)\n        ? featureType\n        : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':')\n            ? featureTypes[i].split(':')[0]\n            : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n              localName == 'featureMembers'\n                ? makeArrayPusher(this.readFeatureElement, this)\n                : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] =\n      node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const extent = /** @type {import(\"../extent.js\").Extent} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return geometry\n      ? transformGeometryWithOptions(geometry, false, context)\n      : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (\n        n.childNodes.length === 0 ||\n        (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))\n      ) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value =\n            localName === 'boundedBy'\n              ? this.readExtentElement(n, objectStack)\n              : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      const len = n.attributes.length;\n      if (len > 0 && !(value instanceof Geometry)) {\n        value = {_content_: value};\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    }\n    const feature = new Feature(values);\n    if (geometryName) {\n      feature.setGeometryName(geometryName);\n    }\n    const fid =\n      node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n    if (fid) {\n      feature.setId(fid);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop(\n      [],\n      this.MULTIPOINT_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTILINESTRING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTIPOLYGON_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (ring) {\n      return ring;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [\n      this.getReadOptions(node, options ? options : {}),\n    ]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @override\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS,\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @override\n   */\n  readProjectionFromNode(node) {\n    return getProjection(\n      this.srsName\n        ? this.srsName\n        : node.firstElementChild.getAttribute('srsName'),\n    );\n  }\n}\n\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n  },\n};\n\nexport default GMLBase;\n","/**\n * @module ol/format/XMLFeature\n */\nimport {extend} from '../array.js';\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readFeatureFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readFeaturesFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options),\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    }\n    if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        options,\n      );\n    }\n    return this.readGeometryFromNode(/** @type {Element} */ (source), options);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    }\n    return this.readProjectionFromNode(/** @type {Element} */ (source));\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @override\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n"],"names":["parseFloat","s","Array","Object","l","i","g","r","n","Node"],"mappings":"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"}