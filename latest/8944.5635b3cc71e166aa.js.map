{"version":3,"file":"8944.5635b3cc71e166aa.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/render.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/util.js"],"sourcesContent":["/**\n * @module ol/render\n */\nimport {DEVICE_PIXEL_RATIO} from './has.js';\nimport {getTransformFromProjections, getUserProjection} from './proj.js';\nimport CanvasImmediateRenderer from './render/canvas/Immediate.js';\nimport {getSquaredTolerance} from './renderer/vector.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply as multiplyTransform,\n  scale as scaleTransform,\n} from './transform.js';\n\n/**\n * @typedef {Object} State\n * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.\n * @property {import(\"./Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"./geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} pixelRatio Pixel ratio used by the layer renderer.\n * @property {number} resolution Resolution that the render batch was created and optimized for.\n * This is not the view's resolution that is being rendered.\n * @property {number} rotation Rotation of the rendered layer in radians.\n */\n\n/**\n * A function to be used when sorting features before rendering.\n * It takes two instances of {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and returns a `{number}`.\n *\n * @typedef {function(import(\"./Feature.js\").FeatureLike, import(\"./Feature.js\").FeatureLike):number} OrderFunction\n */\n\n/**\n * @typedef {Object} ToContextOptions\n * @property {import(\"./size.js\").Size} [size] Desired size of the canvas in css\n * pixels. When provided, both canvas and css size will be set according to the\n * `pixelRatio`. If not provided, the current canvas and css sizes will not be\n * altered.\n * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas\n * pixel to css pixel ratio) for the canvas.\n */\n\n/**\n * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries\n * to the context's canvas.\n *\n * The units for geometry coordinates are css pixels relative to the top left\n * corner of the canvas element.\n * ```js\n * import {toContext} from 'ol/render.js';\n * import Fill from 'ol/style/Fill.js';\n * import Polygon from 'ol/geom/Polygon.js';\n *\n * const canvas = document.createElement('canvas');\n * const render = toContext(\n *     canvas.getContext('2d'),\n *     {size: [100, 100]}\n * );\n * render.setFillStrokeStyle(new Fill({ color: blue }));\n * render.drawPolygon(\n *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]])\n * );\n * ```\n *\n * @param {CanvasRenderingContext2D} context Canvas context.\n * @param {ToContextOptions} [options] Options.\n * @return {CanvasImmediateRenderer} Canvas Immediate.\n * @api\n */\nexport function toContext(context, options) {\n  const canvas = context.canvas;\n  options = options ? options : {};\n  const pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;\n  const size = options.size;\n  if (size) {\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n  }\n  const extent = [0, 0, canvas.width, canvas.height];\n  const transform = scaleTransform(createTransform(), pixelRatio, pixelRatio);\n  return new CanvasImmediateRenderer(context, pixelRatio, extent, transform, 0);\n}\n\n/**\n * Gets a vector context for drawing to the event's canvas.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @return {CanvasImmediateRenderer} Vector context.\n * @api\n */\nexport function getVectorContext(event) {\n  if (!(event.context instanceof CanvasRenderingContext2D)) {\n    throw new Error('Only works for render events from Canvas 2D layers');\n  }\n\n  // canvas may be at a different pixel ratio than frameState.pixelRatio\n  const a = event.inversePixelTransform[0];\n  const b = event.inversePixelTransform[1];\n  const canvasPixelRatio = Math.sqrt(a * a + b * b);\n  const frameState = event.frameState;\n  const transform = multiplyTransform(\n    event.inversePixelTransform.slice(),\n    frameState.coordinateToPixelTransform,\n  );\n  const squaredTolerance = getSquaredTolerance(\n    frameState.viewState.resolution,\n    canvasPixelRatio,\n  );\n  let userTransform;\n  const userProjection = getUserProjection();\n  if (userProjection) {\n    userTransform = getTransformFromProjections(\n      userProjection,\n      frameState.viewState.projection,\n    );\n  }\n\n  return new CanvasImmediateRenderer(\n    event.context,\n    canvasPixelRatio,\n    frameState.extent,\n    transform,\n    frameState.viewState.rotation,\n    squaredTolerance,\n    userTransform,\n  );\n}\n\n/**\n * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @param {import(\"./pixel.js\").Pixel} pixel CSS pixel relative to the top-left\n * corner of the map viewport.\n * @return {import(\"./pixel.js\").Pixel} Pixel on the event's canvas context.\n * @api\n */\nexport function getRenderPixel(event, pixel) {\n  return applyTransform(event.inversePixelTransform, pixel.slice(0));\n}\n","/**\n * @module ol/util\n */\n\n/**\n * @return {never} Any return.\n */\nexport function abstract() {\n  throw new Error('Unimplemented abstract method.');\n}\n\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nlet uidCounter_ = 0;\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nexport function getUid(obj) {\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport const VERSION = '10.4.0';\n"],"names":["toContext","context","options","canvas","pixelRatio","size","extent","transform","getVectorContext","event","userTransform","CanvasRenderingContext2D","Error","a","b","canvasPixelRatio","Math","frameState","squaredTolerance","userProjection","getRenderPixel","pixel","abstract","uidCounter_","getUid","obj","String","VERSION"],"mappings":"0UAsEO,SAASA,EAAUC,CAAO,CAAEC,CAAO,EACxC,IAAMC,EAASF,EAAQ,MAAM,CAEvBG,EAAaF,AADnBA,CAAAA,EAAUA,GAAoB,CAAC,GACJ,UAAU,EAAI,oBAAkB,CACrDG,EAAOH,EAAQ,IAAI,CACrBG,IACFF,EAAO,KAAK,CAAGE,CAAI,CAAC,EAAE,CAAGD,EACzBD,EAAO,MAAM,CAAGE,CAAI,CAAC,EAAE,CAAGD,EAC1BD,EAAO,KAAK,CAAC,KAAK,CAAGE,CAAI,CAAC,EAAE,CAAG,KAC/BF,EAAO,KAAK,CAAC,MAAM,CAAGE,CAAI,CAAC,EAAE,CAAG,MAElC,IAAMC,EAAS,CAAC,EAAG,EAAGH,EAAO,KAAK,CAAEA,EAAO,MAAM,CAAC,CAC5CI,EAAY,SAAe,WAAmBH,EAAYA,GAChE,OAAO,IAAI,GAAuB,CAACH,EAASG,EAAYE,EAAQC,EAAW,EAC7E,CAQO,SAASC,EAAiBC,CAAK,MAkBhCC,EAjBJ,GAAI,CAAED,CAAAA,EAAM,OAAO,YAAYE,wBAAuB,EACpD,MAAM,AAAIC,MAAM,sDAIlB,IAAMC,EAAIJ,EAAM,qBAAqB,CAAC,EAAE,CAClCK,EAAIL,EAAM,qBAAqB,CAAC,EAAE,CAClCM,EAAmBC,KAAK,IAAI,CAACH,EAAIA,EAAIC,EAAIA,GACzCG,EAAaR,EAAM,UAAU,CAC7BF,EAAY,SAChBE,EAAM,qBAAqB,CAAC,KAAK,GACjCQ,EAAW,0BAA0B,EAEjCC,EAAmB,SACvBD,EAAW,SAAS,CAAC,UAAU,CAC/BF,GAGII,EAAiB,0BAQvB,OAPIA,GACFT,CAAAA,EAAgB,kCACdS,EACAF,EAAW,SAAS,CAAC,UAAU,CACjC,EAGK,IAAI,GAAuB,CAChCR,EAAM,OAAO,CACbM,EACAE,EAAW,MAAM,CACjBV,EACAU,EAAW,SAAS,CAAC,QAAQ,CAC7BC,EACAR,EAEJ,CAUO,SAASU,EAAeX,CAAK,CAAEY,CAAK,EACzC,MAAO,SAAeZ,EAAM,qBAAqB,CAAEY,EAAM,KAAK,CAAC,GACjE,C,wBCrIO,SAASC,IACd,MAAM,AAAIV,MAAM,iCAClB,C,uGAOA,IAAIW,EAAc,EAWX,SAASC,EAAOC,CAAG,EACxB,OAAOA,EAAI,MAAM,EAAKA,CAAAA,EAAI,MAAM,CAAGC,OAAO,EAAEH,EAAW,CACzD,CAMO,IAAMI,EAAU,Q"}