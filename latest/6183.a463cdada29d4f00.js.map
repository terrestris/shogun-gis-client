{"version":3,"file":"6183.a463cdada29d4f00.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/Feature.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/GeometryCollection.js"],"sourcesContent":["/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  linearRingsAreOriented,\n  linearRingssAreOriented,\n  orientLinearRings,\n  orientLinearRingsArray,\n} from '../geom/flat/orient.js';\nimport {\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n  transformExtent,\n} from '../proj.js';\nimport RenderFeature from '../render/Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/***\n * @template {import('../Feature.js').FeatureLike} T\n * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass\n */\n\n/***\n * @template {import(\"../Feature.js\").FeatureClass} T\n * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {FeatureToFeatureClass<FeatureType>}\n     */\n    this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */ (\n      Feature\n    );\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection\n        ? getProjection(options.dataProjection)\n        : this.readProjection(source);\n      if (\n        options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === 'tile-pixels'\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n        featureClass: this.featureClass,\n      },\n      options,\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {Feature} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<Feature>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  let transformed = geometry;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    if (write) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    const fromProjection = write ? featureProjection : dataProjection;\n    const toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (\n    write &&\n    options &&\n    /** @type {WriteOptions} */ (options).decimals !== undefined\n  ) {\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\n\nconst GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon,\n};\n\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  const geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry\n      .map((geometry) => createRenderFeature({...object, geometry}))\n      .flat();\n  }\n\n  const geometryType =\n    geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n\n  const stride = geometry.layout.length;\n  return transformGeometryWithOptions(\n    new RenderFeature(\n      geometryType,\n      geometryType === 'Polygon'\n        ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride)\n        : geometry.flatCoordinates,\n      geometry.ends?.flat(),\n      stride,\n      object.properties || {},\n      object.id,\n    ).enableSimplifyTransformed(),\n    false,\n    options,\n  );\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    const geometries = object.map((geometry) =>\n      createGeometry(geometry, options),\n    );\n    return new GeometryCollection(geometries);\n  }\n  const Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(\n    new Geometry(object.flatCoordinates, object.layout || 'XY', object.ends),\n    false,\n    options,\n  );\n}\n","/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {\n  closestSquaredDistanceXY,\n  createOrUpdateEmpty,\n  extend,\n  getCenter,\n} from '../extent.js';\nimport Geometry from './Geometry.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\n *\n * @api\n */\nclass GeometryCollection extends Geometry {\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  constructor(geometries) {\n    super();\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = geometries;\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.changeEventsKeys_ = [];\n\n    this.listenGeometriesChange_();\n  }\n\n  /**\n   * @private\n   */\n  unlistenGeometriesChange_() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  listenGeometriesChange_() {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      this.changeEventsKeys_.push(\n        listen(geometries[i], EventType.CHANGE, this.changed, this),\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const geometryCollection = new GeometryCollection(\n      cloneGeometries(this.geometries_),\n    );\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n        x,\n        y,\n        closestPoint,\n        minSquaredDistance,\n      );\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    createOrUpdateEmpty(extent);\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  }\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  getGeometries() {\n    return cloneGeometries(this.geometries_);\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArray() {\n    return this.geometries_;\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArrayRecursive() {\n    /** @type {Array<Geometry>} */\n    let geometriesArray = [];\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(\n          /** @type {GeometryCollection} */ (\n            geometries[i]\n          ).getGeometriesArrayRecursive(),\n        );\n      } else {\n        geometriesArray.push(geometries[i]);\n      }\n    }\n    return geometriesArray;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {GeometryCollection} Simplified GeometryCollection.\n   * @override\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry =\n        geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(\n        simplifiedGeometries,\n      );\n      return simplifiedGeometryCollection;\n    }\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'GeometryCollection';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.geometries_.length === 0;\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   * @override\n   */\n  scale(sx, sy, anchor) {\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, sy, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  }\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   * @override\n   */\n  applyTransform(transformFn) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   * @override\n   */\n  translate(deltaX, deltaY) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenGeometriesChange_();\n    super.disposeInternal();\n  }\n}\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  return geometries.map((geometry) => geometry.clone());\n}\n\nexport default GeometryCollection;\n"],"names":["Array","Error","g","Math","i","e","Object"],"mappings":"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"}