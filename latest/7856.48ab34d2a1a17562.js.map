{"version":3,"file":"7856.48ab34d2a1a17562.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/Image.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/ImageState.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/ImageTile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/reproj/Tile.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/source/TileImage.js"],"sourcesContent":["/**\n * @module ol/Image\n */\nimport ImageState from './ImageState.js';\nimport EventType from './events/EventType.js';\nimport EventTarget from './events/Target.js';\nimport {listenOnce, unlistenByKey} from './events.js';\nimport {toPromise} from './functions.js';\nimport {CREATE_IMAGE_BITMAP, IMAGE_DECODE} from './has.js';\n\n/**\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\n * @api\n */\n\n/**\n * @typedef {Object} ImageObject\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * For images that cover any extent and resolution (static images), the loader function should not accept\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\n * correct `extent`, `resolution` and `pixelRatio`.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\n * @api\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\n */\n\nclass ImageWrapper extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\n   * resolution will be assumed.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default|Loader} stateOrLoader State.\n   */\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number|Array<number>|undefined}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n    this.state =\n      typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\n\n    /**\n     * @private\n     * @type {import('./DataTile.js').ImageLike|null}\n     */\n    this.image_ = null;\n\n    /**\n     * @protected\n     * @type {Loader|null}\n     */\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\n   * @return {import('./DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * @return {number} PixelRatio.\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\n   * @return {number|Array<number>} Resolution.\n   */\n  getResolution() {\n    return /** @type {number} */ (this.resolution);\n  }\n\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      if (this.loader) {\n        this.state = ImageState.LOADING;\n        this.changed();\n        const resolution = this.getResolution();\n        const requestResolution = Array.isArray(resolution)\n          ? resolution[0]\n          : resolution;\n        toPromise(() =>\n          this.loader(\n            this.getExtent(),\n            requestResolution,\n            this.getPixelRatio(),\n          ),\n        )\n          .then((image) => {\n            if ('image' in image) {\n              this.image_ = image.image;\n            }\n            if ('extent' in image) {\n              this.extent = image.extent;\n            }\n            if ('resolution' in image) {\n              this.resolution = image.resolution;\n            }\n            if ('pixelRatio' in image) {\n              this.pixelRatio_ = image.pixelRatio;\n            }\n            if (\n              image instanceof HTMLImageElement ||\n              (CREATE_IMAGE_BITMAP && image instanceof ImageBitmap) ||\n              image instanceof HTMLCanvasElement ||\n              image instanceof HTMLVideoElement\n            ) {\n              this.image_ = image;\n            }\n            this.state = ImageState.LOADED;\n          })\n          .catch((error) => {\n            this.state = ImageState.ERROR;\n            console.error(error); // eslint-disable-line no-console\n          })\n          .finally(() => this.changed());\n      }\n    }\n  }\n\n  /**\n   * @param {import('./DataTile.js').ImageLike} image The image.\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\n   * @param {number|Array<number>} resolution Resolution.\n   */\n  setResolution(resolution) {\n    this.resolution = resolution;\n  }\n}\n\n/**\n * @param {import('./DataTile.js').ImageLike} image Image element.\n * @param {function():any} loadHandler Load callback function.\n * @param {function():any} errorHandler Error callback function.\n * @return {function():void} Callback to stop listening.\n */\nexport function listenImage(image, loadHandler, errorHandler) {\n  const img = /** @type {HTMLImageElement} */ (image);\n  let listening = true;\n  let decoding = false;\n  let loaded = false;\n\n  const listenerKeys = [\n    listenOnce(img, EventType.LOAD, function () {\n      loaded = true;\n      if (!decoding) {\n        loadHandler();\n      }\n    }),\n  ];\n\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img\n      .decode()\n      .then(function () {\n        if (listening) {\n          loadHandler();\n        }\n      })\n      .catch(function (error) {\n        if (listening) {\n          if (loaded) {\n            loadHandler();\n          } else {\n            errorHandler();\n          }\n        }\n      });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\n\n/**\n * Loads an image.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n * @api\n */\nexport function load(image, src) {\n  return new Promise((resolve, reject) => {\n    function handleLoad() {\n      unlisten();\n      resolve(image);\n    }\n    function handleError() {\n      unlisten();\n      reject(new Error('Image load error'));\n    }\n    function unlisten() {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    }\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n    if (src) {\n      image.src = src;\n    }\n  });\n}\n\n/**\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n */\nexport function decodeFallback(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE\n    ? new Promise((resolve, reject) =>\n        image\n          .decode()\n          .then(() => resolve(image))\n          .catch((e) =>\n            image.complete && image.width ? resolve(image) : reject(e),\n          ),\n      )\n    : load(image);\n}\n\n/**\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\n * the loaded image otherwise.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\n * @api\n */\nexport function decode(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP\n    ? image\n        .decode()\n        .then(() => createImageBitmap(image))\n        .catch((e) => {\n          if (image.complete && image.width) {\n            return image;\n          }\n          throw e;\n        })\n    : decodeFallback(image);\n}\n\nexport default ImageWrapper;\n","/**\n * @module ol/ImageState\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3,\n  EMPTY: 4,\n};\n","/**\n * @module ol/ImageTile\n */\nimport {listenImage} from './Image.js';\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenImage_();\n    this.image_ = null;\n    super.disposeInternal();\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/reproj/Tile\n */\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {releaseCanvas} from '../dom.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\nimport {ERROR_THRESHOLD} from './common.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\n            const state = tile.getState();\n            if (\n              state == TileState.LOADED ||\n              state == TileState.ERROR ||\n              state == TileState.EMPTY\n            ) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/source/TileImage\n */\nimport ImageTile from '../ImageTile.js';\nimport TileState from '../TileState.js';\nimport EventType from '../events/EventType.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\nimport {getUid} from '../util.js';\nimport UrlTile from './UrlTile.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function\n * for the url option instead.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @deprecated Use the ol/source/ImageTile.js instead.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass TileImage extends UrlTile {\n  /**\n   * @param {!Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate:\n        options.interpolate !== undefined ? options.interpolate : true,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    this.tileClass =\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\n\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection = {};\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    if (\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return 0;\n    }\n    return this.getGutter();\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @override\n   */\n  getKey() {\n    let key = super.getKey();\n    if (!this.getInterpolate()) {\n      key += ':disable-interpolation';\n    }\n    return key;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection)) {\n      this.tileGridForProjection[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection[projKey];\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!ImageTile} Tile.\n   * @private\n   */\n  createTile_(z, x, y, pixelRatio, projection, key) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tileUrl = urlTileCoord\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n      : undefined;\n    const tile = new this.tileClass(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.crossOrigin,\n      this.tileLoadFunction,\n      this.tileOptions,\n    );\n    tile.key = key;\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!(ImageTile|ReprojTile)} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      return this.getTileInternal(\n        z,\n        x,\n        y,\n        pixelRatio,\n        sourceProjection || projection,\n      );\n    }\n    const tileCoord = [z, x, y];\n    const key = this.getKey();\n    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n    const targetTileGrid = this.getTileGridForProjection(projection);\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const tile = new ReprojTile(\n      sourceProjection,\n      sourceTileGrid,\n      projection,\n      targetTileGrid,\n      tileCoord,\n      wrappedTileCoord,\n      this.getTilePixelRatio(pixelRatio),\n      this.getGutter(),\n      (z, x, y, pixelRatio) =>\n        this.getTileInternal(z, x, y, pixelRatio, sourceProjection),\n      this.reprojectionErrorThreshold_,\n      this.renderReprojectionEdges_,\n      this.tileOptions,\n    );\n    tile.key = key;\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!ImageTile} Tile.\n   * @protected\n   */\n  getTileInternal(z, x, y, pixelRatio, projection) {\n    const key = this.getKey();\n    return this.createTile_(z, x, y, pixelRatio, projection, key);\n  }\n\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  setRenderReprojectionEdges(render) {\n    if (this.renderReprojectionEdges_ == render) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    this.changed();\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =\n    src;\n}\n\nexport default TileImage;\n"],"names":["ImageWrapper","extent","resolution","pixelRatio","stateOrLoader","requestResolution","Array","image","HTMLImageElement","ImageBitmap","HTMLCanvasElement","HTMLVideoElement","error","console","listenImage","loadHandler","errorHandler","listening","decoding","loaded","listenerKeys","img","decodeFallback","src","Promise","resolve","reject","e","handleLoad","unlisten","handleError","Error","decode","createImageBitmap","ImageTile","tileCoord","state","crossOrigin","tileLoadFunction","options","Image","element","getBlankImage","ctx","ReprojTile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","wrappedTileCoord","gutter","getTileFunction","errorThreshold","renderEdges","undefined","targetExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","sourceProjExtent","targetResolution","sourceResolution","isFinite","errorThresholdInPixels","sourceExtent","worldWidth","worldsAway","Math","sourceExtents","sourceRange","srcX","srcY","tile","offset","sources","source","clipExtent","z","size","width","height","leftToLoad","sourceListenKey","setTimeout","i","arr","TileImage","defaultTileLoadFunction","projection","key","thisProj","projKey","x","y","urlTileCoord","tileUrl","sourceProjection","render","tilegrid","proj","imageTile"],"mappings":"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"}