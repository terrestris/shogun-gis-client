{"version":3,"file":"9728.26f8837f418745cf.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/Collection.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/CollectionEventType.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/featureloader.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/loadingstrategy.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/source/Source.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/source/Vector.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/source/VectorEventType.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/structs/RBush.js"],"sourcesContent":["/**\n * @module ol/Collection\n */\nimport CollectionEventType from './CollectionEventType.js';\nimport BaseObject from './Object.js';\nimport Event from './events/Event.js';\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  LENGTH: 'length',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this\n * type.\n * @template T\n */\nexport class CollectionEvent extends Event {\n  /**\n   * @param {import(\"./CollectionEventType.js\").default} type Type.\n   * @param {T} element Element.\n   * @param {number} index The index of the added or removed element.\n   */\n  constructor(type, element, index) {\n    super(type);\n\n    /**\n     * The element that is added to or removed from the collection.\n     * @type {T}\n     * @api\n     */\n    this.element = element;\n\n    /**\n     * The index of the added or removed element.\n     * @type {number}\n     * @api\n     */\n    this.index = index;\n  }\n}\n\n/***\n * @template T\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types|'change:length', import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types|\n *     'change:length'|'add'|'remove',Return>} CollectionOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [unique=false] Disallow the same item from being added to\n * the collection twice.\n */\n\n/**\n * @classdesc\n * An expanded version of standard JS Array, adding convenience methods for\n * manipulation. Add and remove changes to the Collection trigger a Collection\n * event. Note that this does not cover changes to the objects _within_ the\n * Collection; they trigger events on the appropriate object, not on the\n * Collection as a whole.\n *\n * @fires CollectionEvent\n *\n * @template T\n * @api\n */\nclass Collection extends BaseObject {\n  /**\n   * @param {Array<T>} [array] Array.\n   * @param {Options} [options] Collection options.\n   */\n  constructor(array, options) {\n    super();\n\n    /***\n     * @type {CollectionOnSignature<T, import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {CollectionOnSignature<T, import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {CollectionOnSignature<T, void>}\n     */\n    this.un;\n\n    options = options || {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.unique_ = !!options.unique;\n\n    /**\n     * @private\n     * @type {!Array<T>}\n     */\n    this.array_ = array ? array : [];\n\n    if (this.unique_) {\n      for (let i = 0, ii = this.array_.length; i < ii; ++i) {\n        this.assertUnique_(this.array_[i], i);\n      }\n    }\n\n    this.updateLength_();\n  }\n\n  /**\n   * Remove all elements from the collection.\n   * @api\n   */\n  clear() {\n    while (this.getLength() > 0) {\n      this.pop();\n    }\n  }\n\n  /**\n   * Add elements to the collection.  This pushes each item in the provided array\n   * to the end of the collection.\n   * @param {!Array<T>} arr Array.\n   * @return {Collection<T>} This collection.\n   * @api\n   */\n  extend(arr) {\n    for (let i = 0, ii = arr.length; i < ii; ++i) {\n      this.push(arr[i]);\n    }\n    return this;\n  }\n\n  /**\n   * Iterate over each element, calling the provided callback.\n   * @param {function(T, number, Array<T>): *} f The function to call\n   *     for every element. This function takes 3 arguments (the element, the\n   *     index and the array). The return value is ignored.\n   * @api\n   */\n  forEach(f) {\n    const array = this.array_;\n    for (let i = 0, ii = array.length; i < ii; ++i) {\n      f(array[i], i, array);\n    }\n  }\n\n  /**\n   * Get a reference to the underlying Array object. Warning: if the array\n   * is mutated, no events will be dispatched by the collection, and the\n   * collection's \"length\" property won't be in sync with the actual length\n   * of the array.\n   * @return {!Array<T>} Array.\n   * @api\n   */\n  getArray() {\n    return this.array_;\n  }\n\n  /**\n   * Get the element at the provided index.\n   * @param {number} index Index.\n   * @return {T} Element.\n   * @api\n   */\n  item(index) {\n    return this.array_[index];\n  }\n\n  /**\n   * Get the length of this collection.\n   * @return {number} The length of the array.\n   * @observable\n   * @api\n   */\n  getLength() {\n    return this.get(Property.LENGTH);\n  }\n\n  /**\n   * Insert an element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n  insertAt(index, elem) {\n    if (index < 0 || index > this.getLength()) {\n      throw new Error('Index out of bounds: ' + index);\n    }\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n    this.array_.splice(index, 0, elem);\n    this.updateLength_();\n    this.dispatchEvent(\n      new CollectionEvent(CollectionEventType.ADD, elem, index),\n    );\n  }\n\n  /**\n   * Remove the last element of the collection and return it.\n   * Return `undefined` if the collection is empty.\n   * @return {T|undefined} Element.\n   * @api\n   */\n  pop() {\n    return this.removeAt(this.getLength() - 1);\n  }\n\n  /**\n   * Insert the provided element at the end of the collection.\n   * @param {T} elem Element.\n   * @return {number} New length of the collection.\n   * @api\n   */\n  push(elem) {\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n    const n = this.getLength();\n    this.insertAt(n, elem);\n    return this.getLength();\n  }\n\n  /**\n   * Remove the first occurrence of an element from the collection.\n   * @param {T} elem Element.\n   * @return {T|undefined} The removed element or undefined if none found.\n   * @api\n   */\n  remove(elem) {\n    const arr = this.array_;\n    for (let i = 0, ii = arr.length; i < ii; ++i) {\n      if (arr[i] === elem) {\n        return this.removeAt(i);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Remove the element at the provided index and return it.\n   * Return `undefined` if the collection does not contain this index.\n   * @param {number} index Index.\n   * @return {T|undefined} Value.\n   * @api\n   */\n  removeAt(index) {\n    if (index < 0 || index >= this.getLength()) {\n      return undefined;\n    }\n    const prev = this.array_[index];\n    this.array_.splice(index, 1);\n    this.updateLength_();\n    this.dispatchEvent(\n      /** @type {CollectionEvent<T>} */ (\n        new CollectionEvent(CollectionEventType.REMOVE, prev, index)\n      ),\n    );\n    return prev;\n  }\n\n  /**\n   * Set the element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n  setAt(index, elem) {\n    const n = this.getLength();\n    if (index >= n) {\n      this.insertAt(index, elem);\n      return;\n    }\n    if (index < 0) {\n      throw new Error('Index out of bounds: ' + index);\n    }\n    if (this.unique_) {\n      this.assertUnique_(elem, index);\n    }\n    const prev = this.array_[index];\n    this.array_[index] = elem;\n    this.dispatchEvent(\n      /** @type {CollectionEvent<T>} */ (\n        new CollectionEvent(CollectionEventType.REMOVE, prev, index)\n      ),\n    );\n    this.dispatchEvent(\n      /** @type {CollectionEvent<T>} */ (\n        new CollectionEvent(CollectionEventType.ADD, elem, index)\n      ),\n    );\n  }\n\n  /**\n   * @private\n   */\n  updateLength_() {\n    this.set(Property.LENGTH, this.array_.length);\n  }\n\n  /**\n   * @private\n   * @param {T} elem Element.\n   * @param {number} [except] Optional index to ignore.\n   */\n  assertUnique_(elem, except) {\n    for (let i = 0, ii = this.array_.length; i < ii; ++i) {\n      if (this.array_[i] === elem && i !== except) {\n        throw new Error('Duplicate item added to a unique collection');\n      }\n    }\n  }\n}\n\nexport default Collection;\n","/**\n * @module ol/CollectionEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when an item is added to the collection.\n   * @event module:ol/Collection.CollectionEvent#add\n   * @api\n   */\n  ADD: 'add',\n  /**\n   * Triggered when an item is removed from the collection.\n   * @event module:ol/Collection.CollectionEvent#remove\n   * @api\n   */\n  REMOVE: 'remove',\n};\n","/**\n * @module ol/featureloader\n */\nimport {VOID} from './functions.js';\n\n/**\n *\n * @type {boolean}\n * @private\n */\nlet withCredentials = false;\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * load features.\n *\n * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing\n * the area to be loaded, a `{number}` representing the resolution (map units per pixel), a\n * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get\n * the loaded features passed as an argument and an optional failure callback with no arguments. If\n * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and\n * `'featuresloaderror'` events. `this` within the function is bound to the\n * {@link module:ol/source/Vector~VectorSource} it's called from.\n *\n * The function is responsible for loading the features and adding them to the\n * source.\n *\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").FeatureLike]\n * @typedef {(\n *           extent: import(\"./extent.js\").Extent,\n *           resolution: number,\n *           projection: import(\"./proj/Projection.js\").default,\n *           success?: (features: Array<FeatureType>) => void,\n *           failure?: () => void) => void} FeatureLoader\n * @api\n */\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * get the url to load features from.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\n * and an {@link module:ol/proj/Projection~Projection} for the projection  as\n * arguments and returns a `{string}` representing the URL.\n * @typedef {function(import(\"./extent.js\").Extent, number, import(\"./proj/Projection.js\").default): string} FeatureUrlFunction\n * @api\n */\n\n/**\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {function(Array<FeatureType>, import(\"./proj/Projection.js\").default): void} success Success\n *      Function called with the loaded features and optionally with the data projection.\n * @param {function(): void} failure Failure\n *      Function called when loading failed.\n */\nexport function loadFeaturesXhr(\n  url,\n  format,\n  extent,\n  resolution,\n  projection,\n  success,\n  failure,\n) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\n    'GET',\n    typeof url === 'function' ? url(extent, resolution, projection) : url,\n    true,\n  );\n  if (format.getType() == 'arraybuffer') {\n    xhr.responseType = 'arraybuffer';\n  }\n  xhr.withCredentials = withCredentials;\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  xhr.onload = function (event) {\n    // status will be 0 for file:// urls\n    if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {\n      const type = format.getType();\n      try {\n        /** @type {Document|Node|Object|string|undefined} */\n        let source;\n        if (type == 'text' || type == 'json') {\n          source = xhr.responseText;\n        } else if (type == 'xml') {\n          source = xhr.responseXML || xhr.responseText;\n        } else if (type == 'arraybuffer') {\n          source = /** @type {ArrayBuffer} */ (xhr.response);\n        }\n        if (source) {\n          success(\n            /** @type {Array<FeatureType>} */\n            (\n              format.readFeatures(source, {\n                extent: extent,\n                featureProjection: projection,\n              })\n            ),\n            format.readProjection(source),\n          );\n        } else {\n          failure();\n        }\n      } catch {\n        failure();\n      }\n    } else {\n      failure();\n    }\n  };\n  /**\n   * @private\n   */\n  xhr.onerror = failure;\n  xhr.send();\n}\n\n/**\n * Create an XHR feature loader for a `url` and `format`. The feature loader\n * loads features (with XHR), parses the features, and adds them to the\n * vector source.\n *\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @return {FeatureLoader<FeatureType>} The feature loader.\n * @api\n */\nexport function xhr(url, format) {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"./proj/Projection.js\").default} projection Projection.\n   * @param {function(Array<FeatureType>): void} [success] Success\n   *      Function called when loading succeeded.\n   * @param {function(): void} [failure] Failure\n   *      Function called when loading failed.\n   * @this {import(\"./source/Vector.js\").default<FeatureType>}\n   */\n  return function (extent, resolution, projection, success, failure) {\n    loadFeaturesXhr(\n      url,\n      format,\n      extent,\n      resolution,\n      projection,\n      /**\n       * @param {Array<FeatureType>} features The loaded features.\n       * @param {import(\"./proj/Projection.js\").default} dataProjection Data\n       * projection.\n       */\n      (features, dataProjection) => {\n        this.addFeatures(features);\n        if (success !== undefined) {\n          success(features);\n        }\n      },\n      /* FIXME handle error */ failure ? failure : VOID,\n    );\n  };\n}\n\n/**\n * Setter for the withCredentials configuration for the XHR.\n *\n * @param {boolean} xhrWithCredentials The value of withCredentials to set.\n * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/\n * @api\n */\nexport function setWithCredentials(xhrWithCredentials) {\n  withCredentials = xhrWithCredentials;\n}\n","/**\n * @module ol/loadingstrategy\n */\n\nimport {fromUserExtent, fromUserResolution, toUserExtent} from './proj.js';\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function bbox(extent, resolution) {\n  return [extent];\n}\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {function(import(\"./extent.js\").Extent, number, import(\"./proj.js\").Projection): Array<import(\"./extent.js\").Extent>} Loading strategy.\n * @api\n */\nexport function tile(tileGrid) {\n  return (\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./proj.js\").Projection} projection Projection.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     */\n    function (extent, resolution, projection) {\n      const z = tileGrid.getZForResolution(\n        fromUserResolution(resolution, projection),\n      );\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        fromUserExtent(extent, projection),\n        z,\n      );\n      /** @type {Array<import(\"./extent.js\").Extent>} */\n      const extents = [];\n      /** @type {import(\"./tilecoord.js\").TileCoord} */\n      const tileCoord = [z, 0, 0];\n      for (\n        tileCoord[1] = tileRange.minX;\n        tileCoord[1] <= tileRange.maxX;\n        ++tileCoord[1]\n      ) {\n        for (\n          tileCoord[2] = tileRange.minY;\n          tileCoord[2] <= tileRange.maxY;\n          ++tileCoord[2]\n        ) {\n          extents.push(\n            toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection),\n          );\n        }\n      }\n      return extents;\n    }\n  );\n}\n","/**\n * @module ol/source/Source\n */\nimport BaseObject from '../Object.js';\nimport {get as getProjection} from '../proj.js';\n\n/**\n * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n */\n\n/**\n * A function that takes a {@link import(\"../View.js\").ViewStateLayerStateExtent} and returns a string or\n * an array of strings representing source attributions.\n *\n * @typedef {function(import(\"../View.js\").ViewStateLayerStateExtent): (string|Array<string>)} Attribution\n */\n\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * a simple string (e.g. `'© Acme Inc.'`)\n * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)\n * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {import(\"./Source.js\").State} [state='ready'] State.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\nclass Source extends BaseObject {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|null}\n     */\n    this.projection = getProjection(options.projection);\n\n    /**\n     * @private\n     * @type {?Attribution}\n     */\n    this.attributions_ = adaptAttributions(options.attributions);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;\n\n    /**\n     * This source is currently loading data. Sources that defer loading to the\n     * map's tile queue never set this to `true`.\n     * @type {boolean}\n     */\n    this.loading = false;\n\n    /**\n     * @private\n     * @type {import(\"./Source.js\").State}\n     */\n    this.state_ = options.state !== undefined ? options.state : 'ready';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = !!options.interpolate;\n\n    /**\n     * @protected\n     * @type {function(import(\"../View.js\").ViewOptions):void}\n     */\n    this.viewResolver = null;\n\n    /**\n     * @protected\n     * @type {function(Error):void}\n     */\n    this.viewRejector = null;\n\n    const self = this;\n    /**\n     * @private\n     * @type {Promise<import(\"../View.js\").ViewOptions>}\n     */\n    this.viewPromise_ = new Promise(function (resolve, reject) {\n      self.viewResolver = resolve;\n      self.viewRejector = reject;\n    });\n  }\n\n  /**\n   * Get the attribution function for the source.\n   * @return {?Attribution} Attribution function.\n   * @api\n   */\n  getAttributions() {\n    return this.attributions_;\n  }\n\n  /**\n   * @return {boolean} Attributions are collapsible.\n   * @api\n   */\n  getAttributionsCollapsible() {\n    return this.attributionsCollapsible_;\n  }\n\n  /**\n   * Get the projection of the source.\n   * @return {import(\"../proj/Projection.js\").default|null} Projection.\n   * @api\n   */\n  getProjection() {\n    return this.projection;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions(projection) {\n    return null;\n  }\n\n  /**\n   * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n   */\n  getView() {\n    return this.viewPromise_;\n  }\n\n  /**\n   * Get the state of the source, see {@link import(\"./Source.js\").State} for possible states.\n   * @return {import(\"./Source.js\").State} State.\n   * @api\n   */\n  getState() {\n    return this.state_;\n  }\n\n  /**\n   * @return {boolean|undefined} Wrap X.\n   */\n  getWrapX() {\n    return this.wrapX_;\n  }\n\n  /**\n   * @return {boolean} Use linear interpolation when resampling.\n   */\n  getInterpolate() {\n    return this.interpolate_;\n  }\n\n  /**\n   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\n   * @api\n   */\n  refresh() {\n    this.changed();\n  }\n\n  /**\n   * Set the attributions of the source.\n   * @param {AttributionLike|undefined} attributions Attributions.\n   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\n   *     or `undefined`.\n   * @api\n   */\n  setAttributions(attributions) {\n    this.attributions_ = adaptAttributions(attributions);\n    this.changed();\n  }\n\n  /**\n   * Set the state of the source.\n   * @param {import(\"./Source.js\").State} state State.\n   */\n  setState(state) {\n    this.state_ = state;\n    this.changed();\n  }\n}\n\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {Attribution|null} An attribution function (or null).\n */\nfunction adaptAttributions(attributionLike) {\n  if (!attributionLike) {\n    return null;\n  }\n  if (typeof attributionLike === 'function') {\n    return attributionLike;\n  }\n  if (!Array.isArray(attributionLike)) {\n    attributionLike = [attributionLike];\n  }\n  return (frameState) => attributionLike;\n}\n\nexport default Source;\n","/**\n * @module ol/source/Vector\n */\n\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport {extend} from '../array.js';\nimport {assert} from '../asserts.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {containsExtent, equals, wrapAndSliceX} from '../extent.js';\nimport {xhr} from '../featureloader.js';\nimport {TRUE, VOID} from '../functions.js';\nimport {all as allStrategy} from '../loadingstrategy.js';\nimport {isEmpty} from '../obj.js';\nimport RenderFeature from '../render/Feature.js';\nimport RBush from '../structs/RBush.js';\nimport {getUid} from '../util.js';\nimport Source from './Source.js';\nimport VectorEventType from './VectorEventType.js';\n\n/**\n * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\n * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\n * is one of the standard {@link module:ol/loadingstrategy} strategies.\n *\n * @typedef {function(import(\"../extent.js\").Extent, number, import(\"../proj/Projection.js\").default): Array<import(\"../extent.js\").Extent>} LoadingStrategy\n * @api\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this\n * type.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nexport class VectorSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {FeatureType} [feature] Feature.\n   * @param {Array<FeatureType>} [features] Features.\n   */\n  constructor(type, feature, features) {\n    super(type);\n\n    /**\n     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.\n     * @type {FeatureType|undefined}\n     * @api\n     */\n    this.feature = feature;\n\n    /**\n     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.\n     * @type {Array<FeatureType>|undefined}\n     * @api\n     */\n    this.features = features;\n  }\n}\n\n/***\n * @template {import(\"../Feature.js\").FeatureLike} [T=import(\"../Feature.js\").default]\n * @typedef {T extends RenderFeature ? T|Array<T> : T} FeatureClassOrArrayOfRenderFeatures\n */\n\n/***\n * @template Return\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./VectorEventType\").VectorSourceEventTypes, VectorSourceEvent<FeatureType>, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./VectorEventType\").VectorSourceEventTypes, Return>} VectorSourceOnSignature\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {Array<FeatureType>|Collection<FeatureType>} [features]\n * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source\n * and the collection will stay in sync.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] The feature format used by the XHR\n * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\n * @property {import(\"../featureloader.js\").FeatureLoader<FeatureType>} [loader]\n * The loader function used to load features, from a remote source for example.\n * If this is not set and `url` is set, the source will create and use an XHR\n * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events\n * will only fire if the `success` and `failure` callbacks are used.\n *\n * Example:\n *\n * ```js\n * import Vector from 'ol/source/Vector.js';\n * import GeoJSON from 'ol/format/GeoJSON.js';\n * import {bbox} from 'ol/loadingstrategy.js';\n *\n * const vectorSource = new Vector({\n *   format: new GeoJSON(),\n *   loader: function(extent, resolution, projection, success, failure) {\n *      const proj = projection.getCode();\n *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +\n *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +\n *          'outputFormat=application/json&srsname=' + proj + '&' +\n *          'bbox=' + extent.join(',') + ',' + proj;\n *      const xhr = new XMLHttpRequest();\n *      xhr.open('GET', url);\n *      const onError = function() {\n *        vectorSource.removeLoadedExtent(extent);\n *        failure();\n *      }\n *      xhr.onerror = onError;\n *      xhr.onload = function() {\n *        if (xhr.status == 200) {\n *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);\n *          vectorSource.addFeatures(features);\n *          success(features);\n *        } else {\n *          onError();\n *        }\n *      }\n *      xhr.send();\n *    },\n *    strategy: bbox,\n *  });\n * ```\n * @property {boolean} [overlaps=true] This source may have overlapping geometries.\n * Setting this to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {LoadingStrategy} [strategy] The loading strategy to use.\n * By default an {@link module:ol/loadingstrategy.all}\n * strategy is used, a one-off strategy which loads all features at once.\n * @property {string|import(\"../featureloader.js\").FeatureUrlFunction} [url]\n * Setting this option instructs the source to load features using an XHR loader\n * (see {@link module:ol/featureloader.xhr}). Use a `string` and an\n * {@link module:ol/loadingstrategy.all} for a one-off download of all features from\n * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with\n * other loading strategies.\n * Requires `format` to be set as well.\n * When default XHR feature loader is provided, the features will\n * be transformed from the data projection to the view projection\n * during parsing. If your remote data source does not advertise its projection\n * properly, this transformation will be incorrect. For some formats, the\n * default projection (usually EPSG:4326) can be overridden by setting the\n * dataProjection constructor option on the format.\n * Note that if a source contains non-feature data, such as a GeoJSON geometry\n * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\n * @property {boolean} [useSpatialIndex=true]\n * By default, an RTree is used as spatial index. When features are removed and\n * added frequently, and the total number of features is low, setting this to\n * `false` may improve performance.\n *\n * Note that\n * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\n * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\n * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\n * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\n * through all features.\n *\n * When set to `false`, the features will be maintained in an\n * {@link module:ol/Collection~Collection}, which can be retrieved through\n * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\n * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\n * -180° and 180° meridians to work properly, this should be set to `false`. The\n * resulting geometry coordinates will then exceed the world bounds.\n */\n\n/**\n * @classdesc\n * Provides a source of features for vector layers. Vector features provided\n * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\n * vector data that is optimized for rendering.\n *\n * @fires VectorSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nclass VectorSource extends Source {\n  /**\n   * @param {Options<FeatureType>} [options] Vector source options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: true,\n      projection: undefined,\n      state: 'ready',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n    });\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {import(\"../featureloader.js\").FeatureLoader<import(\"../Feature.js\").FeatureLike>}\n     */\n    this.loader_ = VOID;\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format || null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;\n\n    /**\n     * @private\n     * @type {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined}\n     */\n    this.url_ = options.url;\n\n    if (options.loader !== undefined) {\n      this.loader_ = options.loader;\n    } else if (this.url_ !== undefined) {\n      assert(this.format_, '`format` must be set when `url` is set');\n      // create a XHR feature loader for \"url\" and \"format\"\n      this.loader_ = xhr(this.url_, this.format_);\n    }\n\n    /**\n     * @private\n     * @type {LoadingStrategy}\n     */\n    this.strategy_ =\n      options.strategy !== undefined ? options.strategy : allStrategy;\n\n    const useSpatialIndex =\n      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n\n    /**\n     * @private\n     * @type {RBush<FeatureType>}\n     */\n    this.featuresRtree_ = useSpatialIndex ? new RBush() : null;\n\n    /**\n     * @private\n     * @type {RBush<{extent: import(\"../extent.js\").Extent}>}\n     */\n    this.loadedExtentsRtree_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.loadingExtentsCount_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.nullGeometryFeatures_ = {};\n\n    /**\n     * A lookup of features by id (the return from feature.getId()).\n     * @private\n     * @type {!Object<string, import('../Feature.js').FeatureLike|Array<import('../Feature.js').FeatureLike>>}\n     */\n    this.idIndex_ = {};\n\n    /**\n     * A lookup of features by uid (using getUid(feature)).\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.uidIndex_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.featureChangeKeys_ = {};\n\n    /**\n     * @private\n     * @type {Collection<FeatureType>|null}\n     */\n    this.featuresCollection_ = null;\n\n    /** @type {Collection<FeatureType>} */\n    let collection;\n    /** @type {Array<FeatureType>} */\n    let features;\n    if (Array.isArray(options.features)) {\n      features = options.features;\n    } else if (options.features) {\n      collection = options.features;\n      features = collection.getArray();\n    }\n    if (!useSpatialIndex && collection === undefined) {\n      collection = new Collection(features);\n    }\n    if (features !== undefined) {\n      this.addFeaturesInternal(features);\n    }\n    if (collection !== undefined) {\n      this.bindFeaturesCollection_(collection);\n    }\n  }\n\n  /**\n   * Add a single feature to the source.  If you want to add a batch of features\n   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\n   * instead. A feature will not be added to the source if feature with\n   * the same id is already there. The reason for this behavior is to avoid\n   * feature duplication when using bbox or tile loading strategies.\n   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,\n   * meaning that if a feature with a duplicate id is added in the collection, it will\n   * be removed from it right away.\n   * @param {FeatureType} feature Feature to add.\n   * @api\n   */\n  addFeature(feature) {\n    this.addFeatureInternal(feature);\n    this.changed();\n  }\n\n  /**\n   * Add a feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @protected\n   */\n  addFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n\n    if (!this.addToIndex_(featureKey, feature)) {\n      if (this.featuresCollection_) {\n        this.featuresCollection_.remove(feature);\n      }\n      return;\n    }\n\n    this.setupChangeEvents_(featureKey, feature);\n\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const extent = geometry.getExtent();\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.ADDFEATURE, feature),\n    );\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  setupChangeEvents_(featureKey, feature) {\n    if (feature instanceof RenderFeature) {\n      return;\n    }\n    this.featureChangeKeys_[featureKey] = [\n      listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),\n      listen(\n        feature,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleFeatureChange_,\n        this,\n      ),\n    ];\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @return {boolean} The feature is \"valid\", in the sense that it is also a\n   *     candidate for insertion into the Rtree.\n   * @private\n   */\n  addToIndex_(featureKey, feature) {\n    let valid = true;\n    if (feature.getId() !== undefined) {\n      const id = String(feature.getId());\n      if (!(id in this.idIndex_)) {\n        this.idIndex_[id] = feature;\n      } else if (feature instanceof RenderFeature) {\n        const indexedFeature = this.idIndex_[id];\n        if (!(indexedFeature instanceof RenderFeature)) {\n          valid = false;\n        } else if (!Array.isArray(indexedFeature)) {\n          this.idIndex_[id] = [indexedFeature, feature];\n        } else {\n          indexedFeature.push(feature);\n        }\n      } else {\n        valid = false;\n      }\n    }\n    if (valid) {\n      assert(\n        !(featureKey in this.uidIndex_),\n        'The passed `feature` was already added to the source',\n      );\n      this.uidIndex_[featureKey] = feature;\n    }\n    return valid;\n  }\n\n  /**\n   * Add a batch of features to the source.\n   * @param {Array<FeatureType>} features Features to add.\n   * @api\n   */\n  addFeatures(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  }\n\n  /**\n   * Add features without firing a `change` event.\n   * @param {Array<FeatureType>} features Features.\n   * @protected\n   */\n  addFeaturesInternal(features) {\n    const extents = [];\n    /** @type {Array<FeatureType>} */\n    const newFeatures = [];\n    /** @type {Array<FeatureType>} */\n    const geometryFeatures = [];\n\n    for (let i = 0, length = features.length; i < length; i++) {\n      const feature = features[i];\n      const featureKey = getUid(feature);\n      if (this.addToIndex_(featureKey, feature)) {\n        newFeatures.push(feature);\n      }\n    }\n\n    for (let i = 0, length = newFeatures.length; i < length; i++) {\n      const feature = newFeatures[i];\n      const featureKey = getUid(feature);\n      this.setupChangeEvents_(featureKey, feature);\n\n      const geometry = feature.getGeometry();\n      if (geometry) {\n        const extent = geometry.getExtent();\n        extents.push(extent);\n        geometryFeatures.push(feature);\n      } else {\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n\n    if (this.hasListener(VectorEventType.ADDFEATURE)) {\n      for (let i = 0, length = newFeatures.length; i < length; i++) {\n        this.dispatchEvent(\n          new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]),\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!Collection<FeatureType>} collection Collection.\n   * @private\n   */\n  bindFeaturesCollection_(collection) {\n    let modifyingCollection = false;\n    this.addEventListener(\n      VectorEventType.ADDFEATURE,\n      /**\n       * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.push(evt.feature);\n          modifyingCollection = false;\n        }\n      },\n    );\n    this.addEventListener(\n      VectorEventType.REMOVEFEATURE,\n      /**\n       * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.remove(evt.feature);\n          modifyingCollection = false;\n        }\n      },\n    );\n    collection.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n       */\n      (evt) => {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.addFeature(evt.element);\n          modifyingCollection = false;\n        }\n      },\n    );\n    collection.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n       */\n      (evt) => {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.removeFeature(evt.element);\n          modifyingCollection = false;\n        }\n      },\n    );\n    this.featuresCollection_ = collection;\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.\n   * @api\n   */\n  clear(fast) {\n    if (fast) {\n      for (const featureId in this.featureChangeKeys_) {\n        const keys = this.featureChangeKeys_[featureId];\n        keys.forEach(unlistenByKey);\n      }\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.uidIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.forEach((feature) => {\n          this.removeFeatureInternal(feature);\n        });\n        for (const id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n\n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n    this.nullGeometryFeatures_ = {};\n\n    const clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  }\n\n  /**\n   * Iterate through all features on the source, calling the provided callback\n   * with each one.  If the callback returns any \"truthy\" value, iteration will\n   * stop and the function will return the same value.\n   * Note: this function only iterate through the feature that have a defined geometry.\n   *\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     on the source.  Return a truthy value to stop iteration.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeature(callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometries contain the provided\n   * coordinate, calling the callback with each feature.  If the callback returns\n   * a \"truthy\" value, iteration will stop and the function will return the same\n   * value.\n   *\n   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be\n   * called for all features.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose goemetry contains the provided coordinate.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   */\n  forEachFeatureAtCoordinateDirect(coordinate, callback) {\n    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent, function (feature) {\n      const geometry = feature.getGeometry();\n      if (\n        geometry instanceof RenderFeature ||\n        geometry.intersectsCoordinate(coordinate)\n      ) {\n        return callback(feature);\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * Iterate through all features whose bounding box intersects the provided\n   * extent (note that the feature's geometry may not intersect the extent),\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you are interested in features whose geometry intersects an extent, call\n   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\n   *\n   * When `useSpatialIndex` is set to false, this method will loop through all\n   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose bounding box intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureInExtent(extent, callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent, callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometry intersects the provided extent,\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you only want to test for bounding box intersection, call the\n   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose geometry intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureIntersectingExtent(extent, callback) {\n    return this.forEachFeatureInExtent(\n      extent,\n      /**\n       * @param {FeatureType} feature Feature.\n       * @return {T|undefined} The return value from the last call to the callback.\n       */\n      function (feature) {\n        const geometry = feature.getGeometry();\n        if (\n          geometry instanceof RenderFeature ||\n          geometry.intersectsExtent(extent)\n        ) {\n          const result = callback(feature);\n          if (result) {\n            return result;\n          }\n        }\n      },\n    );\n  }\n\n  /**\n   * Get the features collection associated with this source. Will be `null`\n   * unless the source was configured with `useSpatialIndex` set to `false`, or\n   * with a {@link module:ol/Collection~Collection} as `features`.\n   * @return {Collection<FeatureType>|null} The collection of features.\n   * @api\n   */\n  getFeaturesCollection() {\n    return this.featuresCollection_;\n  }\n\n  /**\n   * Get a snapshot of the features currently on the source in random order. The returned array\n   * is a copy, the features are references to the features in the source.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeatures() {\n    let features;\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray().slice(0);\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n      if (!isEmpty(this.nullGeometryFeatures_)) {\n        extend(features, Object.values(this.nullGeometryFeatures_));\n      }\n    }\n    return features;\n  }\n\n  /**\n   * Get all features whose geometry intersects the provided coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesAtCoordinate(coordinate) {\n    /** @type {Array<FeatureType>} */\n    const features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {\n      features.push(feature);\n    });\n    return features;\n  }\n\n  /**\n   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of\n   * all features intersecting the given extent in random order (so it may include\n   * features whose geometries do not intersect the extent).\n   *\n   * When `useSpatialIndex` is set to false, this method will return all\n   * features.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Include features\n   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent, projection) {\n    if (this.featuresRtree_) {\n      const multiWorld = projection && projection.canWrapX() && this.getWrapX();\n\n      if (!multiWorld) {\n        return this.featuresRtree_.getInExtent(extent);\n      }\n\n      const extents = wrapAndSliceX(extent, projection);\n\n      return [].concat(\n        ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent)),\n      );\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getArray().slice(0);\n    }\n    return [];\n  }\n\n  /**\n   * Get the closest feature to the provided coordinate.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false` and the features in this source are of type\n   * {@link module:ol/Feature~Feature}.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType):boolean} [filter] Feature filter function.\n   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}\n   *     and it should return a boolean value. By default, no filtering is made.\n   * @return {FeatureType} Closest feature.\n   * @api\n   */\n  getClosestFeatureToCoordinate(coordinate, filter) {\n    // Find the closest feature using branch and bound.  We start searching an\n    // infinite extent, and find the distance from the first feature found.  This\n    // becomes the closest feature.  We then compute a smaller extent which any\n    // closer feature must intersect.  We continue searching with this smaller\n    // extent, trying to find a closer feature.  Every time we find a closer\n    // feature, we update the extent being searched so that any even closer\n    // feature must intersect it.  We continue until we run out of features.\n    const x = coordinate[0];\n    const y = coordinate[1];\n    let closestFeature = null;\n    const closestPoint = [NaN, NaN];\n    let minSquaredDistance = Infinity;\n    const extent = [-Infinity, -Infinity, Infinity, Infinity];\n    filter = filter ? filter : TRUE;\n    this.featuresRtree_.forEachInExtent(\n      extent,\n      /**\n       * @param {FeatureType} feature Feature.\n       */\n      function (feature) {\n        if (filter(feature)) {\n          const geometry = feature.getGeometry();\n          const previousMinSquaredDistance = minSquaredDistance;\n          minSquaredDistance =\n            geometry instanceof RenderFeature\n              ? 0\n              : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);\n          if (minSquaredDistance < previousMinSquaredDistance) {\n            closestFeature = feature;\n            // This is sneaky.  Reduce the extent that it is currently being\n            // searched while the R-Tree traversal using this same extent object\n            // is still in progress.  This is safe because the new extent is\n            // strictly contained by the old extent.\n            const minDistance = Math.sqrt(minSquaredDistance);\n            extent[0] = x - minDistance;\n            extent[1] = y - minDistance;\n            extent[2] = x + minDistance;\n            extent[3] = y + minDistance;\n          }\n        }\n      },\n    );\n    return closestFeature;\n  }\n\n  /**\n   * Get the extent of the features currently in the source.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import(\"../extent.js\").Extent} [extent] Destination extent. If provided, no new extent\n   *     will be created. Instead, that extent's coordinates will be overwritten.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent(extent) {\n    return this.featuresRtree_.getExtent(extent);\n  }\n\n  /**\n   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s\n   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling\n   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per\n   * `GeometryCollection` member.\n   * Note that the index treats string and numeric identifiers as the same.  So\n   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n   *\n   * @param {string|number} id Feature identifier.\n   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).\n   * @api\n   */\n  getFeatureById(id) {\n    const feature = this.idIndex_[id.toString()];\n    return feature !== undefined\n      ? /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */ (\n          feature\n        )\n      : null;\n  }\n\n  /**\n   * Get a feature by its internal unique identifier (using `getUid`).\n   *\n   * @param {string} uid Feature identifier.\n   * @return {FeatureType|null} The feature (or `null` if not found).\n   */\n  getFeatureByUid(uid) {\n    const feature = this.uidIndex_[uid];\n    return feature !== undefined ? feature : null;\n  }\n\n  /**\n   * Get the format associated with this source.\n   *\n   * @return {import(\"../format/Feature.js\").default<FeatureType>|null}} The feature format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * Get the url associated with this source.\n   *\n   * @return {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined} The url.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  handleFeatureChange_(event) {\n    const feature = /** @type {FeatureType} */ (event.target);\n    const featureKey = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature);\n        }\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    } else {\n      const extent = geometry.getExtent();\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent, feature);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent, feature);\n        }\n      }\n    }\n    const id = feature.getId();\n    if (id !== undefined) {\n      const sid = id.toString();\n      if (this.idIndex_[sid] !== feature) {\n        this.removeFromIdIndex_(feature);\n        this.idIndex_[sid] = feature;\n      }\n    } else {\n      this.removeFromIdIndex_(feature);\n      this.uidIndex_[featureKey] = feature;\n    }\n    this.changed();\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature),\n    );\n  }\n\n  /**\n   * Returns true if the feature is contained within the source.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} Has feature.\n   * @api\n   */\n  hasFeature(feature) {\n    const id = feature.getId();\n    if (id !== undefined) {\n      return id in this.idIndex_;\n    }\n    return getUid(feature) in this.uidIndex_;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    if (this.featuresRtree_) {\n      return (\n        this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_)\n      );\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getLength() === 0;\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const extentsToLoad = this.strategy_(extent, resolution, projection);\n    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n      const extentToLoad = extentsToLoad[i];\n      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(\n        extentToLoad,\n        /**\n         * @param {{extent: import(\"../extent.js\").Extent}} object Object.\n         * @return {boolean} Contains.\n         */\n        function (object) {\n          return containsExtent(object.extent, extentToLoad);\n        },\n      );\n      if (!alreadyLoaded) {\n        ++this.loadingExtentsCount_;\n        this.dispatchEvent(\n          new VectorSourceEvent(VectorEventType.FEATURESLOADSTART),\n        );\n        this.loader_.call(\n          this,\n          extentToLoad,\n          resolution,\n          projection,\n          /**\n           * @param {Array<FeatureType>} features Loaded features\n           */\n          (features) => {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(\n                VectorEventType.FEATURESLOADEND,\n                undefined,\n                features,\n              ),\n            );\n          },\n          () => {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(VectorEventType.FEATURESLOADERROR),\n            );\n          },\n        );\n        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});\n      }\n    }\n    this.loading =\n      this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;\n  }\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear(true);\n    this.loadedExtentsRtree_.clear();\n    super.refresh();\n  }\n\n  /**\n   * Remove an extent from the list of loaded extents.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  removeLoadedExtent(extent) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const obj = loadedExtentsRtree.forEachInExtent(extent, function (object) {\n      if (equals(object.extent, extent)) {\n        return object;\n      }\n    });\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  }\n\n  /**\n   * Batch remove features from the source.  If you want to remove all features\n   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\n   * instead.\n   * @param {Array<FeatureType>} features Features to remove.\n   * @api\n   */\n  removeFeatures(features) {\n    let removed = false;\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      removed = this.removeFeatureInternal(features[i]) || removed;\n    }\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove a single feature from the source. If you want to batch remove\n   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method\n   * instead.\n   * @param {FeatureType} feature Feature to remove.\n   * @api\n   */\n  removeFeature(feature) {\n    if (!feature) {\n      return;\n    }\n    const removed = this.removeFeatureInternal(feature);\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} True if the feature was removed, false if it was not found.\n   * @protected\n   */\n  removeFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n    if (!(featureKey in this.uidIndex_)) {\n      return false;\n    }\n\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n    }\n\n    const featureChangeKeys = this.featureChangeKeys_[featureKey];\n    featureChangeKeys?.forEach(unlistenByKey);\n    delete this.featureChangeKeys_[featureKey];\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      const idString = id.toString();\n      const indexedFeature = this.idIndex_[idString];\n      if (indexedFeature === feature) {\n        delete this.idIndex_[idString];\n      } else if (Array.isArray(indexedFeature)) {\n        indexedFeature.splice(indexedFeature.indexOf(feature), 1);\n        if (indexedFeature.length === 1) {\n          this.idIndex_[idString] = indexedFeature[0];\n        }\n      }\n    }\n    delete this.uidIndex_[featureKey];\n    if (this.hasListener(VectorEventType.REMOVEFEATURE)) {\n      this.dispatchEvent(\n        new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature),\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Remove a feature from the id index.  Called internally when the feature id\n   * may have changed.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  removeFromIdIndex_(feature) {\n    for (const id in this.idIndex_) {\n      if (this.idIndex_[id] === feature) {\n        delete this.idIndex_[id];\n        break;\n      }\n    }\n  }\n\n  /**\n   * Set the new loader of the source. The next render cycle will use the\n   * new loader.\n   * @param {import(\"../featureloader.js\").FeatureLoader} loader The loader to set.\n   * @api\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * Points the source to a new url. The next render cycle will use the new url.\n   * @param {string|import(\"../featureloader.js\").FeatureUrlFunction} url Url.\n   * @api\n   */\n  setUrl(url) {\n    assert(this.format_, '`format` must be set when `url` is set');\n    this.url_ = url;\n    this.setLoader(xhr(url, this.format_));\n  }\n\n  /**\n   * @param {boolean} overlaps The source can have overlapping geometries.\n   */\n  setOverlaps(overlaps) {\n    this.overlaps_ = overlaps;\n    this.changed();\n  }\n}\n\nexport default VectorSource;\n","/**\n * @module ol/source/VectorEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a feature is added to the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#addfeature\n   * @api\n   */\n  ADDFEATURE: 'addfeature',\n\n  /**\n   * Triggered when a feature is updated.\n   * @event module:ol/source/Vector.VectorSourceEvent#changefeature\n   * @api\n   */\n  CHANGEFEATURE: 'changefeature',\n\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#clear\n   * @api\n   */\n  CLEAR: 'clear',\n\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.\n   * @event module:ol/source/Vector.VectorSourceEvent#removefeature\n   * @api\n   */\n  REMOVEFEATURE: 'removefeature',\n\n  /**\n   * Triggered when features starts loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart\n   * @api\n   */\n  FEATURESLOADSTART: 'featuresloadstart',\n\n  /**\n   * Triggered when features finishes loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend\n   * @api\n   */\n  FEATURESLOADEND: 'featuresloadend',\n\n  /**\n   * Triggered if feature loading results in an error.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror\n   * @api\n   */\n  FEATURESLOADERROR: 'featuresloaderror',\n};\n\n/**\n * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes\n */\n","/**\n * @module ol/structs/RBush\n */\nimport RBush_ from 'rbush';\nimport {createOrUpdate, equals} from '../extent.js';\nimport {isEmpty} from '../obj.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {import(\"rbush\").BBox & {value: T}} Entry\n * @template T\n */\n\n/**\n * @classdesc\n * Wrapper around the RBush by Vladimir Agafonkin.\n * See https://github.com/mourner/rbush.\n *\n * @template {Object} T\n */\nclass RBush {\n  /**\n   * @param {number} [maxEntries] Max entries.\n   */\n  constructor(maxEntries) {\n    /**\n     * @private\n     * @type {RBush_<Entry<T>>}\n     */\n    this.rbush_ = new RBush_(maxEntries);\n\n    /**\n     * A mapping between the objects added to this rbush wrapper\n     * and the objects that are actually added to the internal rbush.\n     * @private\n     * @type {Object<string, Entry<T>>}\n     */\n    this.items_ = {};\n  }\n\n  /**\n   * Insert a value into the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  insert(extent, value) {\n    /** @type {Entry<T>} */\n    const item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value,\n    };\n\n    this.rbush_.insert(item);\n    this.items_[getUid(value)] = item;\n  }\n\n  /**\n   * Bulk-insert values into the RBush.\n   * @param {Array<import(\"../extent.js\").Extent>} extents Extents.\n   * @param {Array<T>} values Values.\n   */\n  load(extents, values) {\n    const items = new Array(values.length);\n    for (let i = 0, l = values.length; i < l; i++) {\n      const extent = extents[i];\n      const value = values[i];\n\n      /** @type {Entry<T>} */\n      const item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value,\n      };\n      items[i] = item;\n      this.items_[getUid(value)] = item;\n    }\n    this.rbush_.load(items);\n  }\n\n  /**\n   * Remove a value from the RBush.\n   * @param {T} value Value.\n   * @return {boolean} Removed.\n   */\n  remove(value) {\n    const uid = getUid(value);\n\n    // get the object in which the value was wrapped when adding to the\n    // internal rbush. then use that object to do the removal.\n    const item = this.items_[uid];\n    delete this.items_[uid];\n    return this.rbush_.remove(item) !== null;\n  }\n\n  /**\n   * Update the extent of a value in the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  update(extent, value) {\n    const item = this.items_[getUid(value)];\n    const bbox = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!equals(bbox, extent)) {\n      this.remove(value);\n      this.insert(extent, value);\n    }\n  }\n\n  /**\n   * Return all values in the RBush.\n   * @return {Array<T>} All.\n   */\n  getAll() {\n    const items = this.rbush_.all();\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Return all values in the given extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<T>} All in extent.\n   */\n  getInExtent(extent) {\n    /** @type {import(\"rbush\").BBox} */\n    const bbox = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n    };\n    const items = this.rbush_.search(bbox);\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Calls a callback function with each value in the tree.\n   * If the callback returns a truthy value, this value is returned without\n   * checking the rest of the tree.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   */\n  forEach(callback) {\n    return this.forEach_(this.getAll(), callback);\n  }\n\n  /**\n   * Calls a callback function with each value in the provided extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   */\n  forEachInExtent(extent, callback) {\n    return this.forEach_(this.getInExtent(extent), callback);\n  }\n\n  /**\n   * @param {Array<T>} values Values.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   * @private\n   */\n  forEach_(values, callback) {\n    let result;\n    for (let i = 0, l = values.length; i < l; i++) {\n      result = callback(values[i]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.items_);\n  }\n\n  /**\n   * Remove all values from the RBush.\n   */\n  clear() {\n    this.rbush_.clear();\n    this.items_ = {};\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getExtent(extent) {\n    const data = this.rbush_.toJSON();\n    return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);\n  }\n\n  /**\n   * @param {RBush<T>} rbush R-Tree.\n   */\n  concat(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (const i in rbush.items_) {\n      this.items_[i] = rbush.items_[i];\n    }\n  }\n}\n\nexport default RBush;\n"],"names":["CollectionEvent","type","element","index","Collection","array","options","i","ii","arr","f","elem","Error","n","prev","except","loadFeaturesXhr","url","format","extent","resolution","projection","success","failure","xhr","XMLHttpRequest","event","source","features","dataProjection","undefined","all","Infinity","bbox","tile","tileGrid","z","tileRange","extents","tileCoord","Source","adaptAttributions","self","Promise","resolve","reject","attributions","state","attributionLike","Array","frameState","VectorSourceEvent","feature","VectorSource","collection","useSpatialIndex","featureKey","geometry","valid","id","String","indexedFeature","newFeatures","geometryFeatures","length","modifyingCollection","evt","fast","featureId","keys","clearEvent","callback","coordinate","result","Object","anExtent","filter","x","y","closestFeature","closestPoint","NaN","minSquaredDistance","previousMinSquaredDistance","minDistance","Math","uid","sid","loadedExtentsRtree","extentsToLoad","extentToLoad","object","obj","removed","featureChangeKeys","idString","loader","overlaps","RBush","maxEntries","value","item","values","items","l","data","rbush"],"mappings":"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"}