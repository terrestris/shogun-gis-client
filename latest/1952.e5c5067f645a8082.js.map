{"version":3,"file":"1952.e5c5067f645a8082.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/format/xsd.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/xml.js"],"sourcesContent":["/**\n * @module ol/format/xsd\n */\nimport {padNumber} from '../string.js';\nimport {getAllTextContent, getDocument} from '../xml.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(getDocument().createTextNode(string));\n}\n","/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(thisArg ?? this, node, objectStack);\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {*} value Value to be written.\n     * @param {Array<*>} objectStack Object stack.\n     * @this {*}\n     */\n    function (node, value, objectStack) {\n      nodeWriter.call(thisArg ?? this, node, value, objectStack);\n      const parent = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const parentNode = parent.node;\n      parentNode.appendChild(node);\n    }\n  );\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined,\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack,\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n"],"names":["readDecimal","node","string","m","parseFloat","readPositiveInteger","readNonNegativeIntegerString","parseInt","readString","writeStringTextNode","xmlSerializer_","document_","XML_SCHEMA_INSTANCE_URI","createElementNS","namespaceURI","qualifiedName","getDocument","getAllTextContent","normalizeWhitespace","getAllTextContent_","accumulator","Node","String","n","isDocument","object","getAttributeNS","name","parse","xml","DOMParser","makeArrayExtender","valueReader","thisArg","objectStack","value","undefined","array","makeArrayPusher","makeReplacer","makeObjectPropertyPusher","property","makeObjectPropertySetter","makeChildAppender","nodeWriter","parentNode","parent","makeSimpleNodeFactory","fixedNodeName","fixedNamespaceURI","newNodeName","context","nodeName","OBJECT_PROPERTY_NODE_FACTORY","makeStructureNS","namespaceURIs","structure","structureNS","i","ii","parseNode","parsersNS","parsers","parser","pushParseAndPop","pushSerializeAndPop","serializersNS","nodeFactory","values","keys","length","getXMLSerializer","XMLSerializer","document"],"mappings":"sSAyCO,SAASA,EAAYC,CAAI,MASEC,EARtB,SAAkBD,EAAM,IAUlC,IAAME,EAAI,4CAA4C,IAAI,CAACD,UAC3D,AAAIC,EACKC,WAAWD,CAAC,CAAC,EAAE,QAV1B,CAmBO,SAASE,EAAoBJ,CAAI,EAEtC,OAAOK,EADG,SAAkBL,EAAM,IAEpC,CAMO,SAASK,EAA6BJ,CAAM,EACjD,IAAMC,EAAI,gBAAgB,IAAI,CAACD,GAC/B,GAAIC,EACF,OAAOI,SAASJ,CAAC,CAAC,EAAE,CAAE,GAG1B,CAMO,SAASK,EAAWP,CAAI,EAC7B,MAAO,SAAkBA,EAAM,IAAO,IAAI,EAC5C,CA8DO,SAASQ,EAAoBR,CAAI,CAAEC,CAAM,EAC9CD,EAAK,WAAW,CAAC,WAAc,cAAc,CAACC,GAChD,C,2BC4WIQ,EAuBAC,E,qfAjgBG,IAAMC,EACX,4CAOK,SAASC,EAAgBC,CAAY,CAAEC,CAAa,EACzD,OAAOC,IAAc,eAAe,CAACF,EAAcC,EACrD,CAUO,SAASE,EAAkBhB,CAAI,CAAEiB,CAAmB,EACzD,MAAOC,AAYF,UAASA,EAAmBlB,CAAI,CAAEiB,CAAmB,CAAEE,CAAW,EACvE,GACEnB,EAAK,QAAQ,EAAIoB,KAAK,kBAAkB,EACxCpB,EAAK,QAAQ,EAAIoB,KAAK,SAAS,CAE3BH,EACFE,EAAY,IAAI,CAACE,OAAOrB,EAAK,SAAS,EAAE,OAAO,CAAC,gBAAiB,KAEjEmB,EAAY,IAAI,CAACnB,EAAK,SAAS,MAE5B,CACL,IAAIsB,EACJ,IAAKA,EAAItB,EAAK,UAAU,CAAEsB,EAAGA,EAAIA,EAAE,WAAW,CAC5CJ,EAAmBI,EAAGL,EAAqBE,EAE/C,CACA,OAAOA,CACT,GA7B4BnB,EAAMiB,EAAqB,EAAE,EAAE,IAAI,CAAC,GAChE,CAkCO,SAASM,EAAWC,CAAM,EAC/B,MAAO,oBAAqBA,CAC9B,CAQO,SAASC,EAAezB,CAAI,CAAEa,CAAY,CAAEa,CAAI,EACrD,OAAO1B,EAAK,cAAc,CAACa,EAAca,IAAS,EACpD,CAQO,SAASC,EAAMC,CAAG,EACvB,OAAO,IAAIC,YAAY,eAAe,CAACD,EAAK,kBAC9C,CAUO,SAASE,EAAkBC,CAAW,CAAEC,CAAO,EACpD,OAME,SAAUhC,CAAI,CAAEiC,CAAW,EACzB,IAAMC,EAAQH,EAAY,IAAI,CAACC,GAAW,IAAI,CAAEhC,EAAMiC,GACtD,GAAIC,AAAUC,KAAAA,IAAVD,EAAqB,CACvB,IAAME,EACJH,CAAW,CAACA,EAAY,MAAM,CAAG,EAAE,CAErC,SAAOG,EAAOF,EAChB,CACF,CAEJ,CAUO,SAASG,EAAgBN,CAAW,CAAEC,CAAO,EAClD,OAME,SAAUhC,CAAI,CAAEiC,CAAW,EACzB,IAAMC,EAAQH,EAAY,IAAI,CAACC,GAAW,IAAI,CAAEhC,EAAMiC,EACxCE,MAAAA,IAAVD,GAIFE,AAFEH,CAAW,CAACA,EAAY,MAAM,CAAG,EAAE,CAE/B,IAAI,CAACC,EAEf,CAEJ,CAUO,SAASI,EAAaP,CAAW,CAAEC,CAAO,EAC/C,OAME,SAAUhC,CAAI,CAAEiC,CAAW,EACzB,IAAMC,EAAQH,EAAY,IAAI,CAACC,GAAW,IAAI,CAAEhC,EAAMiC,EAClDC,AAAUC,MAAAA,IAAVD,GACFD,CAAAA,CAAW,CAACA,EAAY,MAAM,CAAG,EAAE,CAAGC,CAAI,CAE9C,CAEJ,CAWO,SAASK,EAAyBR,CAAW,CAAES,CAAQ,CAAER,CAAO,EACrE,OAME,SAAUhC,CAAI,CAAEiC,CAAW,EACzB,IAAMC,EAAQH,EAAY,IAAI,CAACC,GAAW,IAAI,CAAEhC,EAAMiC,GACtD,GAAIC,AAAUC,KAAAA,IAAVD,EAAqB,CACvB,IAIIE,EAJEZ,EACJS,CAAW,CAACA,EAAY,MAAM,CAAG,EAAE,CAE/BP,EAAOc,AAAaL,KAAAA,IAAbK,EAAyBA,EAAWxC,EAAK,SAAS,AAE3D0B,CAAAA,KAAQF,EACVY,EAAQZ,CAAM,CAACE,EAAK,EAEpBU,EAAQ,EAAE,CACVZ,CAAM,CAACE,EAAK,CAAGU,GAEjBA,EAAM,IAAI,CAACF,EACb,CACF,CAEJ,CAUO,SAASO,EAAyBV,CAAW,CAAES,CAAQ,CAAER,CAAO,EACrE,OAME,SAAUhC,CAAI,CAAEiC,CAAW,EACzB,IAAMC,EAAQH,EAAY,IAAI,CAACC,GAAW,IAAI,CAAEhC,EAAMiC,EACxCE,MAAAA,IAAVD,GAKFV,CAAAA,AAHES,CAAW,CAACA,EAAY,MAAM,CAAG,EAAE,AAG/B,CADOO,AAAaL,KAAAA,IAAbK,EAAyBA,EAAWxC,EAAK,SAAS,CACnD,CAAGkC,CAAI,CAEvB,CAEJ,CAWO,SAASQ,EAAkBC,CAAU,CAAEX,CAAO,EACnD,OAOE,SAAUhC,CAAI,CAAEkC,CAAK,CAAED,CAAW,EAChCU,EAAW,IAAI,CAACX,GAAW,IAAI,CAAEhC,EAAMkC,EAAOD,GAK9CW,AADmBC,AAFjBZ,CAAW,CAACA,EAAY,MAAM,CAAG,EAAE,CAEX,IAAI,CACnB,WAAW,CAACjC,EACzB,CAEJ,CAyCO,SAAS8C,EAAsBC,CAAa,CAAEC,CAAiB,EACpE,OAOE,SAAUd,CAAK,CAAED,CAAW,CAAEgB,CAAW,EAIvC,IAAMjD,EAAOkD,AAFXjB,CAAW,CAACA,EAAY,MAAM,CAAG,EAAE,CAEhB,IAAI,CACrBkB,EAAWJ,EAOf,OANII,AAAahB,KAAAA,IAAbgB,GACFA,CAAAA,EAAWF,CAAU,EAKhBrC,EADLoC,AAAsBb,KAAAA,IAAtBa,EAAkCA,EAAoBhD,EAAK,YAAY,CACbmD,EAC9D,CAEJ,CASO,IAAMC,EAA+BN,IAgCrC,SAASO,EAAgBC,CAAa,CAAEC,CAAS,CAAEC,CAAW,MAE/DC,EAAGC,EACP,IAAKD,EAAI,EAFTD,EAAcA,AAAgBrB,KAAAA,IAAhBqB,EAA4BA,EAAc,CAAC,EAE7CE,EAAKJ,EAAc,MAAM,CAAEG,EAAIC,EAAI,EAAED,EAC/CD,CAAW,CAACF,CAAa,CAACG,EAAE,CAAC,CAAGF,EAElC,OAAOC,CACT,CAUO,SAASG,EAAUC,CAAS,CAAE5D,CAAI,CAAEiC,CAAW,CAAED,CAAO,EAC7D,IAAIV,EACJ,IAAKA,EAAItB,EAAK,iBAAiB,CAAEsB,EAAGA,EAAIA,EAAE,kBAAkB,CAAE,CAC5D,IAAMuC,EAAUD,CAAS,CAACtC,EAAE,YAAY,CAAC,CACzC,GAAIuC,AAAY1B,KAAAA,IAAZ0B,EAAuB,CACzB,IAAMC,EAASD,CAAO,CAACvC,EAAE,SAAS,CAAC,AAC/BwC,AAAW3B,MAAAA,IAAX2B,GACFA,EAAO,IAAI,CAAC9B,EAASV,EAAGW,EAE5B,CACF,CACF,CAaO,SAAS8B,EAAgBvC,CAAM,CAAEoC,CAAS,CAAE5D,CAAI,CAAEiC,CAAW,CAAED,CAAO,EAG3E,OAFAC,EAAY,IAAI,CAACT,GACjBmC,EAAUC,EAAW5D,EAAMiC,EAAaD,GACfC,EAAY,GAAG,EAC1C,CA8EO,SAAS+B,EACdxC,CAAM,CACNyC,CAAa,CACbC,CAAW,CACXC,CAAM,CACNlC,CAAW,CACXmC,CAAI,CACJpC,CAAO,MApDHE,EAAOlC,EAsDXiC,EAAY,IAAI,CAACT,GAvDjB,IAAM6C,EAAS,AAACD,CAAAA,AAASjC,KAAAA,IAwDkCiC,EAAAA,EAArBD,CAxDW,EAAG,MAAM,CAE1D,IAAK,IAAIV,EAAI,EAAGA,EAAIY,EAAQ,EAAEZ,EAEdtB,KAAAA,IADdD,CAAAA,EAAQiC,AAqD4BA,CArDtB,CAACV,EAAE,AAAD,GAQVzD,AAASmC,KAAAA,IANbnC,CAAAA,EAAOkE,AAmDcA,EAnDF,IAAI,CAmDsClC,EAjD3DE,EAiDwCD,EA/CxCmC,AAASjC,KAAAA,IA+C4CiC,EA/ChCA,AA+CgCA,CA/C5B,CAACX,EAAE,CAAGtB,KAAAA,EACjC,GAEE8B,AA4CIA,CA5CS,CAACjE,EAAK,YAAY,CAAC,CAACA,EAAK,SAAS,CAAC,CAAC,IAAI,CA4CMgC,EA1CzDhC,EACAkC,EAyCsCD,GAC9C,OAAmCA,EAAY,GAAG,EACpD,CAkBO,SAASqC,IAId,OAHI7D,AAAmB0B,KAAAA,IAAnB1B,GAAgC,AAAyB,aAAzB,OAAO8D,eACzC9D,CAAAA,EAAiB,IAAI8D,aAAc,EAE9B9D,CACT,CAmBO,SAASM,IAId,OAHIL,AAAcyB,KAAAA,IAAdzB,GAA2B,AAAoB,aAApB,OAAO8D,UACpC9D,CAAAA,EAAY8D,SAAS,cAAc,CAAC,cAAc,CAAC,GAAI,GAAI,KAAI,EAE1D9D,CACT,C"}