{"version":3,"file":"439.9ecb1766ec113cee.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/asserts.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/contains.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/segments.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/WMTS.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/tilegrid/common.js"],"sourcesContent":["/**\n * @module ol/asserts\n */\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {string} errorMessage Error message.\n */\nexport function assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {import('../../extent.js').Extent} [coordinatesExtent] Coordinates extent\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n  coordinatesExtent,\n) {\n  coordinatesExtent =\n    coordinatesExtent ??\n    extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (\n    (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) ||\n    (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3])\n  ) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/tilegrid\n */\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {toSize} from './size.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth,\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution,\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/tilegrid/WMTS\n */\n\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from './TileGrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes,\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(\n  matrixSet,\n  extent,\n  matrixLimits,\n) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().startsWith('ne');\n\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (!elt[identifierPropName].includes(':')) {\n          return (\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n            elt_ml[matrixIdsPropName]\n          );\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution =\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([\n          elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0],\n        ]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight],\n      );\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes,\n  });\n}\n","/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport const DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport const DEFAULT_TILE_SIZE = 256;\n"],"names":["assert","assertion","errorMessage","Error","linearRingContainsExtent","flatCoordinates","offset","end","stride","extent","coordinate","linearRingContainsXY","x","y","wn","x1","y1","x2","y2","linearRingsContainsXY","ends","i","ii","linearRingssContainsXY","endss","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","forEach","callback","ret","getForProjection","projection","tileGrid","createForProjection","wrapX","tileCoord","z","center","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","createForExtent","maxZoom","tileSize","corner","undefined","resolutions","resolutionsFromExtent","createXYZ","options","xyzOptions","gridOptions","maxResolution","height","width","length","Array","half","WMTSTileGrid","createFromCapabilitiesMatrixSet","matrixSet","matrixLimits","matrixIds","origins","tileSizes","sizes","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","code","metersPerUnit","switchOriginXY","a","b","elt","matrixAvailable","elt_ml","resolution","tileWidth","tileHeight","DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE"],"mappings":"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"}