{"version":3,"file":"5860.a1bbb1502b9e06f7.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/Collection.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/CollectionEventType.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/featureloader.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/loadingstrategy.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/source/Source.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/source/Vector.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/source/VectorEventType.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/structs/RBush.js"],"sourcesContent":["/**\n * @module ol/Collection\n */\nimport CollectionEventType from './CollectionEventType.js';\nimport BaseObject from './Object.js';\nimport Event from './events/Event.js';\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  LENGTH: 'length',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this\n * type.\n * @template T\n */\nexport class CollectionEvent extends Event {\n  /**\n   * @param {import(\"./CollectionEventType.js\").default} type Type.\n   * @param {T} element Element.\n   * @param {number} index The index of the added or removed element.\n   */\n  constructor(type, element, index) {\n    super(type);\n\n    /**\n     * The element that is added to or removed from the collection.\n     * @type {T}\n     * @api\n     */\n    this.element = element;\n\n    /**\n     * The index of the added or removed element.\n     * @type {number}\n     * @api\n     */\n    this.index = index;\n  }\n}\n\n/***\n * @template T\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types|'change:length', import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types|\n *     'change:length'|'add'|'remove',Return>} CollectionOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [unique=false] Disallow the same item from being added to\n * the collection twice.\n */\n\n/**\n * @classdesc\n * An expanded version of standard JS Array, adding convenience methods for\n * manipulation. Add and remove changes to the Collection trigger a Collection\n * event. Note that this does not cover changes to the objects _within_ the\n * Collection; they trigger events on the appropriate object, not on the\n * Collection as a whole.\n *\n * @fires CollectionEvent\n *\n * @template T\n * @api\n */\nclass Collection extends BaseObject {\n  /**\n   * @param {Array<T>} [array] Array.\n   * @param {Options} [options] Collection options.\n   */\n  constructor(array, options) {\n    super();\n\n    /***\n     * @type {CollectionOnSignature<T, import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {CollectionOnSignature<T, import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {CollectionOnSignature<T, void>}\n     */\n    this.un;\n\n    options = options || {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.unique_ = !!options.unique;\n\n    /**\n     * @private\n     * @type {!Array<T>}\n     */\n    this.array_ = array ?? [];\n\n    if (this.unique_) {\n      for (let i = 1, ii = this.array_.length; i < ii; ++i) {\n        this.assertUnique_(this.array_[i], i);\n      }\n    }\n\n    this.updateLength_();\n  }\n\n  /**\n   * Remove all elements from the collection.\n   * @api\n   */\n  clear() {\n    while (this.getLength() > 0) {\n      this.pop();\n    }\n  }\n\n  /**\n   * Add elements to the collection.  This pushes each item in the provided array\n   * to the end of the collection.\n   * @param {!Array<T>} arr Array.\n   * @return {Collection<T>} This collection.\n   * @api\n   */\n  extend(arr) {\n    for (let i = 0, ii = arr.length; i < ii; ++i) {\n      this.push(arr[i]);\n    }\n    return this;\n  }\n\n  /**\n   * Iterate over each element, calling the provided callback.\n   * @param {function(T, number, Array<T>): *} f The function to call\n   *     for every element. This function takes 3 arguments (the element, the\n   *     index and the array). The return value is ignored.\n   * @api\n   */\n  forEach(f) {\n    const array = this.array_;\n    for (let i = 0, ii = array.length; i < ii; ++i) {\n      f(array[i], i, array);\n    }\n  }\n\n  /**\n   * Get a reference to the underlying Array object. Warning: if the array\n   * is mutated, no events will be dispatched by the collection, and the\n   * collection's \"length\" property won't be in sync with the actual length\n   * of the array.\n   * @return {!Array<T>} Array.\n   * @api\n   */\n  getArray() {\n    return this.array_;\n  }\n\n  /**\n   * Get the element at the provided index.\n   * @param {number} index Index.\n   * @return {T} Element.\n   * @api\n   */\n  item(index) {\n    return this.array_[index];\n  }\n\n  /**\n   * Get the length of this collection.\n   * @return {number} The length of the array.\n   * @observable\n   * @api\n   */\n  getLength() {\n    return this.get(Property.LENGTH);\n  }\n\n  /**\n   * Insert an element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n  insertAt(index, elem) {\n    if (index < 0 || index > this.getLength()) {\n      throw new Error('Index out of bounds: ' + index);\n    }\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n    this.array_.splice(index, 0, elem);\n    this.updateLength_();\n    this.dispatchEvent(\n      new CollectionEvent(CollectionEventType.ADD, elem, index),\n    );\n  }\n\n  /**\n   * Remove the last element of the collection and return it.\n   * Return `undefined` if the collection is empty.\n   * @return {T|undefined} Element.\n   * @api\n   */\n  pop() {\n    return this.removeAt(this.getLength() - 1);\n  }\n\n  /**\n   * Insert the provided element at the end of the collection.\n   * @param {T} elem Element.\n   * @return {number} New length of the collection.\n   * @api\n   */\n  push(elem) {\n    const n = this.getLength();\n    this.insertAt(n, elem);\n    return this.getLength();\n  }\n\n  /**\n   * Remove the first occurrence of an element from the collection.\n   * @param {T} elem Element.\n   * @return {T|undefined} The removed element or undefined if none found.\n   * @api\n   */\n  remove(elem) {\n    const arr = this.array_;\n    for (let i = 0, ii = arr.length; i < ii; ++i) {\n      if (arr[i] === elem) {\n        return this.removeAt(i);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Remove the element at the provided index and return it.\n   * Return `undefined` if the collection does not contain this index.\n   * @param {number} index Index.\n   * @return {T|undefined} Value.\n   * @api\n   */\n  removeAt(index) {\n    if (index < 0 || index >= this.getLength()) {\n      return undefined;\n    }\n    const prev = this.array_[index];\n    this.array_.splice(index, 1);\n    this.updateLength_();\n    this.dispatchEvent(\n      /** @type {CollectionEvent<T>} */ (\n        new CollectionEvent(CollectionEventType.REMOVE, prev, index)\n      ),\n    );\n    return prev;\n  }\n\n  /**\n   * Set the element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n  setAt(index, elem) {\n    const n = this.getLength();\n    if (index >= n) {\n      this.insertAt(index, elem);\n      return;\n    }\n    if (index < 0) {\n      throw new Error('Index out of bounds: ' + index);\n    }\n    if (this.unique_) {\n      this.assertUnique_(elem, index);\n    }\n    const prev = this.array_[index];\n    this.array_[index] = elem;\n    this.dispatchEvent(\n      /** @type {CollectionEvent<T>} */ (\n        new CollectionEvent(CollectionEventType.REMOVE, prev, index)\n      ),\n    );\n    this.dispatchEvent(\n      /** @type {CollectionEvent<T>} */ (\n        new CollectionEvent(CollectionEventType.ADD, elem, index)\n      ),\n    );\n  }\n\n  /**\n   * @private\n   */\n  updateLength_() {\n    this.set(Property.LENGTH, this.array_.length);\n  }\n\n  /**\n   * @private\n   * @param {T} elem Element.\n   * @param {number} [except] Optional index to ignore.\n   */\n  assertUnique_(elem, except) {\n    const array = this.array_;\n    for (let i = 0, ii = array.length; i < ii; ++i) {\n      if (array[i] === elem && i !== except) {\n        throw new Error('Duplicate item added to a unique collection');\n      }\n    }\n  }\n}\n\nexport default Collection;\n","/**\n * @module ol/CollectionEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when an item is added to the collection.\n   * @event module:ol/Collection.CollectionEvent#add\n   * @api\n   */\n  ADD: 'add',\n  /**\n   * Triggered when an item is removed from the collection.\n   * @event module:ol/Collection.CollectionEvent#remove\n   * @api\n   */\n  REMOVE: 'remove',\n};\n","/**\n * @module ol/featureloader\n */\n\n/**\n *\n * @type {boolean}\n * @private\n */\nlet withCredentials = false;\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * load features.\n *\n * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing\n * the area to be loaded, a `{number}` representing the resolution (map units per pixel), a\n * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get\n * the loaded features passed as an argument and an optional failure callback with no arguments. If\n * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and\n * `'featuresloaderror'` events. `this` within the function is bound to the\n * {@link module:ol/source/Vector~VectorSource} it's called from.\n *\n * The function is responsible for loading the features and adding them to the\n * source.\n *\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").FeatureLike]\n * @typedef {(\n *           extent: import(\"./extent.js\").Extent,\n *           resolution: number,\n *           projection: import(\"./proj/Projection.js\").default,\n *           success?: (features: Array<FeatureType>) => void,\n *           failure?: () => void) => void} FeatureLoader\n * @api\n */\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * get the url to load features from.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\n * and an {@link module:ol/proj/Projection~Projection} for the projection  as\n * arguments and returns a `{string}` representing the URL.\n * @typedef {function(import(\"./extent.js\").Extent, number, import(\"./proj/Projection.js\").default): string} FeatureUrlFunction\n * @api\n */\n\n/**\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {function(Array<FeatureType>, import(\"./proj/Projection.js\").default): void} success Success\n *      Function called with the loaded features and optionally with the data projection.\n * @param {function(): void} failure Failure\n *      Function called when loading failed.\n */\nexport function loadFeaturesXhr(\n  url,\n  format,\n  extent,\n  resolution,\n  projection,\n  success,\n  failure,\n) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\n    'GET',\n    typeof url === 'function' ? url(extent, resolution, projection) : url,\n    true,\n  );\n  if (format.getType() == 'arraybuffer') {\n    xhr.responseType = 'arraybuffer';\n  }\n  xhr.withCredentials = withCredentials;\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  xhr.onload = function (event) {\n    // status will be 0 for file:// urls\n    if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {\n      const type = format.getType();\n      try {\n        /** @type {Document|Node|Object|string|undefined} */\n        let source;\n        if (type == 'text' || type == 'json') {\n          source = xhr.responseText;\n        } else if (type == 'xml') {\n          source = xhr.responseXML || xhr.responseText;\n        } else if (type == 'arraybuffer') {\n          source = /** @type {ArrayBuffer} */ (xhr.response);\n        }\n        if (source) {\n          success(\n            /** @type {Array<FeatureType>} */\n            (\n              format.readFeatures(source, {\n                extent: extent,\n                featureProjection: projection,\n              })\n            ),\n            format.readProjection(source),\n          );\n        } else {\n          failure();\n        }\n      } catch {\n        failure();\n      }\n    } else {\n      failure();\n    }\n  };\n  /**\n   * @private\n   */\n  xhr.onerror = failure;\n  xhr.send();\n}\n\n/**\n * Create an XHR feature loader for a `url` and `format`. The feature loader\n * loads features (with XHR), parses the features, and adds them to the\n * vector source.\n *\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @return {FeatureLoader<FeatureType>} The feature loader.\n * @api\n */\nexport function xhr(url, format) {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"./proj/Projection.js\").default} projection Projection.\n   * @param {function(Array<FeatureType>): void} [success] Success\n   *      Function called when loading succeeded.\n   * @param {function(): void} [failure] Failure\n   *      Function called when loading failed.\n   * @this {import(\"./source/Vector.js\").default<FeatureType>}\n   */\n  return function (extent, resolution, projection, success, failure) {\n    loadFeaturesXhr(\n      url,\n      format,\n      extent,\n      resolution,\n      projection,\n      /**\n       * @param {Array<FeatureType>} features The loaded features.\n       * @param {import(\"./proj/Projection.js\").default} dataProjection Data\n       * projection.\n       */\n      (features, dataProjection) => {\n        this.addFeatures(features);\n        if (success !== undefined) {\n          success(features);\n        }\n      },\n      () => {\n        this.changed();\n        if (failure !== undefined) {\n          failure();\n        }\n      },\n    );\n  };\n}\n\n/**\n * Setter for the withCredentials configuration for the XHR.\n *\n * @param {boolean} xhrWithCredentials The value of withCredentials to set.\n * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/\n * @api\n */\nexport function setWithCredentials(xhrWithCredentials) {\n  withCredentials = xhrWithCredentials;\n}\n","/**\n * @module ol/loadingstrategy\n */\n\nimport {fromUserExtent, fromUserResolution, toUserExtent} from './proj.js';\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function bbox(extent, resolution) {\n  return [extent];\n}\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {function(import(\"./extent.js\").Extent, number, import(\"./proj.js\").Projection): Array<import(\"./extent.js\").Extent>} Loading strategy.\n * @api\n */\nexport function tile(tileGrid) {\n  return (\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./proj.js\").Projection} projection Projection.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     */\n    function (extent, resolution, projection) {\n      const z = tileGrid.getZForResolution(\n        fromUserResolution(resolution, projection),\n      );\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        fromUserExtent(extent, projection),\n        z,\n      );\n      /** @type {Array<import(\"./extent.js\").Extent>} */\n      const extents = [];\n      /** @type {import(\"./tilecoord.js\").TileCoord} */\n      const tileCoord = [z, 0, 0];\n      for (\n        tileCoord[1] = tileRange.minX;\n        tileCoord[1] <= tileRange.maxX;\n        ++tileCoord[1]\n      ) {\n        for (\n          tileCoord[2] = tileRange.minY;\n          tileCoord[2] <= tileRange.maxY;\n          ++tileCoord[2]\n        ) {\n          extents.push(\n            toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection),\n          );\n        }\n      }\n      return extents;\n    }\n  );\n}\n","/**\n * @module ol/source/Source\n */\nimport BaseObject from '../Object.js';\nimport {get as getProjection} from '../proj.js';\n\n/**\n * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n */\n\n/**\n * A function that takes a {@link import(\"../View.js\").ViewStateLayerStateExtent} and returns a string or\n * an array of strings representing source attributions.\n *\n * @typedef {function(import(\"../View.js\").ViewStateLayerStateExtent): (string|Array<string>)} Attribution\n */\n\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * a simple string (e.g. `'© Acme Inc.'`)\n * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)\n * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {import(\"./Source.js\").State} [state='ready'] State.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\nclass Source extends BaseObject {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|null}\n     */\n    this.projection = getProjection(options.projection);\n\n    /**\n     * @private\n     * @type {?Attribution}\n     */\n    this.attributions_ = adaptAttributions(options.attributions);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;\n\n    /**\n     * This source is currently loading data. Sources that defer loading to the\n     * map's tile queue never set this to `true`.\n     * @type {boolean}\n     */\n    this.loading = false;\n\n    /**\n     * @private\n     * @type {import(\"./Source.js\").State}\n     */\n    this.state_ = options.state !== undefined ? options.state : 'ready';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = !!options.interpolate;\n\n    /**\n     * @protected\n     * @type {function(import(\"../View.js\").ViewOptions):void}\n     */\n    this.viewResolver = null;\n\n    /**\n     * @protected\n     * @type {function(Error):void}\n     */\n    this.viewRejector = null;\n\n    const self = this;\n    /**\n     * @private\n     * @type {Promise<import(\"../View.js\").ViewOptions>}\n     */\n    this.viewPromise_ = new Promise(function (resolve, reject) {\n      self.viewResolver = resolve;\n      self.viewRejector = reject;\n    });\n  }\n\n  /**\n   * Get the attribution function for the source.\n   * @return {?Attribution} Attribution function.\n   * @api\n   */\n  getAttributions() {\n    return this.attributions_;\n  }\n\n  /**\n   * @return {boolean} Attributions are collapsible.\n   * @api\n   */\n  getAttributionsCollapsible() {\n    return this.attributionsCollapsible_;\n  }\n\n  /**\n   * Get the projection of the source.\n   * @return {import(\"../proj/Projection.js\").default|null} Projection.\n   * @api\n   */\n  getProjection() {\n    return this.projection;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions(projection) {\n    return null;\n  }\n\n  /**\n   * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n   */\n  getView() {\n    return this.viewPromise_;\n  }\n\n  /**\n   * Get the state of the source, see {@link import(\"./Source.js\").State} for possible states.\n   * @return {import(\"./Source.js\").State} State.\n   * @api\n   */\n  getState() {\n    return this.state_;\n  }\n\n  /**\n   * @return {boolean|undefined} Wrap X.\n   */\n  getWrapX() {\n    return this.wrapX_;\n  }\n\n  /**\n   * @return {boolean} Use linear interpolation when resampling.\n   */\n  getInterpolate() {\n    return this.interpolate_;\n  }\n\n  /**\n   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\n   * @api\n   */\n  refresh() {\n    this.changed();\n  }\n\n  /**\n   * Set the attributions of the source.\n   * @param {AttributionLike|undefined} attributions Attributions.\n   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\n   *     or `undefined`.\n   * @api\n   */\n  setAttributions(attributions) {\n    this.attributions_ = adaptAttributions(attributions);\n    this.changed();\n  }\n\n  /**\n   * Set the state of the source.\n   * @param {import(\"./Source.js\").State} state State.\n   */\n  setState(state) {\n    this.state_ = state;\n    this.changed();\n  }\n}\n\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {Attribution|null} An attribution function (or null).\n */\nfunction adaptAttributions(attributionLike) {\n  if (!attributionLike) {\n    return null;\n  }\n  if (typeof attributionLike === 'function') {\n    return attributionLike;\n  }\n  if (!Array.isArray(attributionLike)) {\n    attributionLike = [attributionLike];\n  }\n  return (frameState) => attributionLike;\n}\n\nexport default Source;\n","/**\n * @module ol/source/Vector\n */\n\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport {extend} from '../array.js';\nimport {assert} from '../asserts.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {containsExtent, equals, wrapAndSliceX} from '../extent.js';\nimport {xhr} from '../featureloader.js';\nimport {TRUE, VOID} from '../functions.js';\nimport {all as allStrategy} from '../loadingstrategy.js';\nimport {isEmpty} from '../obj.js';\nimport RenderFeature from '../render/Feature.js';\nimport RBush from '../structs/RBush.js';\nimport {getUid} from '../util.js';\nimport Source from './Source.js';\nimport VectorEventType from './VectorEventType.js';\n\n/**\n * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\n * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\n * is one of the standard {@link module:ol/loadingstrategy} strategies.\n *\n * @typedef {function(import(\"../extent.js\").Extent, number, import(\"../proj/Projection.js\").default): Array<import(\"../extent.js\").Extent>} LoadingStrategy\n * @api\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this\n * type.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nexport class VectorSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {FeatureType} [feature] Feature.\n   * @param {Array<FeatureType>} [features] Features.\n   */\n  constructor(type, feature, features) {\n    super(type);\n\n    /**\n     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.\n     * @type {FeatureType|undefined}\n     * @api\n     */\n    this.feature = feature;\n\n    /**\n     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.\n     * @type {Array<FeatureType>|undefined}\n     * @api\n     */\n    this.features = features;\n  }\n}\n\n/***\n * @template {import(\"../Feature.js\").FeatureLike} [T=import(\"../Feature.js\").default]\n * @typedef {T extends RenderFeature ? T|Array<T> : T} FeatureClassOrArrayOfRenderFeatures\n */\n\n/***\n * @template Return\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./VectorEventType\").VectorSourceEventTypes, VectorSourceEvent<FeatureType>, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./VectorEventType\").VectorSourceEventTypes, Return>} VectorSourceOnSignature\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {Array<FeatureType>|Collection<FeatureType>} [features]\n * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source\n * and the collection will stay in sync.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] The feature format used by the XHR\n * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\n * @property {import(\"../featureloader.js\").FeatureLoader<FeatureType>} [loader]\n * The loader function used to load features, from a remote source for example.\n * If this is not set and `url` is set, the source will create and use an XHR\n * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events\n * will only fire if the `success` and `failure` callbacks are used.\n *\n * Example:\n *\n * ```js\n * import Vector from 'ol/source/Vector.js';\n * import GeoJSON from 'ol/format/GeoJSON.js';\n * import {bbox} from 'ol/loadingstrategy.js';\n *\n * const vectorSource = new Vector({\n *   format: new GeoJSON(),\n *   loader: function(extent, resolution, projection, success, failure) {\n *      const proj = projection.getCode();\n *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +\n *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +\n *          'outputFormat=application/json&srsname=' + proj + '&' +\n *          'bbox=' + extent.join(',') + ',' + proj;\n *      const xhr = new XMLHttpRequest();\n *      xhr.open('GET', url);\n *      const onError = function() {\n *        vectorSource.removeLoadedExtent(extent);\n *        failure();\n *      }\n *      xhr.onerror = onError;\n *      xhr.onload = function() {\n *        if (xhr.status == 200) {\n *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);\n *          vectorSource.addFeatures(features);\n *          success(features);\n *        } else {\n *          onError();\n *        }\n *      }\n *      xhr.send();\n *    },\n *    strategy: bbox,\n *  });\n * ```\n * @property {boolean} [overlaps=true] This source may have overlapping geometries.\n * Setting this to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {LoadingStrategy} [strategy] The loading strategy to use.\n * By default an {@link module:ol/loadingstrategy.all}\n * strategy is used, a one-off strategy which loads all features at once.\n * @property {string|import(\"../featureloader.js\").FeatureUrlFunction} [url]\n * Setting this option instructs the source to load features using an XHR loader\n * (see {@link module:ol/featureloader.xhr}). Use a `string` and an\n * {@link module:ol/loadingstrategy.all} for a one-off download of all features from\n * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with\n * other loading strategies.\n * Requires `format` to be set as well.\n * When default XHR feature loader is provided, the features will\n * be transformed from the data projection to the view projection\n * during parsing. If your remote data source does not advertise its projection\n * properly, this transformation will be incorrect. For some formats, the\n * default projection (usually EPSG:4326) can be overridden by setting the\n * dataProjection constructor option on the format.\n * Note that if a source contains non-feature data, such as a GeoJSON geometry\n * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\n * @property {boolean} [useSpatialIndex=true]\n * By default, an RTree is used as spatial index. When features are removed and\n * added frequently, and the total number of features is low, setting this to\n * `false` may improve performance.\n *\n * Note that\n * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\n * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\n * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\n * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\n * through all features.\n *\n * When set to `false`, the features will be maintained in an\n * {@link module:ol/Collection~Collection}, which can be retrieved through\n * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\n * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\n * -180° and 180° meridians to work properly, this should be set to `false`. The\n * resulting geometry coordinates will then exceed the world bounds.\n */\n\n/**\n * @classdesc\n * Provides a source of features for vector layers. Vector features provided\n * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\n * vector data that is optimized for rendering.\n *\n * @fires VectorSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nclass VectorSource extends Source {\n  /**\n   * @param {Options<FeatureType>} [options] Vector source options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super({\n      attributions: options.attributions,\n      interpolate: true,\n      projection: undefined,\n      state: 'ready',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n    });\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {import(\"../featureloader.js\").FeatureLoader<import(\"../Feature.js\").FeatureLike>}\n     */\n    this.loader_ = VOID;\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format || null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;\n\n    /**\n     * @private\n     * @type {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined}\n     */\n    this.url_ = options.url;\n\n    if (options.loader !== undefined) {\n      this.loader_ = options.loader;\n    } else if (this.url_ !== undefined) {\n      assert(this.format_, '`format` must be set when `url` is set');\n      // create a XHR feature loader for \"url\" and \"format\"\n      this.loader_ = xhr(this.url_, this.format_);\n    }\n\n    /**\n     * @private\n     * @type {LoadingStrategy}\n     */\n    this.strategy_ =\n      options.strategy !== undefined ? options.strategy : allStrategy;\n\n    const useSpatialIndex =\n      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n\n    /**\n     * @private\n     * @type {RBush<FeatureType>}\n     */\n    this.featuresRtree_ = useSpatialIndex ? new RBush() : null;\n\n    /**\n     * @private\n     * @type {RBush<{extent: import(\"../extent.js\").Extent}>}\n     */\n    this.loadedExtentsRtree_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.loadingExtentsCount_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.nullGeometryFeatures_ = {};\n\n    /**\n     * A lookup of features by id (the return from feature.getId()).\n     * @private\n     * @type {!Object<string, import('../Feature.js').FeatureLike|Array<import('../Feature.js').FeatureLike>>}\n     */\n    this.idIndex_ = {};\n\n    /**\n     * A lookup of features by uid (using getUid(feature)).\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.uidIndex_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.featureChangeKeys_ = {};\n\n    /**\n     * @private\n     * @type {Collection<FeatureType>|null}\n     */\n    this.featuresCollection_ = null;\n\n    /** @type {Collection<FeatureType>} */\n    let collection;\n    /** @type {Array<FeatureType>} */\n    let features;\n    if (Array.isArray(options.features)) {\n      features = options.features;\n    } else if (options.features) {\n      collection = options.features;\n      features = collection.getArray();\n    }\n    if (!useSpatialIndex && collection === undefined) {\n      collection = new Collection(features);\n    }\n    if (features !== undefined) {\n      this.addFeaturesInternal(features);\n    }\n    if (collection !== undefined) {\n      this.bindFeaturesCollection_(collection);\n    }\n  }\n\n  /**\n   * Add a single feature to the source.  If you want to add a batch of features\n   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\n   * instead. A feature will not be added to the source if feature with\n   * the same id is already there. The reason for this behavior is to avoid\n   * feature duplication when using bbox or tile loading strategies.\n   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,\n   * meaning that if a feature with a duplicate id is added in the collection, it will\n   * be removed from it right away.\n   * @param {FeatureType} feature Feature to add.\n   * @api\n   */\n  addFeature(feature) {\n    this.addFeatureInternal(feature);\n    this.changed();\n  }\n\n  /**\n   * Add a feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @protected\n   */\n  addFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n\n    if (!this.addToIndex_(featureKey, feature)) {\n      if (this.featuresCollection_) {\n        this.featuresCollection_.remove(feature);\n      }\n      return;\n    }\n\n    this.setupChangeEvents_(featureKey, feature);\n\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const extent = geometry.getExtent();\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.ADDFEATURE, feature),\n    );\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  setupChangeEvents_(featureKey, feature) {\n    if (feature instanceof RenderFeature) {\n      return;\n    }\n    this.featureChangeKeys_[featureKey] = [\n      listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),\n      listen(\n        feature,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleFeatureChange_,\n        this,\n      ),\n    ];\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @return {boolean} The feature is \"valid\", in the sense that it is also a\n   *     candidate for insertion into the Rtree.\n   * @private\n   */\n  addToIndex_(featureKey, feature) {\n    let valid = true;\n    if (feature.getId() !== undefined) {\n      const id = String(feature.getId());\n      if (!(id in this.idIndex_)) {\n        this.idIndex_[id] = feature;\n      } else if (feature instanceof RenderFeature) {\n        const indexedFeature = this.idIndex_[id];\n        if (!(indexedFeature instanceof RenderFeature)) {\n          valid = false;\n        } else if (!Array.isArray(indexedFeature)) {\n          this.idIndex_[id] = [indexedFeature, feature];\n        } else {\n          indexedFeature.push(feature);\n        }\n      } else {\n        valid = false;\n      }\n    }\n    if (valid) {\n      assert(\n        !(featureKey in this.uidIndex_),\n        'The passed `feature` was already added to the source',\n      );\n      this.uidIndex_[featureKey] = feature;\n    }\n    return valid;\n  }\n\n  /**\n   * Add a batch of features to the source.\n   * @param {Array<FeatureType>} features Features to add.\n   * @api\n   */\n  addFeatures(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  }\n\n  /**\n   * Add features without firing a `change` event.\n   * @param {Array<FeatureType>} features Features.\n   * @protected\n   */\n  addFeaturesInternal(features) {\n    const extents = [];\n    /** @type {Array<FeatureType>} */\n    const newFeatures = [];\n    /** @type {Array<FeatureType>} */\n    const geometryFeatures = [];\n\n    for (let i = 0, length = features.length; i < length; i++) {\n      const feature = features[i];\n      const featureKey = getUid(feature);\n      if (this.addToIndex_(featureKey, feature)) {\n        newFeatures.push(feature);\n      }\n    }\n\n    for (let i = 0, length = newFeatures.length; i < length; i++) {\n      const feature = newFeatures[i];\n      const featureKey = getUid(feature);\n      this.setupChangeEvents_(featureKey, feature);\n\n      const geometry = feature.getGeometry();\n      if (geometry) {\n        const extent = geometry.getExtent();\n        extents.push(extent);\n        geometryFeatures.push(feature);\n      } else {\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n\n    if (this.hasListener(VectorEventType.ADDFEATURE)) {\n      for (let i = 0, length = newFeatures.length; i < length; i++) {\n        this.dispatchEvent(\n          new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]),\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!Collection<FeatureType>} collection Collection.\n   * @private\n   */\n  bindFeaturesCollection_(collection) {\n    let modifyingCollection = false;\n    this.addEventListener(\n      VectorEventType.ADDFEATURE,\n      /**\n       * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.push(evt.feature);\n          modifyingCollection = false;\n        }\n      },\n    );\n    this.addEventListener(\n      VectorEventType.REMOVEFEATURE,\n      /**\n       * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.remove(evt.feature);\n          modifyingCollection = false;\n        }\n      },\n    );\n    collection.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n       */\n      (evt) => {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.addFeature(evt.element);\n          modifyingCollection = false;\n        }\n      },\n    );\n    collection.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n       */\n      (evt) => {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.removeFeature(evt.element);\n          modifyingCollection = false;\n        }\n      },\n    );\n    this.featuresCollection_ = collection;\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.\n   * @api\n   */\n  clear(fast) {\n    if (fast) {\n      for (const featureId in this.featureChangeKeys_) {\n        const keys = this.featureChangeKeys_[featureId];\n        keys.forEach(unlistenByKey);\n      }\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.uidIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.forEach((feature) => {\n          this.removeFeatureInternal(feature);\n        });\n        for (const id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n\n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n    this.nullGeometryFeatures_ = {};\n\n    const clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  }\n\n  /**\n   * Iterate through all features on the source, calling the provided callback\n   * with each one.  If the callback returns any \"truthy\" value, iteration will\n   * stop and the function will return the same value.\n   * Note: this function only iterate through the feature that have a defined geometry.\n   *\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     on the source.  Return a truthy value to stop iteration.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeature(callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometries contain the provided\n   * coordinate, calling the callback with each feature.  If the callback returns\n   * a \"truthy\" value, iteration will stop and the function will return the same\n   * value.\n   *\n   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be\n   * called for all features.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose goemetry contains the provided coordinate.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   */\n  forEachFeatureAtCoordinateDirect(coordinate, callback) {\n    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent, function (feature) {\n      const geometry = feature.getGeometry();\n      if (\n        geometry instanceof RenderFeature ||\n        geometry.intersectsCoordinate(coordinate)\n      ) {\n        return callback(feature);\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * Iterate through all features whose bounding box intersects the provided\n   * extent (note that the feature's geometry may not intersect the extent),\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you are interested in features whose geometry intersects an extent, call\n   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\n   *\n   * When `useSpatialIndex` is set to false, this method will loop through all\n   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose bounding box intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureInExtent(extent, callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent, callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometry intersects the provided extent,\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you only want to test for bounding box intersection, call the\n   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose geometry intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureIntersectingExtent(extent, callback) {\n    return this.forEachFeatureInExtent(\n      extent,\n      /**\n       * @param {FeatureType} feature Feature.\n       * @return {T|undefined} The return value from the last call to the callback.\n       */\n      function (feature) {\n        const geometry = feature.getGeometry();\n        if (\n          geometry instanceof RenderFeature ||\n          geometry.intersectsExtent(extent)\n        ) {\n          const result = callback(feature);\n          if (result) {\n            return result;\n          }\n        }\n      },\n    );\n  }\n\n  /**\n   * Get the features collection associated with this source. Will be `null`\n   * unless the source was configured with `useSpatialIndex` set to `false`, or\n   * with a {@link module:ol/Collection~Collection} as `features`.\n   * @return {Collection<FeatureType>|null} The collection of features.\n   * @api\n   */\n  getFeaturesCollection() {\n    return this.featuresCollection_;\n  }\n\n  /**\n   * Get a snapshot of the features currently on the source in random order. The returned array\n   * is a copy, the features are references to the features in the source.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeatures() {\n    let features;\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray().slice(0);\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n      if (!isEmpty(this.nullGeometryFeatures_)) {\n        extend(features, Object.values(this.nullGeometryFeatures_));\n      }\n    }\n    return features;\n  }\n\n  /**\n   * Get all features whose geometry intersects the provided coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesAtCoordinate(coordinate) {\n    /** @type {Array<FeatureType>} */\n    const features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {\n      features.push(feature);\n    });\n    return features;\n  }\n\n  /**\n   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of\n   * all features intersecting the given extent in random order (so it may include\n   * features whose geometries do not intersect the extent).\n   *\n   * When `useSpatialIndex` is set to false, this method will return all\n   * features.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Include features\n   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent, projection) {\n    if (this.featuresRtree_) {\n      const multiWorld = projection && projection.canWrapX() && this.getWrapX();\n\n      if (!multiWorld) {\n        return this.featuresRtree_.getInExtent(extent);\n      }\n\n      const extents = wrapAndSliceX(extent, projection);\n\n      return [].concat(\n        ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent)),\n      );\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getArray().slice(0);\n    }\n    return [];\n  }\n\n  /**\n   * Get the closest feature to the provided coordinate.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false` and the features in this source are of type\n   * {@link module:ol/Feature~Feature}.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType):boolean} [filter] Feature filter function.\n   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}\n   *     and it should return a boolean value. By default, no filtering is made.\n   * @return {FeatureType|null} Closest feature (or `null` if none found).\n   * @api\n   */\n  getClosestFeatureToCoordinate(coordinate, filter) {\n    // Find the closest feature using branch and bound.  We start searching an\n    // infinite extent, and find the distance from the first feature found.  This\n    // becomes the closest feature.  We then compute a smaller extent which any\n    // closer feature must intersect.  We continue searching with this smaller\n    // extent, trying to find a closer feature.  Every time we find a closer\n    // feature, we update the extent being searched so that any even closer\n    // feature must intersect it.  We continue until we run out of features.\n    const x = coordinate[0];\n    const y = coordinate[1];\n    let closestFeature = null;\n    const closestPoint = [NaN, NaN];\n    let minSquaredDistance = Infinity;\n    const extent = [-Infinity, -Infinity, Infinity, Infinity];\n    filter = filter ? filter : TRUE;\n    this.featuresRtree_.forEachInExtent(\n      extent,\n      /**\n       * @param {FeatureType} feature Feature.\n       */\n      function (feature) {\n        if (filter(feature)) {\n          const geometry = feature.getGeometry();\n          const previousMinSquaredDistance = minSquaredDistance;\n          minSquaredDistance =\n            geometry instanceof RenderFeature\n              ? 0\n              : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);\n          if (minSquaredDistance < previousMinSquaredDistance) {\n            closestFeature = feature;\n            // This is sneaky.  Reduce the extent that it is currently being\n            // searched while the R-Tree traversal using this same extent object\n            // is still in progress.  This is safe because the new extent is\n            // strictly contained by the old extent.\n            const minDistance = Math.sqrt(minSquaredDistance);\n            extent[0] = x - minDistance;\n            extent[1] = y - minDistance;\n            extent[2] = x + minDistance;\n            extent[3] = y + minDistance;\n          }\n        }\n      },\n    );\n    return closestFeature;\n  }\n\n  /**\n   * Get the extent of the features currently in the source.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import(\"../extent.js\").Extent} [extent] Destination extent. If provided, no new extent\n   *     will be created. Instead, that extent's coordinates will be overwritten.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent(extent) {\n    return this.featuresRtree_.getExtent(extent);\n  }\n\n  /**\n   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s\n   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling\n   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per\n   * `GeometryCollection` member.\n   * Note that the index treats string and numeric identifiers as the same.  So\n   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n   *\n   * @param {string|number} id Feature identifier.\n   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).\n   * @api\n   */\n  getFeatureById(id) {\n    const feature = this.idIndex_[id.toString()];\n    return feature !== undefined\n      ? /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */ (\n          feature\n        )\n      : null;\n  }\n\n  /**\n   * Get a feature by its internal unique identifier (using `getUid`).\n   *\n   * @param {string} uid Feature identifier.\n   * @return {FeatureType|null} The feature (or `null` if not found).\n   */\n  getFeatureByUid(uid) {\n    const feature = this.uidIndex_[uid];\n    return feature !== undefined ? feature : null;\n  }\n\n  /**\n   * Get the format associated with this source.\n   *\n   * @return {import(\"../format/Feature.js\").default<FeatureType>|null}} The feature format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * Get the url associated with this source.\n   *\n   * @return {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined} The url.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  handleFeatureChange_(event) {\n    const feature = /** @type {FeatureType} */ (event.target);\n    const featureKey = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature);\n        }\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    } else {\n      const extent = geometry.getExtent();\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent, feature);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent, feature);\n        }\n      }\n    }\n    const id = feature.getId();\n    if (id !== undefined) {\n      const sid = id.toString();\n      if (this.idIndex_[sid] !== feature) {\n        this.removeFromIdIndex_(feature);\n        this.idIndex_[sid] = feature;\n      }\n    } else {\n      this.removeFromIdIndex_(feature);\n      this.uidIndex_[featureKey] = feature;\n    }\n    this.changed();\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature),\n    );\n  }\n\n  /**\n   * Returns true if the feature is contained within the source.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} Has feature.\n   * @api\n   */\n  hasFeature(feature) {\n    const id = feature.getId();\n    if (id !== undefined) {\n      return id in this.idIndex_;\n    }\n    return getUid(feature) in this.uidIndex_;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    if (this.featuresRtree_) {\n      return (\n        this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_)\n      );\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getLength() === 0;\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const extentsToLoad = this.strategy_(extent, resolution, projection);\n    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n      const extentToLoad = extentsToLoad[i];\n      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(\n        extentToLoad,\n        /**\n         * @param {{extent: import(\"../extent.js\").Extent}} object Object.\n         * @return {boolean} Contains.\n         */\n        function (object) {\n          return containsExtent(object.extent, extentToLoad);\n        },\n      );\n      if (!alreadyLoaded) {\n        ++this.loadingExtentsCount_;\n        this.dispatchEvent(\n          new VectorSourceEvent(VectorEventType.FEATURESLOADSTART),\n        );\n        this.loader_.call(\n          this,\n          extentToLoad,\n          resolution,\n          projection,\n          /**\n           * @param {Array<FeatureType>} features Loaded features\n           */\n          (features) => {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(\n                VectorEventType.FEATURESLOADEND,\n                undefined,\n                features,\n              ),\n            );\n          },\n          () => {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(VectorEventType.FEATURESLOADERROR),\n            );\n          },\n        );\n        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});\n      }\n    }\n    this.loading =\n      this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;\n  }\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear(true);\n    this.loadedExtentsRtree_.clear();\n    super.refresh();\n  }\n\n  /**\n   * Remove an extent from the list of loaded extents.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  removeLoadedExtent(extent) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const obj = loadedExtentsRtree.forEachInExtent(extent, function (object) {\n      if (equals(object.extent, extent)) {\n        return object;\n      }\n    });\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  }\n\n  /**\n   * Batch remove features from the source.  If you want to remove all features\n   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\n   * instead.\n   * @param {Array<FeatureType>} features Features to remove.\n   * @api\n   */\n  removeFeatures(features) {\n    let removed = false;\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      removed = this.removeFeatureInternal(features[i]) || removed;\n    }\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove a single feature from the source. If you want to batch remove\n   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method\n   * instead.\n   * @param {FeatureType} feature Feature to remove.\n   * @api\n   */\n  removeFeature(feature) {\n    if (!feature) {\n      return;\n    }\n    const removed = this.removeFeatureInternal(feature);\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} True if the feature was removed, false if it was not found.\n   * @protected\n   */\n  removeFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n    if (!(featureKey in this.uidIndex_)) {\n      return false;\n    }\n\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n    }\n\n    const featureChangeKeys = this.featureChangeKeys_[featureKey];\n    featureChangeKeys?.forEach(unlistenByKey);\n    delete this.featureChangeKeys_[featureKey];\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      const idString = id.toString();\n      const indexedFeature = this.idIndex_[idString];\n      if (indexedFeature === feature) {\n        delete this.idIndex_[idString];\n      } else if (Array.isArray(indexedFeature)) {\n        indexedFeature.splice(indexedFeature.indexOf(feature), 1);\n        if (indexedFeature.length === 1) {\n          this.idIndex_[idString] = indexedFeature[0];\n        }\n      }\n    }\n    delete this.uidIndex_[featureKey];\n    if (this.hasListener(VectorEventType.REMOVEFEATURE)) {\n      this.dispatchEvent(\n        new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature),\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Remove a feature from the id index.  Called internally when the feature id\n   * may have changed.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  removeFromIdIndex_(feature) {\n    for (const id in this.idIndex_) {\n      if (this.idIndex_[id] === feature) {\n        delete this.idIndex_[id];\n        break;\n      }\n    }\n  }\n\n  /**\n   * Set the new loader of the source. The next render cycle will use the\n   * new loader.\n   * @param {import(\"../featureloader.js\").FeatureLoader} loader The loader to set.\n   * @api\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * Points the source to a new url. The next render cycle will use the new url.\n   * @param {string|import(\"../featureloader.js\").FeatureUrlFunction} url Url.\n   * @api\n   */\n  setUrl(url) {\n    assert(this.format_, '`format` must be set when `url` is set');\n    this.url_ = url;\n    this.setLoader(xhr(url, this.format_));\n  }\n\n  /**\n   * @param {boolean} overlaps The source can have overlapping geometries.\n   */\n  setOverlaps(overlaps) {\n    this.overlaps_ = overlaps;\n    this.changed();\n  }\n}\n\nexport default VectorSource;\n","/**\n * @module ol/source/VectorEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a feature is added to the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#addfeature\n   * @api\n   */\n  ADDFEATURE: 'addfeature',\n\n  /**\n   * Triggered when a feature is updated.\n   * @event module:ol/source/Vector.VectorSourceEvent#changefeature\n   * @api\n   */\n  CHANGEFEATURE: 'changefeature',\n\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#clear\n   * @api\n   */\n  CLEAR: 'clear',\n\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.\n   * @event module:ol/source/Vector.VectorSourceEvent#removefeature\n   * @api\n   */\n  REMOVEFEATURE: 'removefeature',\n\n  /**\n   * Triggered when features starts loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart\n   * @api\n   */\n  FEATURESLOADSTART: 'featuresloadstart',\n\n  /**\n   * Triggered when features finishes loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend\n   * @api\n   */\n  FEATURESLOADEND: 'featuresloadend',\n\n  /**\n   * Triggered if feature loading results in an error.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror\n   * @api\n   */\n  FEATURESLOADERROR: 'featuresloaderror',\n};\n\n/**\n * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes\n */\n","/**\n * @module ol/structs/RBush\n */\nimport RBush_ from 'rbush';\nimport {createOrUpdate, equals} from '../extent.js';\nimport {isEmpty} from '../obj.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {import(\"rbush\").BBox & {value: T}} Entry\n * @template T\n */\n\n/**\n * @classdesc\n * Wrapper around the RBush by Vladimir Agafonkin.\n * See https://github.com/mourner/rbush.\n *\n * @template {Object} T\n */\nclass RBush {\n  /**\n   * @param {number} [maxEntries] Max entries.\n   */\n  constructor(maxEntries) {\n    /**\n     * @private\n     * @type {RBush_<Entry<T>>}\n     */\n    this.rbush_ = new RBush_(maxEntries);\n\n    /**\n     * A mapping between the objects added to this rbush wrapper\n     * and the objects that are actually added to the internal rbush.\n     * @private\n     * @type {Object<string, Entry<T>>}\n     */\n    this.items_ = {};\n  }\n\n  /**\n   * Insert a value into the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  insert(extent, value) {\n    /** @type {Entry<T>} */\n    const item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value,\n    };\n\n    this.rbush_.insert(item);\n    this.items_[getUid(value)] = item;\n  }\n\n  /**\n   * Bulk-insert values into the RBush.\n   * @param {Array<import(\"../extent.js\").Extent>} extents Extents.\n   * @param {Array<T>} values Values.\n   */\n  load(extents, values) {\n    const items = new Array(values.length);\n    for (let i = 0, l = values.length; i < l; i++) {\n      const extent = extents[i];\n      const value = values[i];\n\n      /** @type {Entry<T>} */\n      const item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value,\n      };\n      items[i] = item;\n      this.items_[getUid(value)] = item;\n    }\n    this.rbush_.load(items);\n  }\n\n  /**\n   * Remove a value from the RBush.\n   * @param {T} value Value.\n   * @return {boolean} Removed.\n   */\n  remove(value) {\n    const uid = getUid(value);\n\n    // get the object in which the value was wrapped when adding to the\n    // internal rbush. then use that object to do the removal.\n    const item = this.items_[uid];\n    delete this.items_[uid];\n    return this.rbush_.remove(item) !== null;\n  }\n\n  /**\n   * Update the extent of a value in the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  update(extent, value) {\n    const item = this.items_[getUid(value)];\n    const bbox = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!equals(bbox, extent)) {\n      this.remove(value);\n      this.insert(extent, value);\n    }\n  }\n\n  /**\n   * Return all values in the RBush.\n   * @return {Array<T>} All.\n   */\n  getAll() {\n    const items = this.rbush_.all();\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Return all values in the given extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<T>} All in extent.\n   */\n  getInExtent(extent) {\n    /** @type {import(\"rbush\").BBox} */\n    const bbox = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n    };\n    const items = this.rbush_.search(bbox);\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Calls a callback function with each value in the tree.\n   * If the callback returns a truthy value, this value is returned without\n   * checking the rest of the tree.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   */\n  forEach(callback) {\n    return this.forEach_(this.getAll(), callback);\n  }\n\n  /**\n   * Calls a callback function with each value in the provided extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   */\n  forEachInExtent(extent, callback) {\n    return this.forEach_(this.getInExtent(extent), callback);\n  }\n\n  /**\n   * @param {Array<T>} values Values.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   * @private\n   */\n  forEach_(values, callback) {\n    let result;\n    for (let i = 0, l = values.length; i < l; i++) {\n      result = callback(values[i]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.items_);\n  }\n\n  /**\n   * Remove all values from the RBush.\n   */\n  clear() {\n    this.rbush_.clear();\n    this.items_ = {};\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getExtent(extent) {\n    const data = this.rbush_.toJSON();\n    return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);\n  }\n\n  /**\n   * @param {RBush<T>} rbush R-Tree.\n   */\n  concat(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (const i in rbush.items_) {\n      this.items_[i] = rbush.items_[i];\n    }\n  }\n}\n\nexport default RBush;\n"],"names":["Error","e","i","XMLHttpRequest","s","r","a","Promise","Array","l","String","Object","NaN","Math"],"mappings":"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"}