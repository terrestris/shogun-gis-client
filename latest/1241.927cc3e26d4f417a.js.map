{"version":3,"file":"1241.927cc3e26d4f417a.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/interpolate.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/MultiLineString.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/length.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/LineString.js"],"sourcesContent":["/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  fraction,\n  dest,\n  dimension,\n) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t =\n        (target - cumulativeLengths[-index - 2]) /\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] =\n      o === undefined\n        ? NaN\n        : t === undefined\n          ? flatCoordinates[o + i]\n          : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  m,\n  extrapolate,\n) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(\n      lerp(\n        flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i],\n        t,\n      ),\n    );\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  m,\n  extrapolate,\n  interpolate,\n) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates,\n      offset,\n      ends[ends.length - 1],\n      stride,\n      m,\n      extrapolate,\n    );\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    }\n    if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        m,\n        false,\n      );\n    }\n    offset = end;\n  }\n  return null;\n}\n","/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {\n  interpolatePoint,\n  lineStringsCoordinateAtM,\n} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.ends_ = ends;\n    } else {\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      const layout =\n        lineStrings.length === 0\n          ? this.getLayout()\n          : lineStrings[0].getLayout();\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const multiLineString = new MultiLineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice(),\n    );\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (\n      (this.layout != 'XYM' && this.layout != 'XYZM') ||\n      this.flatCoordinates.length === 0\n    ) {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      m,\n      extrapolate,\n      interpolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index],\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(\n        flatCoordinates.slice(offset, end),\n        layout,\n      );\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    /** @type {Array<number>} */\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        0.5,\n      );\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds,\n    );\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiLineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_,\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default MultiLineString;\n","/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  let length = 0;\n  for (let i = offset + stride; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n","/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    extend(this.flatCoordinates, coordinate);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const lineString = new LineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      callback,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    return lineStringCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      m,\n      extrapolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, dest) {\n    return interpolatePoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      fraction,\n      dest,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(\n        0.5,\n        this.flatMidpoint_ ?? undefined,\n      );\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatMidpoint_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    return new LineString(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'LineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent,\n      this.getExtent(),\n    );\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default LineString;\n"],"names":["Math","Array","NaN","l","s","h","e","i","f"],"mappings":"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"}