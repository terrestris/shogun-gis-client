{"version":3,"file":"1241.1e0bdccd59132b69.js","sources":["webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/LineString.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/MultiLineString.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/interpolate.js","webpack://@terrestris/shogun-gis-client/./node_modules/ol/geom/flat/length.js"],"sourcesContent":["/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    extend(this.flatCoordinates, coordinate);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const lineString = new LineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      callback,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    return lineStringCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      m,\n      extrapolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, dest) {\n    return interpolatePoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      fraction,\n      dest,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(\n        0.5,\n        this.flatMidpoint_ ?? undefined,\n      );\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatMidpoint_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    return new LineString(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'LineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent,\n      this.getExtent(),\n    );\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default LineString;\n","/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {\n  interpolatePoint,\n  lineStringsCoordinateAtM,\n} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.ends_ = ends;\n    } else {\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      const layout =\n        lineStrings.length === 0\n          ? this.getLayout()\n          : lineStrings[0].getLayout();\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const multiLineString = new MultiLineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice(),\n    );\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (\n      (this.layout != 'XYM' && this.layout != 'XYZM') ||\n      this.flatCoordinates.length === 0\n    ) {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      m,\n      extrapolate,\n      interpolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index],\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(\n        flatCoordinates.slice(offset, end),\n        layout,\n      );\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    /** @type {Array<number>} */\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        0.5,\n      );\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds,\n    );\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiLineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_,\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default MultiLineString;\n","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  fraction,\n  dest,\n  dimension,\n) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t =\n        (target - cumulativeLengths[-index - 2]) /\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] =\n      o === undefined\n        ? NaN\n        : t === undefined\n          ? flatCoordinates[o + i]\n          : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  m,\n  extrapolate,\n) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(\n      lerp(\n        flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i],\n        t,\n      ),\n    );\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  m,\n  extrapolate,\n  interpolate,\n) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates,\n      offset,\n      ends[ends.length - 1],\n      stride,\n      m,\n      extrapolate,\n    );\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    }\n    if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        m,\n        false,\n      );\n    }\n    offset = end;\n  }\n  return null;\n}\n","/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  let length = 0;\n  for (let i = offset + stride; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n"],"names":["LineString","coordinates","layout","undefined","Array","coordinate","lineString","x","y","closestPoint","minSquaredDistance","Math","callback","m","extrapolate","fraction","dest","squaredTolerance","simplifiedFlatCoordinates","extent","MultiLineString","ends","flatCoordinates","i","ii","lineStrings","multiLineString","interpolate","index","offset","end","midpoints","stride","midpoint","simplifiedEnds","interpolatePoint","dimension","o","t","n","x1","y1","length","cumulativeLengths","x2","y2","target","NaN","lineStringCoordinateAtM","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","lineStringLength"],"mappings":"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"}